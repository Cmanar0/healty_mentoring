<style>
/* Time Correction Isolated Modal Styles */
.tc-modal-standard {
    max-width: 920px !important;
    height: 600px !important;
    padding: 0 !important;
    overflow: hidden !important;
}
.tc-grid {
    display: grid;
    grid-template-columns: 360px 1fr;
    height: 100%;
}
.tc-sidebar {
    background: #f8fafc;
    border-right: 1px solid #e2e8f0;
    padding: 32px;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    overflow-x: hidden;
    height: 100%;
    box-sizing: border-box;
}
.tc-main {
    padding: 40px;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    height: 100%;
    box-sizing: border-box;
}
.tc-header {
    margin-bottom: 32px;
}
.tc-placeholder-text {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #94a3b8;
    font-size: 0.95rem;
    line-height: 1.5;
    text-align: center;
    padding: 0 20px;
}
.tc-preview-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: transparent;
    padding: 0;
    border-radius: 0;
    border: none;
    overflow: hidden;
}
.tc-preview-header {
    font-size: 0.75rem;
    font-weight: 700;
    color: #475569;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
}
.tc-options-list {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 10px;
    overflow-y: auto;
    padding: 8px;
    margin-right: -4px;
    min-height: 0;
}
.tc-option-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px 16px;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    min-width: 0; /* Allow container to shrink */
    width: 100%;
    box-sizing: border-box;
}
.tc-option-item:hover {
    border-color: #cbd5e1;
    background: #f8fafc;
    transform: translateY(-1px);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
}
.tc-option-item.selected {
    background: #eff6ff;
    border-color: #3b82f6;
    box-shadow: 0 0 0 1px #3b82f6;
}
.tc-option-radio {
    width: 18px;
    height: 18px;
    margin: 0;
    cursor: pointer;
    accent-color: #3b82f6;
}
.tc-option-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 2px;
    min-width: 0; /* Critical for wrapping children in flex container */
}
.tc-option-name {
    font-size: 0.95rem;
    font-weight: 700;
    color: #1e293b;
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
}
.tc-option-id {
    font-size: 0.75rem;
    color: #64748b;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    word-wrap: break-word;
    overflow-wrap: break-word;
}
.tc-option-offset {
    font-size: 0.85rem;
    font-weight: 600;
    color: #3b82f6;
    background: rgba(59, 130, 246, 0.1);
    padding: 4px 8px;
    border-radius: 6px;
    white-space: nowrap;
}
.tc-modal-standard .booking-modal-title {
    font-size: 1.75rem;
    color: #1e293b;
    margin-bottom: 8px;
    font-weight: 800;
    letter-spacing: -0.025em;
}

/* Dynamic Selection Info Styles */
.tc-selected-tz-info {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 16px 20px;
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 12px;
    margin-top: 24px;
    margin-bottom: 24px;
    transition: all 0.3s ease;
}
.tc-selected-tz-info.has-selection {
    background: #f0f9ff;
    border-color: #bae6fd;
}
.tc-selected-tz-icon {
    width: 40px;
    height: 40px;
    background: white;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #3b82f6;
    font-size: 1.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
.tc-selected-tz-details {
    flex: 1;
}
.tc-selected-tz-label {
    font-size: 0.7rem;
    font-weight: 700;
    color: #94a3b8;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 2px;
}
.tc-selected-tz-value {
    font-size: 1rem;
    font-weight: 700;
    color: #1e293b;
}
</style>

<!-- Time Correction Modal (Isolated UI) -->
<div id="timeCorrectionModal" class="booking-modal-overlay" style="display: none; z-index: 10001;">
    <div class="booking-modal-container tc-modal-standard">
        <button class="booking-close-btn" onclick="closeTimeCorrectionModal()"><i class="fas fa-times"></i></button>
        
        <div class="tc-grid">
            <!-- Left Column: Matching Results -->
            <div class="tc-sidebar">
                <div id="timeCorrectionPreview" class="tc-preview-section">
                    <div class="tc-preview-header">
                        <i class="fas fa-search-location"></i>
                        <span>Matching Timezone(s)</span>
                    </div>
                    <div id="timeCorrectionTimezoneList" class="tc-options-list">
                        <div class="tc-placeholder-text">
                            Enter your current local time on the right to find matching timezones...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Controls & Actions -->
            <div class="tc-main">
                <div class="tc-header">
                    <h2 class="booking-modal-title">Correct Your Time</h2>
                    <p class="time-correction-desc">
                        What time is it for you right now? We'll set your timezone accordingly to ensure your session starts exactly when you expect.
                    </p>
                </div>
                
                <div class="tc-form-body">
                    <!-- Time Input -->
                    <div class="time-input-container">
                        <label class="time-input-label">
                            What is Your Current Time? <span class="required-asterisk">*</span>
                        </label>
                        <div class="time-input-wrapper">
                            <input 
                                type="time" 
                                id="correctTimeInput" 
                                class="modern-time-input" 
                                required 
                            >
                        </div>
                        <p class="time-input-helper">
                            Set this to match your current local time.
                        </p>
                    </div>

                    <!-- Selected Info -->
                    <div id="tcSelectedTzInfo" class="tc-selected-tz-info">
                        <div class="tc-selected-tz-icon">
                            <i class="fas fa-globe-americas"></i>
                        </div>
                        <div class="tc-selected-tz-details">
                            <div class="tc-selected-tz-label">Selected Timezone</div>
                            <div id="tcSelectedTzName" class="tc-selected-tz-value">Please select...</div>
                        </div>
                    </div>

                    <!-- Actions -->
                    <div class="time-correction-actions">
                        <button 
                            type="button"
                            onclick="closeTimeCorrectionModal()"
                            class="btn-cancel-correction"
                        >
                            Cancel
                        </button>
                        <button 
                            type="button"
                            id="confirmTimeCorrectionBtn"
                            onclick="confirmTimeCorrection()"
                            class="btn-confirm-correction"
                            disabled
                        >
                            Use this Timezone
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let selectedTimezoneFromTime = null;

    function openTimeCorrectionModal() {
        const modal = document.getElementById('timeCorrectionModal');
        if (!modal) return;
        
        // Set current time as default
        const now = new Date();
        const hours24 = now.getHours();
        const minutes = now.getMinutes();
        
        const timeInput = document.getElementById('correctTimeInput');
        
        if (timeInput) {
            // Format as HH:MM for time input (24-hour format)
            timeInput.value = `${String(hours24).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }
        
        // Reset UI state
        const confirmBtn = document.getElementById('confirmTimeCorrectionBtn');
        if (confirmBtn) {
            confirmBtn.disabled = true;
        }
        selectedTimezoneFromTime = null;
        
        // Show modal
        modal.style.display = 'flex';
        setTimeout(() => {
            modal.style.opacity = '1';
        }, 10);
        
        // Update preview as user changes time
        if (timeInput) {
            // Remove any existing listeners by cloning (to avoid duplicates)
            const oldInput = timeInput;
            const newTimeInput = oldInput.cloneNode(true);
            oldInput.parentNode.replaceChild(newTimeInput, oldInput);
            
            // Add event listeners to the new input
            newTimeInput.addEventListener('input', updateTimeCorrectionPreview);
            newTimeInput.addEventListener('change', updateTimeCorrectionPreview);
            
            // Trigger preview update immediately with the default time
            // Use a small delay to ensure modal is fully rendered
            setTimeout(() => {
                updateTimeCorrectionPreview();
            }, 200);
        }
    }
    
    function closeTimeCorrectionModal() {
        const modal = document.getElementById('timeCorrectionModal');
        if (modal) {
            modal.style.opacity = '0';
            setTimeout(() => {
                modal.style.display = 'none';
            }, 200);
        }
    }
    
    function updateTimeCorrectionPreview() {
        const timeInput = document.getElementById('correctTimeInput');
        const tzList = document.getElementById('timeCorrectionTimezoneList');
        const confirmBtn = document.getElementById('confirmTimeCorrectionBtn');
        
        if (!timeInput || !tzList || !confirmBtn) {
            return;
        }
        
        const timeValue = timeInput.value;
        
        if (!timeValue) {
            tzList.innerHTML = `<div class="tc-placeholder-text">Enter your current local time on the right to find matching timezones...</div>`;
            confirmBtn.disabled = true;
            selectedTimezoneFromTime = null;
            return;
        }
        
        // Parse user's entered time (time input is in 24-hour format: HH:MM)
        const [hours24, minutes] = timeValue.split(':').map(Number);
        
        if (isNaN(hours24) || isNaN(minutes)) {
            console.log('Invalid time format:', timeValue);
            return;
        }
        
        // Get current UTC time
        const now = new Date();
        const utcHours = now.getUTCHours();
        const utcMinutes = now.getUTCMinutes();
        
        // Calculate offset in minutes
        const userTimeMinutes = hours24 * 60 + minutes;
        const utcTimeMinutes = utcHours * 60 + utcMinutes;
        let offsetMinutes = userTimeMinutes - utcTimeMinutes;
        
        // Normalize to -12 to +12 hours range
        while (offsetMinutes > 12 * 60) offsetMinutes -= 24 * 60;
        while (offsetMinutes < -12 * 60) offsetMinutes += 24 * 60;
        
        console.log('Calculated offset:', offsetMinutes, 'minutes (', (offsetMinutes / 60).toFixed(2), 'hours)');
        
        // Find matching timezones (buildTimezoneList handles TIMEZONE_OPTIONS availability)
        const matchingTimezones = findTimezonesByOffset(offsetMinutes);
        
        console.log('Found matching timezones:', matchingTimezones.length);
        
        if (matchingTimezones.length > 0) {
            // Clear previous list
            tzList.innerHTML = '';
            confirmBtn.innerHTML = 'Use this Timezone';
            
            // Show timezone options
            matchingTimezones.forEach((tz, index) => {
                const tzItem = document.createElement('div');
                tzItem.className = 'tc-option-item' + (index === 0 ? ' selected' : '');
                tzItem.innerHTML = `
                    <input type="radio" name="timezoneSelection" value="${tz.id}" id="tcOption${index}" ${index === 0 ? 'checked' : ''} class="tc-option-radio">
                    <div class="tc-option-content">
                        <div class="tc-option-name">${tz.name || tz.id}</div>
                        <div class="tc-option-id">${tz.id}</div>
                    </div>
                    <div class="tc-option-offset">${tz.offset || ''}</div>
                `;
                
                // Add click handler
                tzItem.addEventListener('click', function(e) {
                    const radio = this.querySelector('input[type="radio"]');
                    if (radio) {
                        radio.checked = true;
                        // Update all items styling
                        tzList.querySelectorAll('.tc-option-item').forEach(item => {
                            if (item.querySelector('input[type="radio"]:checked')) {
                                item.classList.add('selected');
                            } else {
                                item.classList.remove('selected');
                            }
                        });
                        selectedTimezoneFromTime = radio.value;
                        confirmBtn.innerHTML = 'Use this Timezone';
                        
                        // Update dynamic selection info
                        const nameEl = document.getElementById('tcSelectedTzName');
                        const infoContainer = document.getElementById('tcSelectedTzInfo');
                        if (nameEl && infoContainer) {
                            nameEl.textContent = tz.name || tz.id;
                            infoContainer.classList.add('has-selection');
                        }
                    }
                });
                
                // Set initial selected
                if (index === 0) {
                    selectedTimezoneFromTime = tz.id;
                    const nameEl = document.getElementById('tcSelectedTzName');
                    const infoContainer = document.getElementById('tcSelectedTzInfo');
                    if (nameEl && infoContainer) {
                        nameEl.textContent = tz.name || tz.id;
                        infoContainer.classList.add('has-selection');
                    }
                }
                
                tzList.appendChild(tzItem);
            });
            
            confirmBtn.disabled = false;
        } else {
            tzList.innerHTML = `<div class="tc-placeholder-text">No matching timezones found for this time. Try adjusting the minutes.</div>`;
            confirmBtn.disabled = true;
            selectedTimezoneFromTime = null;
            
            // Reset selection info
            const nameEl = document.getElementById('tcSelectedTzName');
            const infoContainer = document.getElementById('tcSelectedTzInfo');
            if (nameEl && infoContainer) {
                nameEl.textContent = 'Please select...';
                infoContainer.classList.remove('has-selection');
            }
        }
    }
    
    // Helper functions for timezone handling
    if (typeof formatTimezoneName !== 'function') {
        window.formatTimezoneName = function(id) {
            try {
                const parts = id.split('/');
                const city = parts[parts.length - 1] || id;
                return city.replace(/_/g, ' ');
            } catch (e) {
                return id;
            }
        }
    }
    
    if (typeof deriveRegion !== 'function') {
        window.deriveRegion = function(id) {
            try {
                const parts = id.split('/');
                return parts.length > 1 ? parts[0].replace(/_/g, ' ') : 'Other';
            } catch (e) {
                return 'Other';
            }
        }
    }
    
    if (typeof getCurrentTimezoneOffset !== 'function') {
        window.getCurrentTimezoneOffset = function(ianaId) {
            try {
                const now = new Date();
                const formatter = new Intl.DateTimeFormat('en', {
                    timeZone: ianaId,
                    timeZoneName: 'longOffset'
                });
                const parts = formatter.formatToParts(now);
                const offsetPart = parts.find(p => p.type === 'timeZoneName');
                if (offsetPart && offsetPart.value) {
                    const match = offsetPart.value.match(/GMT([+-]\d{1,2})(:?(\d{2}))?/);
                    if (match) {
                        const sign = match[1].startsWith('-') ? '-' : '+';
                        const hours = match[1].replace('+', '').replace('-', '');
                        const minutes = match[3] ? match[3] : '00';
                        return `UTC${sign}${hours.padStart(2, '0')}${minutes !== '00' ? ':' + minutes : ''}`;
                    }
                }
            } catch (e) {
                console.warn('Could not get timezone offset for', ianaId, e);
            }
            return 'UTC+00';
        }
    }
    
    if (typeof buildTimezoneList !== 'function') {
        window.buildTimezoneList = function() {
            if (window.TIMEZONE_OPTIONS && window.TIMEZONE_OPTIONS.length) {
                return window.TIMEZONE_OPTIONS.map(tz => ({
                    ...tz,
                    offset: getCurrentTimezoneOffset(tz.id)
                }));
            }
            let ids = [];
            try {
                if (typeof Intl.supportedValuesOf === 'function') {
                    ids = Intl.supportedValuesOf('timeZone');
                }
            } catch (e) {
                console.warn('Intl.supportedValuesOf unavailable', e);
            }
            if (!ids || ids.length === 0) {
                ids = ['UTC', 'America/New_York', 'Europe/London', 'Asia/Tokyo', 'Australia/Sydney'];
            }
            return ids.map(id => ({
                id,
                name: formatTimezoneName(id),
                region: deriveRegion(id),
                offset: getCurrentTimezoneOffset(id)
            }));
        }
    }
    
    if (typeof findTimezonesByOffset !== 'function') {
        window.findTimezonesByOffset = function(offsetMinutes) {
            const timezones = buildTimezoneList();
            if (timezones.length === 0) return [];
            
            const now = new Date();
            const matching = [];
            
            timezones.forEach(tz => {
                try {
                    const formatter = new Intl.DateTimeFormat('en', {
                        timeZone: tz.id,
                        timeZoneName: 'longOffset'
                    });
                    const parts = formatter.formatToParts(now);
                    const offsetPart = parts.find(p => p.type === 'timeZoneName');
                    
                    if (offsetPart && offsetPart.value) {
                        const match = offsetPart.value.match(/GMT([+-])(\d{1,2})(:?(\d{2}))?/);
                        if (match) {
                            const sign = match[1] === '+' ? 1 : -1;
                            const hours = parseInt(match[2]) || 0;
                            const minutes = match[4] ? parseInt(match[4]) : 0;
                            const tzOffsetMinutes = sign * (hours * 60 + minutes);
                            
                            if (Math.abs(tzOffsetMinutes - offsetMinutes) < 30) {
                                matching.push(tz);
                            }
                        }
                    }
                } catch (e) {}
            });
            
            matching.sort((a, b) => {
                const nameA = (a.name || a.id).toLowerCase();
                const nameB = (b.name || b.id).toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            return matching;
        }
    }
</script>
