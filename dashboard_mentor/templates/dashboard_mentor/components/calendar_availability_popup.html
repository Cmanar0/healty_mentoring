{% load static %}

<!-- ===================== AVAILABILITY CALENDAR MODAL ===================== -->
<div id="availabilityCalendarOverlay" class="availability-calendar-overlay" aria-hidden="true">
  <div class="availability-calendar-backdrop" data-close-availability-calendar></div>

  <div class="availability-calendar-modal">
    <header class="availability-calendar-header">
      <div class="availability-calendar-title-group">
        <h2>Manage Sessions & Availability</h2>
        <p class="availability-calendar-subtitle">Weekly view in your timezone</p>
      </div>

      <div class="availability-calendar-nav">
        <button class="calendar-nav-btn" data-calendar-nav="prev" aria-label="Previous">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <div class="calendar-date-display" id="calendarDateDisplay">Loading...</div>
        <button class="calendar-nav-btn" data-calendar-nav="next" aria-label="Next">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>

      <div class="availability-calendar-header-actions">
        <button class="calendar-nav-btn" data-calendar-nav="today" aria-label="Today">Today</button>
        <div class="availability-calendar-view-toggle">
          <button class="view-toggle-btn" data-calendar-view="timeGridDay">Day</button>
          <button class="view-toggle-btn is-active" data-calendar-view="timeGridWeek">Week</button>
          <button class="view-toggle-btn" data-calendar-view="dayGridMonth">Month</button>
        </div>

        <button class="availability-calendar-close-btn" data-close-availability-calendar>âœ•</button>
      </div>
    </header>

    <section class="availability-calendar-body">
      <div id="mentorAvailabilityCalendar" class="availability-calendar-root"></div>
    </section>
  </div>
</div>


<!-- ===================== FullCalendar v6 CSS ===================== -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.css">

<!-- ===================== FullCalendar v6 JS (core + plugins) ===================== -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/locales-all.global.min.js"></script>

<!-- ===================== CSS ===================== -->
<style>
/* Overlay */
.availability-calendar-overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(15, 23, 42, 0.6);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  z-index: 2000;
  opacity: 0;
  transition: opacity 0.3s ease;
}
.availability-calendar-overlay.is-visible { 
  display: flex !important; 
  opacity: 1;
}

/* Modal */
.availability-calendar-modal {
  background: #ffffff;
  width: 95%;
  max-width: 1400px;
  height: 90vh;
  border-radius: 24px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 
    0 25px 50px -12px rgba(0, 0, 0, 0.25),
    0 0 0 1px rgba(0, 0, 0, 0.05); /* Subtle border ring */
  transform: scale(0.95);
  opacity: 0;
  transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s ease;
}

.availability-calendar-overlay.is-visible .availability-calendar-modal {
  transform: scale(1);
  opacity: 1;
}

/* Header */
.availability-calendar-header {
  padding: 20px 32px;
  background: #ffffff;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 24px;
}

.availability-calendar-title-group {
  flex: 1;
  min-width: 0;
}

.availability-calendar-title-group h2 {
  margin: 0;
  font-size: 1.5rem;
  font-weight: 700;
  color: #0f172a;
  letter-spacing: -0.025em;
  line-height: 1.2;
}

.availability-calendar-title-group .availability-calendar-subtitle {
  margin: 4px 0 0 0;
  font-size: 0.875rem;
  color: #64748b;
  font-weight: 400;
}

/* Navigation Group */
.availability-calendar-nav {
  display: flex;
  min-width: 280px;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  background: #f8fafc;
  padding: 4px;
  border-radius: 12px;
  border: 1px solid #e2e8f0;
}

.calendar-nav-btn {
  border: none;
  background: transparent;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  cursor: pointer;
  color: #64748b;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.calendar-nav-btn:hover {
  background: #ffffff;
  color: #0f172a;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.calendar-date-display {
  padding: 0 16px;
  font-size: 0.925rem;
  font-weight: 600;
  color: #334155;
  white-space: nowrap;
  min-width: 140px;
  text-align: center;
  font-variant-numeric: tabular-nums;
}

/* Header Actions */
.availability-calendar-header-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}

/* Today Button */
.calendar-nav-btn[data-calendar-nav="today"] {
  width: auto;
  padding: 0 16px;
  background: #f1f5f9;
  color: #475569;
  font-weight: 600;
  font-size: 0.875rem;
  height: 36px;
  border-radius: 10px;
}

.calendar-nav-btn[data-calendar-nav="today"]:hover {
  background: #e2e8f0;
  color: #1e293b;
}

/* View Toggle (Segmented Control) */
.availability-calendar-view-toggle {
  display: inline-flex;
  align-items: center;
  background: #f1f5f9;
  border-radius: 10px;
  padding: 4px;
  gap: 0;
  border: 1px solid #e2e8f0;
}

.view-toggle-btn {
  padding: 6px 16px;
  border: none;
  cursor: pointer;
  border-radius: 8px;
  background: transparent;
  color: #64748b;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.2s ease;
  position: relative;
}

.view-toggle-btn:hover:not(.is-active) {
  color: #334155;
}

.view-toggle-btn.is-active {
  background: #ffffff;
  color: #0f172a;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  font-weight: 600;
}

/* Close Button */
.availability-calendar-close-btn {
  border: none;
  background: transparent;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  color: #94a3b8;
  font-size: 1.25rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  margin-left: 8px;
}

.availability-calendar-close-btn:hover {
  background: #fee2e2;
  color: #ef4444;
  transform: rotate(90deg);
}

/* Body */
.availability-calendar-body {
  flex: 1;
  min-height: 0;
  display: flex;
  padding: 0; /* Remove padding for flush look */
  background: #f8fafc; /* Slight contrast for calendar area */
  position: relative;
}

.availability-calendar-root {
  flex: 1;
  min-height: 420px;
  border: none;
  background: #ffffff;
}

/* --- FullCalendar Overrides --- */

/* General Text */
.availability-calendar-root {
  font-family: inherit;
  --fc-border-color: #cbd5e1; /* Stronger, balanced border color */
  --fc-page-bg-color: #ffffff;
  --fc-neutral-bg-color: #f8fafc;
  --fc-today-bg-color: #f0fdf4;
  --fc-now-indicator-color: #ef4444;
}

/* Headers */
.fc-theme-standard th {
  border: 1px solid var(--fc-border-color); /* Restore native borders */
  background: #f8fafc;
}

.fc-col-header-cell-cushion {
  color: #64748b;
  font-weight: 600;
  font-size: 0.875rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 8px 0;
}

/* Time Labels */
.fc-timegrid-axis-cushion,
.fc-timegrid-slot-label-cushion {
  color: #64748b; /* Slightly darker for readability */
  font-size: 0.75rem;
  font-weight: 500;
}

/* Slots */
.availability-calendar-root .fc-timegrid-slot {
  height: 20px; 
}

/* Ensure Month View borders are visible and match */
.fc-theme-standard td, 
.fc-theme-standard .fc-scrollgrid {
  border-color: var(--fc-border-color);
}

/* Hour slots styling (targeted by JS adding .fc-hour-slot) */
.availability-calendar-root .fc-hour-slot {
  border-top-color: var(--fc-border-color) !important;
}

/* Events */
.fc-event {
  border: none;
  border-radius: 4px;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  font-size: 0.8rem;
  font-weight: 500;
  padding: 2px;
}

.fc-v-event {
  background-color: #d1fae5;
  border-left: 3px solid #10b981;
  color: #065f46;
}

.fc-event-main {
  color: inherit;
  padding: 2px 4px;
}

/* Now Indicator */
.fc-timegrid-now-indicator-line {
  border-color: #ef4444;
  border-width: 2px;
}
.fc-timegrid-now-indicator-arrow {
  border-color: #ef4444;
  border-width: 6px;
}

/* Scrollbar */
.fc-scroller::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
.fc-scroller::-webkit-scrollbar-track {
  background: transparent;
}
.fc-scroller::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 4px;
}
.fc-scroller::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

.availability-calendar-overlay.is-visible { display: flex; }

/* Modal */
.availability-calendar-modal {
  background: #fff;
  width: 100%;
  max-width: 1300px;
  height: 92vh;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Header */
.availability-calendar-header {
  padding: 12px 18px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 16px;
}

.availability-calendar-title-group {
  flex: 1;
  min-width: 0;
}

.availability-calendar-title-group h2 {
  margin: 0;
  font-size: 1.125rem;
  font-weight: 600;
  color: #1e293b;
  line-height: 1.3;
}

.availability-calendar-title-group .availability-calendar-subtitle {
  margin: 2px 0 0 0;
  font-size: 0.75rem;
  color: #64748b;
  line-height: 1.2;
}

.availability-calendar-nav {
  display: flex;
  align-items: center;
  gap: 4px;
}

.calendar-nav-btn {
  border: none;
  background: #f1f5f9;
  padding: 6px 10px;
  border-radius: 6px;
  cursor: pointer;
  color: #64748b;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 32px;
  height: 32px;
}

.calendar-nav-btn:hover {
  background: #e2e8f0;
  color: #1e293b;
}

.calendar-nav-btn svg {
  display: block;
}

.calendar-date-display {
  padding: 6px 16px;
  font-size: 0.875rem;
  font-weight: 600;
  color: #1e293b;
  white-space: nowrap;
  min-width: 120px;
  text-align: center;
}

.availability-calendar-header-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

.availability-calendar-body {
  flex: 1;
  min-height: 0;
  display: flex;
  padding: 10px;
}

.availability-calendar-root {
  flex: 1;
  min-height: 420px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid #e5e7eb;
}

/* View Toggle Buttons - grouped in a row */
.availability-calendar-view-toggle {
  display: inline-flex;
  align-items: center;
  background: #f1f5f9;
  border-radius: 8px;
  padding: 2px;
  gap: 0;
  border: 1px solid #e2e8f0;
}

.view-toggle-btn {
  padding: 6px 12px;
  border: none;
  cursor: pointer;
  border-radius: 6px;
  background: transparent;
  color: #64748b;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.15s ease;
}

.view-toggle-btn:hover:not(.is-active) {
  background: #e2e8f0;
  color: #1e293b;
}

.view-toggle-btn.is-active {
  background: #10b981;
  color: #fff;
}

/* Close Button - separate */
.availability-calendar-close-btn {
  border: none;
  background: #f1f5f9;
  padding: 8px 12px;
  border-radius: 8px;
  cursor: pointer;
  color: #64748b;
  font-size: 1.125rem;
  line-height: 1;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
}

.availability-calendar-close-btn:hover {
  background: #e2e8f0;
  color: #ef4444;
}

/* Make time slot rows thinner - target all possible elements */
.availability-calendar-root .fc-timegrid-slot,
.availability-calendar-root .fc-timegrid-slot table,
.availability-calendar-root .fc-timegrid-slot tr,
.availability-calendar-root .fc-timegrid-slot td,
.availability-calendar-root .fc-timegrid-slot-lane,
.availability-calendar-root .fc-timegrid-slot-lane table,
.availability-calendar-root .fc-timegrid-slot-lane tr,
.availability-calendar-root .fc-timegrid-slot-lane td {
  height: 3px !important;
  min-height: 3px !important;
  max-height: 3px !important;
  line-height: 3px !important;
}

/* Target the table rows directly */
.availability-calendar-root table.fc-timegrid-slots tr {
  height: 3px !important;
  min-height: 3px !important;
  max-height: 3px !important;
}

.availability-calendar-root table.fc-timegrid-slots tr td {
  height: 3px !important;
  min-height: 3px !important;
  max-height: 3px !important;
  padding: 0 !important;
  line-height: 3px !important;
}

/* Hide horizontal borders for 5-min slots, but PRESERVE vertical borders */
.availability-calendar-root .fc-timegrid-slot {
  border-top: none !important;
  border-bottom: none !important;
}

/* Only show borders on hour slots (slot 0 and every 12th slot) */
.availability-calendar-root .fc-hour-slot {
  border-top: 1px solid var(--fc-border-color) !important;
}

/* Ensure Month View borders are strong */
.availability-calendar-root .fc-daygrid-day-frame {
  border: 0px solid var(--fc-border-color);
}

/* Style hour labels */
.availability-calendar-root .fc-timegrid-slot-label {
  font-size: 0.75rem;
  padding: 2px 8px;
}

/* Make slot labels show hour ranges */
.availability-calendar-root .fc-timegrid-slot-label-cushion {
  font-weight: 500;
}
</style>

<!-- ===================== JS ===================== -->
<script>
(function() {
  const overlay = document.getElementById("availabilityCalendarOverlay");
  const calendarRoot = document.getElementById("mentorAvailabilityCalendar");
  const openTriggers = document.querySelectorAll("[data-open-availability-calendar]");
  const closeTriggers = document.querySelectorAll("[data-close-availability-calendar]");
  const viewBtnEls = document.querySelectorAll("[data-calendar-view]");
  const subtitleEl = document.querySelector(".availability-calendar-subtitle");
  const dateDisplayEl = document.getElementById("calendarDateDisplay");

  // Format date display based on current view type
  function updateDateDisplay() {
    if (!calendar || !dateDisplayEl) return;
    
    const view = calendar.view;
    const start = view.activeStart;
    const end = view.activeEnd;
    
    let displayText = '';
    
    if (view.type === 'timeGridDay') {
      // Day view: show specific date (e.g., "January 15, 2024")
      const dateFormatter = new Intl.DateTimeFormat('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      displayText = dateFormatter.format(start);
    } else if (view.type === 'timeGridWeek') {
      // Week view: show date range (e.g., "Jan 15 - Jan 21, 2024")
      const startFormatter = new Intl.DateTimeFormat('en-US', {
        month: 'short',
        day: 'numeric'
      });
      const endFormatter = new Intl.DateTimeFormat('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
      const startStr = startFormatter.format(start);
      const endStr = endFormatter.format(new Date(end.getTime() - 1)); // Subtract 1ms to get last day
      displayText = startStr + ' - ' + endStr;
    } else if (view.type === 'dayGridMonth') {
      // Month view: show month name and year (e.g., "January 2024")
      // Calculate the month from the middle of the view range to avoid boundary issues
      // This handles cases where activeStart might be at the end of previous month
      const midDate = new Date((start.getTime() + end.getTime()) / 2);
      // Get the first day of the month that midDate falls into
      const monthStart = new Date(midDate.getFullYear(), midDate.getMonth(), 1);
      const monthFormatter = new Intl.DateTimeFormat('en-US', {
        year: 'numeric',
        month: 'long'
      });
      displayText = monthFormatter.format(monthStart);
    }
    
    dateDisplayEl.textContent = displayText;
  }

  // Get current UTC offset for a timezone (handles DST automatically)
  // Uses JavaScript's native timezone support - IANA timezones already handle DST
  function getCurrentTimezoneOffset(ianaId) {
    try {
      const now = new Date();
      
      // Use Intl.DateTimeFormat to get the timezone offset
      // This automatically handles DST based on the current date
      const formatter = new Intl.DateTimeFormat('en', {
        timeZone: ianaId,
        timeZoneName: 'longOffset'
      });
      
      const parts = formatter.formatToParts(now);
      const offsetPart = parts.find(p => p.type === 'timeZoneName');
      
      if (offsetPart && offsetPart.value) {
        // offsetPart.value will be like "GMT+1", "GMT+02:00", "GMT+1:00", etc.
        // Extract the offset part
        const offsetMatch = offsetPart.value.match(/GMT([+-])(\d{1,2})(:?(\d{2}))?/);
        if (offsetMatch) {
          const sign = offsetMatch[1];
          const hours = parseInt(offsetMatch[2]) || 0;
          const minutes = offsetMatch[4] ? parseInt(offsetMatch[4]) : 0;
          
          if (minutes === 0) {
            return 'UTC' + sign + String(hours).padStart(2, '0');
          } else {
            return 'UTC' + sign + String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0');
          }
        }
      }
      
      // Fallback: Calculate offset by comparing what time it is in UTC vs the timezone
      // Format the same moment in both timezones and compare
      const utcTimeStr = now.toLocaleString('sv-SE', { timeZone: 'UTC' }); // ISO-like format
      const tzTimeStr = now.toLocaleString('sv-SE', { timeZone: ianaId });
      
      // Parse both (format: "YYYY-MM-DD HH:mm:ss")
      const utcDate = new Date(utcTimeStr.replace(' ', 'T') + 'Z');
      const tzDate = new Date(tzTimeStr.replace(' ', 'T') + 'Z');
      
      // The difference tells us the offset
      const diffMs = tzDate.getTime() - utcDate.getTime();
      const diffHours = diffMs / (1000 * 60 * 60);
      
      const sign = diffHours >= 0 ? '+' : '-';
      const absHours = Math.abs(diffHours);
      const hours = Math.floor(absHours);
      const minutes = Math.round((absHours - hours) * 60);
      
      if (minutes === 0) {
        return 'UTC' + sign + String(hours).padStart(2, '0');
      } else {
        return 'UTC' + sign + String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0');
      }
    } catch (e) {
      console.warn('Could not get timezone offset for', ianaId, ':', e);
      return 'UTC+0';
    }
  }

  // Get timezone display name from IANA ID using COMMON_TIMEZONES, with dynamic offset
  function getTimezoneDisplayName(ianaId) {
    try {
      const timezonesDataEl = document.getElementById('timezonesData');
      if (timezonesDataEl && timezonesDataEl.textContent) {
        const timezones = JSON.parse(timezonesDataEl.textContent);
        const tz = timezones.find(t => t.id === ianaId);
        if (tz) {
          // Get current offset dynamically (handles DST)
          const currentOffset = getCurrentTimezoneOffset(ianaId);
          // Return format: "Prague (UTC+1)" or "Prague (UTC+2)" depending on season
          return tz.name + ' (' + currentOffset + ')';
        }
      }
    } catch (e) {
      console.warn('Could not get timezone display name:', e);
    }
    // Fallback: return IANA ID with dynamic offset
    const currentOffset = getCurrentTimezoneOffset(ianaId);
    return ianaId + ' (' + currentOffset + ')';
  }

  // Helper: Find IANA ID from display name or IANA ID in COMMON_TIMEZONES
  function findIanaIdFromTimezone(timezoneValue) {
    if (!timezoneValue || !timezoneValue.trim()) return null;
    
    const trimmed = timezoneValue.trim();
    
    try {
      const timezonesDataEl = document.getElementById('timezonesData');
      if (timezonesDataEl && timezonesDataEl.textContent) {
        const timezones = JSON.parse(timezonesDataEl.textContent);
        
        // First, try exact IANA ID match
        const exactMatch = timezones.find(t => t.id === trimmed);
        if (exactMatch) {
          return exactMatch.id;
        }
        
        // Then, try matching by display name (e.g., "Prague (UTC+1)")
        const nameMatch = timezones.find(t => {
          // Match exact name
          if (t.name === trimmed) return true;
          // Match name with offset (e.g., "Prague (UTC+1)")
          const nameWithOffset = t.name + ' (' + t.offset + ')';
          if (nameWithOffset === trimmed) return true;
          // Match partial name (e.g., "Prague" matches "Prague (UTC+1)")
          if (trimmed.startsWith(t.name + ' (')) return true;
          return false;
        });
        
        if (nameMatch) {
          return nameMatch.id;
        }
      }
    } catch (e) {
      console.warn('Error looking up timezone in COMMON_TIMEZONES:', e);
    }
    
    // If it looks like an IANA ID (contains '/'), return as-is
    if (trimmed.includes('/')) {
      return trimmed;
    }
    
    return null;
  }

  // Resolve mentor timezone from global userProfileData JSON (provided by dashboard_mentor/base.html)
  function resolveMentorTimezone() {
    let tz = null;
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const rawText = dataEl.textContent.trim();
        console.log('[Calendar] userProfileData raw text:', rawText);
        
        if (rawText) {
          const data = JSON.parse(rawText);
          console.log('[Calendar] userProfileData parsed:', data);
          
          let rawTimezone = null;
          
          // Priority 1: selected_timezone
          if (data.selected_timezone && data.selected_timezone.trim() !== '') {
            rawTimezone = data.selected_timezone.trim();
            console.log('[Calendar] Using selected_timezone:', rawTimezone);
          } 
          // Priority 2: detected_timezone
          else if (data.detected_timezone && data.detected_timezone.trim() !== '') {
            rawTimezone = data.detected_timezone.trim();
            console.log('[Calendar] Using detected_timezone:', rawTimezone);
          } else {
            console.warn('[Calendar] Both selected_timezone and detected_timezone are empty');
            console.warn('[Calendar] selected_timezone:', data.selected_timezone);
            console.warn('[Calendar] detected_timezone:', data.detected_timezone);
            // Fallback: try browser-detected timezone
            try {
              const browserTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
              if (browserTz) {
                rawTimezone = browserTz;
                console.log('[Calendar] Fallback: Using browser-detected timezone:', browserTz);
              }
            } catch (e) {
              console.warn('[Calendar] Could not detect browser timezone:', e);
            }
          }
          
          // Convert to IANA ID if we have a timezone value
          if (rawTimezone) {
            const ianaId = findIanaIdFromTimezone(rawTimezone);
            if (ianaId) {
              tz = ianaId;
              console.log('[Calendar] Resolved timezone:', rawTimezone, '->', ianaId);
            } else {
              // If lookup failed but it looks like an IANA ID, use it
              if (rawTimezone.includes('/')) {
                tz = rawTimezone;
                console.log('[Calendar] Using raw timezone as IANA ID:', tz);
              } else {
                console.warn('[Calendar] Could not resolve timezone:', rawTimezone);
              }
            }
          }
        } else {
          console.warn('[Calendar] userProfileData element has empty textContent');
        }
      } else {
        console.error('[Calendar] userProfileData element not found!');
      }
    } catch (e) {
      console.error('[Calendar] Could not resolve mentor timezone:', e);
    }
    
    // Final fallback: browser timezone or UTC
    if (!tz) {
      try {
        tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
        console.log('[Calendar] Final fallback: Using browser timezone:', tz);
      } catch (e) {
        tz = 'UTC';
        console.warn('[Calendar] Final fallback: Using UTC');
      }
    }
    
    console.log('[Calendar] Final resolved timezone:', tz);
    return tz || 'UTC';
  }

  let calendar = null;
  let mentorTimezone = resolveMentorTimezone();
  let mentorTimezoneDisplay = getTimezoneDisplayName(mentorTimezone);
  
  // Function to update timezone (call this when popup opens to get latest values)
  function updateTimezoneFromProfile() {
    mentorTimezone = resolveMentorTimezone();
    mentorTimezoneDisplay = getTimezoneDisplayName(mentorTimezone);
    
    // Update subtitle
    if (subtitleEl) {
      const viewType = calendar && calendar.view ? 
        (calendar.view.type === 'dayGridMonth' ? 'Monthly' :
         calendar.view.type === 'timeGridDay' ? 'Day' : 'Weekly') : 'Weekly';
      subtitleEl.textContent = viewType + ' view in your timezone (' + mentorTimezoneDisplay + ')';
    }
    
    // Update calendar timezone if it exists
    if (calendar) {
      calendar.setOption('timeZone', mentorTimezone);
      calendar.render();
    }
  }
  
  // Update subtitle immediately with resolved timezone display name (before calendar init)
  if (subtitleEl) {
    subtitleEl.textContent = 'Weekly view in your timezone (' + mentorTimezoneDisplay + ')';
  }

  const exampleEvents = [
    {
      title: "Shooting Stars",
      start: "2025-01-12T09:00:00",
      end: "2025-01-12T11:00:00",
      backgroundColor: "#10b981",
    }
  ];

  function scrollToAppropriateTime() {
    if (!calendar) return;
    
    const currentView = calendar.view;
    // Apply scrolling to both day and week views
    if (currentView.type !== 'timeGridDay' && currentView.type !== 'timeGridWeek') return;
    
    // Always scroll to 9am
    calendar.scrollToTime({ hours: 9, minutes: 0 });
    
    // Then adjust to center it in the viewport
    setTimeout(() => {
      const scrollContainer = calendarRoot.querySelector('.fc-scroller');
      if (!scrollContainer) return;
      
      // Find the time slot element for 9am
      const timeSlots = scrollContainer.querySelectorAll('.fc-timegrid-slot');
      if (timeSlots.length === 0) return;
      
      // 9am = 9 * 12 = slot 108 (each slot is 5 minutes, so 12 slots per hour)
      const slotIndex = 9 * 12;
      const targetSlot = timeSlots[slotIndex];
      
      if (targetSlot) {
        const containerRect = scrollContainer.getBoundingClientRect();
        const slotRect = targetSlot.getBoundingClientRect();
        const scrollTop = scrollContainer.scrollTop;
        
        // Calculate position relative to scroll container
        const slotTop = slotRect.top - containerRect.top + scrollTop;
        const viewportHeight = containerRect.height;
        
        // Center the slot in the viewport
        const targetScrollTop = slotTop - (viewportHeight / 2);
        
        scrollContainer.scrollTo({
          top: Math.max(0, targetScrollTop),
          behavior: 'smooth'
        });
      }
    }, 100);
  }

  function initCalendar() {
    // Debug: log the timezone being used
    console.log('Calendar timezone:', mentorTimezone);
    console.log('Current UTC time:', new Date().toISOString());
    
    // For nowIndicator to work correctly with timeZone, we need to provide
    // a function that returns the current time, and FullCalendar will interpret it
    // in the context of the specified timeZone
    // Using a function ensures it updates dynamically
    calendar = new FullCalendar.Calendar(calendarRoot, {
      timeZone: mentorTimezone,
      initialView: "timeGridWeek",
      height: "100%",
      nowIndicator: true,
      // Don't set 'now' explicitly - let FullCalendar use current time
      // It should automatically respect the timeZone setting
      slotMinTime: "00:00:00", // Start at midnight
      slotMaxTime: "24:00:00", // End at midnight (24 hours)
      slotDuration: "00:05:00", // 5-minute intervals for thin rows
      slotLabelInterval: "01:00:00", // Show labels every hour
      slotLabelContent: function(arg) {
        // Return hour number (0-23) - this matches the timezone correctly
        const hour = arg.date.getHours();
        const minutes = arg.date.getMinutes();
        // Only show if exactly on the hour
        if (minutes === 0 && hour >= 0 && hour <= 23) {
          return hour.toString();
        }
        return '';
      },
      headerToolbar: false,
      selectable: true,
      firstDay: 1, // Start week with Monday
      allDaySlot: false, // Remove all-day row from week and day views
      events: exampleEvents,
      // Remove all-day slot from specific views
      views: {
        timeGridWeek: {
          allDaySlot: false,
          slotMinTime: "00:00:00",
          slotMaxTime: "24:00:00",
          slotDuration: "00:05:00",
          slotLabelInterval: "01:00:00",
          slotLabelContent: function(arg) {
            // Return hour number (0-23) - this matches the timezone correctly
            const hour = arg.date.getHours();
            const minutes = arg.date.getMinutes();
            // Only show if exactly on the hour
            if (minutes === 0 && hour >= 0 && hour <= 23) {
              return hour.toString();
            }
            return '';
          },
          slotLaneClassNames: function(arg) {
            const minutes = arg.date.getMinutes();
            if (minutes === 0) {
              return ['fc-hour-slot'];
            }
            return [];
          }
        },
        timeGridDay: {
          allDaySlot: false,
          slotMinTime: "00:00:00",
          slotMaxTime: "24:00:00",
          slotDuration: "00:05:00",
          slotLabelInterval: "01:00:00",
          slotLabelContent: function(arg) {
            // Return hour number (0-23) - this matches the timezone correctly
            const hour = arg.date.getHours();
            const minutes = arg.date.getMinutes();
            // Only show if exactly on the hour
            if (minutes === 0 && hour >= 0 && hour <= 23) {
              return hour.toString();
            }
            return '';
          },
          slotLaneClassNames: function(arg) {
            const minutes = arg.date.getMinutes();
            if (minutes === 0) {
              return ['fc-hour-slot'];
            }
            return [];
          },
          scrollTime: "09:00:00" // Default scroll position
        }
      }
    });

    calendar.render();

    // Update subtitle with resolved timezone display name
    if (subtitleEl) {
      const timezoneDisplay = getTimezoneDisplayName(mentorTimezone);
      subtitleEl.textContent = 'Weekly view in your timezone (' + timezoneDisplay + ')';
    }

    // Mark hour slots for CSS targeting - call multiple times to ensure they persist
    setTimeout(() => {
      markHourSlots();
      // Call again after a delay to ensure classes persist after any re-renders
      setTimeout(() => markHourSlots(), 200);
      setTimeout(() => markHourSlots(), 500);
    }, 100);

    // Listen to calendar's render events to re-mark slots after re-renders
    if (calendar && calendar.on) {
      calendar.on('viewDidMount', function() {
        setTimeout(() => markHourSlots(), 100);
        updateDateDisplay(); // Update date display when view mounts
      });
      
      // Also listen to datesSet event which fires when calendar navigates
      calendar.on('datesSet', function() {
        setTimeout(() => markHourSlots(), 100);
        updateDateDisplay(); // Update date display when dates change
      });
    }
    
    // Initial date display update
    setTimeout(() => updateDateDisplay(), 100);
    
    // Use MutationObserver to watch for DOM changes and re-apply borders
    const observer = new MutationObserver(function(mutations) {
      // Re-mark hour slots if the slots table changes
      const slotsTable = calendarRoot.querySelector('table.fc-timegrid-slots');
      if (slotsTable) {
        setTimeout(() => markHourSlots(), 50);
      }
    });
    
    // Observe the calendar root for changes
    if (calendarRoot) {
      observer.observe(calendarRoot, {
        childList: true,
        subtree: true
      });
    }

    setTimeout(() => {
      calendar.updateSize();
      // If initial view is day or week view, scroll appropriately
      if (calendar.view.type === 'timeGridDay' || calendar.view.type === 'timeGridWeek') {
        setTimeout(() => {
          scrollToAppropriateTime();
          markHourSlots(); // Re-mark after scrolling
        }, 100);
      }
    }, 50);
  }

  function markHourSlots() {
    if (!calendarRoot) return;
    
    // Mark slot 0 (midnight) and then every 12th slot (each hour)
    const slots = calendarRoot.querySelectorAll('table.fc-timegrid-slots tbody tr');
    if (slots.length === 0) return;
    
    slots.forEach((slot, index) => {
      // Slot 0 (index 0) and every 12th slot after that (index 12, 24, 36, etc.)
      const isHourSlot = (index === 0 || index % 12 === 0);
      
      if (isHourSlot) {
        slot.classList.add('fc-hour-slot');
        // Also mark children
        slot.querySelectorAll('td, .fc-timegrid-slot-lane').forEach(el => {
          el.classList.add('fc-hour-slot');
        });
      } else {
        slot.classList.remove('fc-hour-slot');
        slot.querySelectorAll('td, .fc-timegrid-slot-lane').forEach(el => {
          el.classList.remove('fc-hour-slot');
        });
      }
    });
  }

  function openOverlay() {
    overlay.classList.add("is-visible");
    
    // Re-read timezone from profile when opening (in case it was updated)
    updateTimezoneFromProfile();

    if (!calendar) {
      initCalendar();
    } else {
      // Update calendar timezone in case it changed
      calendar.setOption('timeZone', mentorTimezone);
      calendar.render();
      setTimeout(() => {
        calendar.updateSize();
        markHourSlots();
        updateDateDisplay(); // Update date display when opening overlay
        // If current view is day or week view, scroll appropriately
        if (calendar.view.type === 'timeGridDay' || calendar.view.type === 'timeGridWeek') {
          setTimeout(() => scrollToAppropriateTime(), 150);
        }
      }, 50);
    }
  }

  function closeOverlay() {
    overlay.classList.remove("is-visible");
  }

  openTriggers.forEach(btn => btn.addEventListener("click", openOverlay));
  closeTriggers.forEach(btn => btn.addEventListener("click", closeOverlay));

  // Calendar navigation (prev/next/today)
  const navBtns = overlay.querySelectorAll("[data-calendar-nav]");
  navBtns.forEach(btn => {
    btn.addEventListener("click", function() {
      if (!calendar) return;
      
      const action = this.dataset.calendarNav;
      if (action === "prev") {
        calendar.prev();
      } else if (action === "next") {
        calendar.next();
      } else if (action === "today") {
        calendar.today();
      }
      
      setTimeout(() => {
        calendar.updateSize();
        updateDateDisplay(); // Update date display after navigation
      }, 50);
    });
  });

  // Close when clicking outside the modal (on backdrop/overlay)
  overlay.addEventListener("click", function(e) {
    // Only close if clicking directly on the overlay or backdrop, not on the modal content
    if (e.target === overlay || e.target.classList.contains("availability-calendar-backdrop")) {
      closeOverlay();
    }
  });

  // Prevent clicks inside the modal from closing it
  const modal = overlay.querySelector(".availability-calendar-modal");
  if (modal) {
    modal.addEventListener("click", function(e) {
      e.stopPropagation();
    });
  }

  document.addEventListener("keydown", e => {
    if (e.key === "Escape") closeOverlay();
  });

  viewBtnEls.forEach(btn => {
    btn.addEventListener("click", function() {
      const targetView = this.dataset.calendarView;

      viewBtnEls.forEach(b => b.classList.toggle("is-active", b === this));

      if (calendar) {
        calendar.changeView(targetView);
        const timezoneDisplay = getTimezoneDisplayName(mentorTimezone);
        subtitleEl.textContent =
          (targetView === "dayGridMonth" ? "Monthly" :
           targetView === "timeGridDay" ? "Day" : "Weekly") +
          " view in your timezone (" + timezoneDisplay + ")";

        setTimeout(() => {
          calendar.updateSize();
          calendar.render();
          markHourSlots();
          updateDateDisplay(); // Update date display when view changes
          
          // If switching to day or week view, scroll to appropriate time
          if (targetView === "timeGridDay" || targetView === "timeGridWeek") {
            setTimeout(() => scrollToAppropriateTime(), 150);
          }
        }, 50);
      }
    });
  });

})();
</script>

