{% load static %}

{# Entry-point popup template. Include this from a page via: {% include "dashboard_mentor/calendar_mentor/calendar.html" %} #}

<div id="mentorCalendarOverlay" class="mentor-calendar-overlay" aria-hidden="true">
  <div class="mentor-calendar-backdrop" data-mentor-calendar-close></div>

  <div class="mentor-calendar-modal" role="dialog" aria-modal="true" aria-label="Calendar">
    <header class="mentor-calendar-header">
      <div class="mentor-calendar-date-group">
        <h2 id="mentorCalendarDateDisplay">Loading...</h2>
      </div>

      <div class="mentor-calendar-controls">
        <div class="mentor-calendar-nav">
          <button class="calendar-nav-btn" data-calendar-nav="prev" aria-label="Previous">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <button class="calendar-nav-btn" data-calendar-nav="today" aria-label="Today">Today</button>
          <button class="calendar-nav-btn" data-calendar-nav="next" aria-label="Next">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>

        <div class="mentor-calendar-view-toggle">
          <button class="view-toggle-btn" data-calendar-view="timeGridDay">Day</button>
          <button class="view-toggle-btn is-active" data-calendar-view="timeGridWeek">Week</button>
          <button class="view-toggle-btn" data-calendar-view="dayGridMonth">Month</button>
        </div>

        <div class="mentor-calendar-mode-toggle" aria-label="Mode toggle">
          <button type="button" id="mentorCalendarModeSessions" class="mode-toggle-btn is-active" data-mode="sessions">
            Sessions
          </button>
          <button type="button" id="mentorCalendarModeAvailability" class="mode-toggle-btn" data-mode="availability">
            Availability
          </button>
        </div>

        <button type="button" id="mentorCalendarSaveBtn" class="mentor-calendar-save-btn" aria-label="Save availability" aria-busy="false">
          <span class="btn-label">Save</span>
          <span class="btn-spinner" aria-hidden="true"></span>
        </button>

        <button type="button" class="mentor-calendar-close" data-mentor-calendar-close aria-label="Close">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </header>

    <div class="mentor-calendar-body">
      <div id="mentorCalendarRoot" class="mentor-calendar-root"></div>
    </div>
  </div>
</div>

{% include "dashboard_mentor/calendar_mentor/Session_slot.html" %}
{% include "dashboard_mentor/calendar_mentor/Availability_Slot.html" %}
{% include "dashboard_mentor/calendar_mentor/availability_settings.html" %}
{% include "dashboard_mentor/calendar_mentor/popups/availability_switch_mode_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/popups/session_switch_mode_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/popups/session_settings.html" %}
{% include "dashboard_mentor/calendar_mentor/popups/schedule_session_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/popups/unsaved_changes_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/popups/recurring_delete_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/popups/recurring_move_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/popups/collision_resolution_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/popups/session_changes_popup.html" %}

<style>
  /* --- Overlay --- */
  .mentor-calendar-overlay {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(15, 23, 42, 0.6);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    z-index: 9999;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
  }
  .mentor-calendar-overlay.is-visible {
    opacity: 1;
    visibility: visible;
  }
  .mentor-calendar-backdrop {
    position: absolute;
    inset: 0;
  }

  /* --- Modal --- */
  .mentor-calendar-modal {
    background: #ffffff;
    width: 95%;
    max-width: 1400px;
    height: 90vh;
    border-radius: 24px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 
      0 25px 50px -12px rgba(0, 0, 0, 0.25),
      0 0 0 1px rgba(0, 0, 0, 0.05);
    transform: translateY(20px);
    transition: transform 0.3s ease, opacity 0.3s ease;
    opacity: 0;
  }
  .mentor-calendar-overlay.is-visible .mentor-calendar-modal {
    transform: translateY(0);
    opacity: 1;
  }

  /* --- Header --- */
  .mentor-calendar-header {
    padding: 20px 32px;
    background: #ffffff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 24px;
    border-bottom: 1px solid #f1f5f9;
  }

  /* Date Display (Left) */
  .mentor-calendar-date-group h2 {
    margin: 0;
    font-size: 1.5rem;
    font-weight: 700;
    color: #0f172a;
    letter-spacing: -0.025em;
    line-height: 1.2;
    min-width: 200px; /* Prevent jumping */
  }

  /* Controls Group (Right) */
  .mentor-calendar-controls {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  /* Nav Buttons */
  .mentor-calendar-nav {
    display: flex;
    align-items: center;
    gap: 4px;
    background: #f8fafc;
    padding: 4px;
    border-radius: 12px;
    border: 1px solid #e2e8f0;
  }

  .calendar-nav-btn {
    border: none;
    background: transparent;
    width: 32px;
    height: 32px;
    border-radius: 8px;
    cursor: pointer;
    color: #64748b;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    padding: 0;
  }

  .calendar-nav-btn[data-calendar-nav="today"] {
    width: auto;
    padding: 0 12px;
    font-size: 0.875rem;
    font-weight: 600;
    color: #475569;
  }

  .calendar-nav-btn:hover {
    background: #ffffff;
    color: #0f172a;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
  }

  /* View Toggle (Segmented Control) */
  .mentor-calendar-view-toggle {
    min-width: 245px;
    display: flex;
    align-items: center;
    background: #f1f5f9;
    border-radius: 10px;
    padding: 4px;
    gap: 5px;
    border: 1px solid #e2e8f0;
  }

  .view-toggle-btn {
    padding: 6px 16px;
    border: none;
    cursor: pointer;
    border-radius: 8px;
    background: transparent;
    color: #64748b;
    font-size: 0.875rem;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  .view-toggle-btn:hover:not(.is-active) {
    color: #334155;
    background: rgba(0,0,0,0.03);
  }

  .view-toggle-btn.is-active {
    background: #334156;
    color: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    font-weight: 600;
  }

  /* Sessions / Availability toggle */
  .mentor-calendar-mode-toggle {
    display: flex;
    align-items: center;
    background: #f1f5f9;
    border-radius: 10px;
    padding: 4px;
    border: 1px solid #e2e8f0;
    gap: 4px;
  }
  .mode-toggle-btn {
    padding: 6px 14px;
    border: none;
    cursor: pointer;
    border-radius: 8px;
    background: transparent;
    color: #64748b;
    font-size: 0.875rem;
    font-weight: 600;
    transition: all 0.2s ease;
    white-space: nowrap;
  }
  .mode-toggle-btn:hover:not(.is-active) {
    color: #334155;
    background: rgba(0,0,0,0.03);
  }
  .mode-toggle-btn.is-active[data-mode="sessions"] {
    background: #10b981; /* green */
    color: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }
  .mode-toggle-btn.is-active[data-mode="availability"] {
    background: #3b82f6; /* blue */
    color: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  /* Save button */
  .mentor-calendar-save-btn {
    height: 40px;
    padding: 0 14px;
    border-radius: 10px;
    border: 1px solid #e2e8f0;
    background: #0f172a;
    color: #ffffff;
    font-size: 0.875rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 96px; /* prevent width shift when loading spinner shows */
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
  .mentor-calendar-save-btn:hover {
    background: #111827;
  }
  .mentor-calendar-save-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .mentor-calendar-save-btn .btn-spinner {
    display: none;
    width: 16px;
    height: 16px;
    border-radius: 999px;
    border: 2px solid rgba(255, 255, 255, 0.35);
    border-top-color: currentColor;
    animation: mentor-save-spin 0.8s linear infinite;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  .mentor-calendar-save-btn.is-loading {
    cursor: wait;
  }
  .mentor-calendar-save-btn.is-loading .btn-label {
    visibility: hidden;
  }
  .mentor-calendar-save-btn.is-loading .btn-spinner {
    display: inline-block;
  }

  @keyframes mentor-save-spin {
    to { transform: translate(-50%, -50%) rotate(360deg); }
  }

  /* Close Button */
  .mentor-calendar-close {
    border: none;
    background: transparent;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    color: #94a3b8;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    margin-left: 8px;
  }

  .mentor-calendar-close:hover {
    background: #fee2e2;
    color: #ef4444;
    transform: rotate(90deg);
  }

  /* --- Body --- */
  .mentor-calendar-body {
    flex: 1;
    min-height: 0;
    background: #f8fafc;
    position: relative;
    padding: 0;
  }

  .mentor-calendar-root {
    height: 100%;
    background: #ffffff;
  }

  /* --- FullCalendar Overrides (Matching Availability Popup) --- */
  .mentor-calendar-root {
    font-family: inherit;
    --fc-border-color: #cbd5e1;
    --fc-page-bg-color: #ffffff;
    --fc-neutral-bg-color: #f8fafc;
    --fc-today-bg-color: #fefce8;
    --fc-now-indicator-color: #ef4444;
    /* Ensure slots have consistent rounding everywhere (wrapper + inner) */
    --mentor-calendar-slot-radius: 10px;
  }

  /* Headers */
  .mentor-calendar-root .fc-theme-standard th {
    border: 1px solid var(--fc-border-color);
    background: #f8fafc;
    padding: 12px 0;
  }

  .mentor-calendar-root .fc-col-header-cell-cushion {
    color: #64748b;
    font-weight: 600;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  /* Time Labels */
  .mentor-calendar-root .fc-timegrid-axis-cushion,
  .mentor-calendar-root .fc-timegrid-slot-label-cushion {
    color: #64748b;
    font-size: 0.75rem;
    font-weight: 500;
  }

  /* Strictly enforce 1px borders everywhere to match popup */
  .mentor-calendar-root .fc-theme-standard td, 
  .mentor-calendar-root .fc-theme-standard th,
  .mentor-calendar-root .fc-scrollgrid,
  .mentor-calendar-root .fc-timegrid-col,
  .mentor-calendar-root .fc-daygrid-day-frame {
    border: 1px solid var(--fc-border-color) !important;
  }

  /* Prevent double borders in month view */
  .mentor-calendar-root .fc-daygrid-day-frame {
    border: none !important; 
  }
  .mentor-calendar-root .fc-daygrid-day {
    border: 1px solid var(--fc-border-color) !important;
  }

  /* Disable past days visually - more grey */
  /* Use opacity on background elements only, not the entire cell */
  .mentor-calendar-root .fc-day-past-disabled {
    pointer-events: none;
    background-color: #f1f5f9 !important;
    position: relative;
  }
  
  /* Grey out the background of past days using a pseudo-element overlay */
  .mentor-calendar-root .fc-day-past-disabled::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.7);
    z-index: 0;
    pointer-events: none;
  }
  
  /* Past sessions should be fully visible and clickable on top of disabled days */
  /* Events are positioned above the overlay with higher z-index */
  /* Don't override background-color - let FullCalendar's inline styles (which set the green color) apply */
  .mentor-calendar-root .fc-day-past-disabled .fc-event,
  .mentor-calendar-root .fc-day-past-disabled .fc-timegrid-event,
  .mentor-calendar-root .fc-day-past-disabled .fc-daygrid-event {
    pointer-events: auto !important;
    opacity: 1 !important;
    z-index: 10 !important;
    filter: none !important;
    /* Don't set background-color here - let FullCalendar's inline styles apply */
  }
  
  /* Ensure event content elements are also fully visible */
  .mentor-calendar-root .fc-day-past-disabled .fc-event-main,
  .mentor-calendar-root .fc-day-past-disabled .fc-event-title,
  .mentor-calendar-root .fc-day-past-disabled .fc-event-time,
  .mentor-calendar-root .fc-day-past-disabled .fc-event-title-container,
  .mentor-calendar-root .fc-day-past-disabled .fc-event-content,
  .mentor-calendar-root .fc-day-past-disabled .fc-event-segments,
  .mentor-calendar-root .fc-day-past-disabled .fc-event-segment,
  .mentor-calendar-root .fc-day-past-disabled .mentor-calendar-slot {
    pointer-events: auto !important;
    opacity: 1 !important;
    color: inherit !important;
    filter: none !important;
  }
  
  /* Ensure timegrid events (which are absolutely positioned) are above the overlay */
  .mentor-calendar-root .fc-day-past-disabled .fc-timegrid-event {
    z-index: 10 !important;
  }
  
  .mentor-calendar-root .fc-day-past-disabled .fc-daygrid-day-frame,
  .mentor-calendar-root .fc-day-past-disabled .fc-timegrid-col-frame {
    cursor: not-allowed;
    background-color: #f1f5f9 !important;
  }
  
  .mentor-calendar-root .fc-day-past-disabled .fc-daygrid-day-number,
  .mentor-calendar-root .fc-day-past-disabled .fc-col-header-cell-cushion {
    color: #cbd5e1;
  }
  
  .mentor-calendar-root .fc-day-past-disabled .fc-timegrid-slot {
    background-color: #f8fafc !important;
  }

  /* TimeGrid "drop rows" (FullCalendar time slots)
     - slotDuration controls how many rows per hour
     - snapDuration controls drag/drop snapping
  */
  .mentor-calendar-root .fc-timegrid-slot,
  .mentor-calendar-root .fc-timegrid-slot table,
  .mentor-calendar-root .fc-timegrid-slot tr,
  .mentor-calendar-root .fc-timegrid-slot td,
  .mentor-calendar-root .fc-timegrid-slot-lane,
  .mentor-calendar-root .fc-timegrid-slot-lane table,
  .mentor-calendar-root .fc-timegrid-slot-lane tr,
  .mentor-calendar-root .fc-timegrid-slot-lane td {
    height: 9px !important;       /* 5-min row height */
    min-height: 9px !important;
    max-height: 9px !important;
    line-height: 9px !important;
  }

  .mentor-calendar-root table.fc-timegrid-slots tr td {
    padding: 0 !important;
  }

  /* Hide horizontal borders for 5-min rows (we keep strong hour lines instead) */
  .mentor-calendar-root .fc-timegrid-slot {
    border-top: 1px solid #cbd5e12b !important;
    border-bottom: none !important;
  }
  
  /* Class we'll add via JS for strong hour lines */
  .mentor-calendar-root .fc-hour-slot {
    border-top: 1px solid var(--fc-border-color) !important;
  }

  /* --- Dynamic Slot Styling based on Mode --- */

  /* Base Event Styles (handled by FullCalendar inline styles usually, but we set overrides) */
  .mentor-calendar-root .fc-event,
  .mentor-calendar-root .fc-timegrid-event,
  .mentor-calendar-root .fc-daygrid-event {
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    border-width: 2px !important;
    border-style: solid !important;
    border-radius: var(--mentor-calendar-slot-radius) !important;
    overflow: hidden; /* keep slot content fully inside the event */
    /* FullCalendar sets height via inline styles - never override height, min-height, or max-height */
  }

  /* Inner slot content should match the event wrapper radius */
  .mentor-calendar-root .mentor-calendar-slot {
    height: 100% !important;
    border-radius: var(--mentor-calendar-slot-radius);
    box-sizing: border-box;
  }

  /* When a slot dropdown is open, lift the event above neighbors */
  .mentor-calendar-root .fc-event.is-dropdown-open,
  .mentor-calendar-root .fc-timegrid-event.is-dropdown-open,
  .mentor-calendar-root .fc-daygrid-event.is-dropdown-open {
    /* FullCalendar may set z-index inline; force override */
    z-index: 20000 !important;
  }

  /* 
     Mode: SESSIONS (Default) 
     - Session Slots (Green): Normal
     - Availability Slots (Grey): Disabled/Ghost
  */
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability {
    background-color: #f1f5f9 !important; /* Slate-100 */
    border-color: #cbd5e1 !important;     /* Slate-300 */
    opacity: 0.8;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .fc-event-main,
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .fc-event-time,
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .fc-event-title, 
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability [data-slot-time] {
    color: #94a3b8 !important; /* Slate-400 */
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-slot-title {
    color: #94a3b8 !important; /* Slate-400 */
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-slot-delete {
    display: none !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-slot-duration {
    color: #94a3b8 !important; /* Slate-400 */
    opacity: 0.8 !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-recurrence-trigger {
    background: #f1f5f9 !important; /* Slate-100 */
    border-color: #cbd5e1 !important; /* Slate-300 */
    color: #94a3b8 !important; /* Slate-400 */
    pointer-events: none !important; /* Lock dropdown */
    box-shadow: none !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-recurrence-chevron {
    opacity: 0.5 !important;
  }

  /* 
     Mode: AVAILABILITY 
     - Session Slots (Grey): Disabled/Ghost
     - Availability Slots (Blue): Normal
  */
  .mentor-calendar-root.is-mode-availability .event-type-session {
    background-color: #f1f5f9 !important; /* Slate-100 */
    border-color: #cbd5e1 !important;     /* Slate-300 */
    opacity: 0.8;
  }
  .mentor-calendar-root.is-mode-availability .event-type-session .fc-event-main,
  .mentor-calendar-root.is-mode-availability .event-type-session .fc-event-time,
  .mentor-calendar-root.is-mode-availability .event-type-session .fc-event-title,
  .mentor-calendar-root.is-mode-availability .event-type-session [data-slot-time] {
    color: #94a3b8 !important; /* Slate-400 */
  }
  .mentor-calendar-root.is-mode-availability .event-type-session .mentor-calendar-slot-title {
    color: #94a3b8 !important; /* Slate-400 */
  }

  /* --- Collision styling (red) --- */
  .mentor-calendar-root .fc-event.is-collision,
  .mentor-calendar-root .fc-timegrid-event.is-collision,
  .mentor-calendar-root .fc-daygrid-event.is-collision {
    background-color: #ef4444 !important; /* red-500 */
    border-color: #b91c1c !important;     /* red-700 */
    opacity: 1 !important;
  }
  .mentor-calendar-root .fc-event.is-collision .fc-event-main,
  .mentor-calendar-root .fc-event.is-collision .fc-event-time,
  .mentor-calendar-root .fc-event.is-collision .fc-event-title,
  .mentor-calendar-root .fc-event.is-collision [data-slot-time],
  .mentor-calendar-root .fc-event.is-collision .mentor-calendar-slot-title {
    color: #ffffff !important;
  }

  /* --- Expired session styling (grey, reduced opacity) --- */
  /* IMPORTANT: FullCalendar calculates event height based on start/end time and time grid slot height (9px per 5-min slot) */
  /* The height is set via inline styles by FullCalendar - we must NOT override it or change positioning context */
  .mentor-calendar-root .fc-event[data-session-status="expired"],
  .mentor-calendar-root .fc-timegrid-event[data-session-status="expired"],
  .mentor-calendar-root .fc-daygrid-event[data-session-status="expired"] {
    opacity: 0.6 !important;
    /* DO NOT set: position, height, min-height, max-height - FullCalendar controls these via inline styles */
  }
  .mentor-calendar-root .fc-event[data-session-status="expired"]::after,
  .mentor-calendar-root .fc-timegrid-event[data-session-status="expired"]::after,
  .mentor-calendar-root .fc-daygrid-event[data-session-status="expired"]::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
      45deg,
      transparent,
      transparent 4px,
      rgba(0, 0, 0, 0.05) 4px,
      rgba(0, 0, 0, 0.05) 8px
    );
    pointer-events: none;
    border-radius: var(--mentor-calendar-slot-radius);
    z-index: 1; /* Ensure it's above content but doesn't affect layout */
    /* The ::after is absolutely positioned relative to the event's containing block (timegrid column) */
    /* This doesn't interfere with FullCalendar's height calculation */
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  .mentor-calendar-root .fc-event[data-session-status="expired"] .fc-event-main,
  .mentor-calendar-root .fc-event[data-session-status="expired"] .fc-event-time,
  .mentor-calendar-root .fc-event[data-session-status="expired"] .fc-event-title,
  .mentor-calendar-root .fc-event[data-session-status="expired"] [data-slot-time],
  .mentor-calendar-root .fc-event[data-session-status="expired"] .mentor-calendar-slot-title {
    opacity: 0.8;
  }

  /* --- Completed session styling (dark green) --- */
  /* IMPORTANT: FullCalendar calculates event height based on start/end time and time grid slot height (9px per 5-min slot) */
  /* The height is set via inline styles by FullCalendar - we must NOT override it or change positioning context */
  .mentor-calendar-root .fc-event[data-session-status="completed"],
  .mentor-calendar-root .fc-timegrid-event[data-session-status="completed"],
  .mentor-calendar-root .fc-daygrid-event[data-session-status="completed"] {
    opacity: 0.85 !important;
    /* DO NOT set: position, height, min-height, max-height - FullCalendar controls these via inline styles */
  }
  .mentor-calendar-root .fc-event[data-session-status="completed"] .fc-event-main,
  .mentor-calendar-root .fc-event[data-session-status="completed"] .fc-event-time,
  .mentor-calendar-root .fc-event[data-session-status="completed"] .fc-event-title,
  .mentor-calendar-root .fc-event[data-session-status="completed"] [data-slot-time],
  .mentor-calendar-root .fc-event[data-session-status="completed"] .mentor-calendar-slot-title {
    opacity: 0.95;
  }

  /* --- Refunded session styling (purple/indigo) --- */
  /* IMPORTANT: FullCalendar calculates event height based on start/end time and time grid slot height (9px per 5-min slot) */
  /* The height is set via inline styles by FullCalendar - we must NOT override it or change positioning context */
  .mentor-calendar-root .fc-event[data-session-status="refunded"],
  .mentor-calendar-root .fc-timegrid-event[data-session-status="refunded"],
  .mentor-calendar-root .fc-daygrid-event[data-session-status="refunded"] {
    opacity: 0.85 !important;
    /* DO NOT set: position, height, min-height, max-height - FullCalendar controls these via inline styles */
  }
  .mentor-calendar-root .fc-event[data-session-status="refunded"] .fc-event-main,
  .mentor-calendar-root .fc-event[data-session-status="refunded"] .fc-event-time,
  .mentor-calendar-root .fc-event[data-session-status="refunded"] .fc-event-title,
  .mentor-calendar-root .fc-event[data-session-status="refunded"] [data-slot-time],
  .mentor-calendar-root .fc-event[data-session-status="refunded"] .mentor-calendar-slot-title {
    opacity: 0.95;
  }

  /* Sessions mode: availability hover is light + clickable */
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability {
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1) !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover {
    background-color: #eff6ff !important; /* Blue-50 */
    border-color: #60a5fa !important;     /* Blue-400 */
    transform: translateY(-2px) scale(1.01);
    box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.15), 0 4px 6px -4px rgba(59, 130, 246, 0.1);
    z-index: 50 !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover .mentor-calendar-slot,
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover .mentor-calendar-slot-title,
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover [data-slot-time] {
    color: #1e3a8a !important; /* Blue-900 */
  }

  /* Blink notification for invalid recurring drag (cross-day) */
  .mentor-calendar-root .fc-event.recurring-blink {
    animation: mentorRecurringBlink 0.22s ease-in-out 0s 3;
  }
  @keyframes mentorRecurringBlink {
    0%, 100% { filter: none; }
    50% { filter: brightness(1.35) saturate(0.95); }
  }

  /* --- High Contrast Month View --- */
  .mentor-calendar-root .fc-daygrid-day {
     background-color: #ffffff;
     transition: background-color 0.2s ease;
  }
  .mentor-calendar-root .fc-day-other {
    background-color: #f1f5f9 !important; /* Distinct grey for other month days */
    background-image: repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(0,0,0,0.02) 10px, rgba(0,0,0,0.02) 20px);
  }

  /* --- Square on Right Summary UI (Large Full Height) --- */
  .mentor-calendar-root .fc-daygrid-day-frame {
    position: relative;
  }

  .mentor-calendar-root .mentor-month-square {
    position: absolute;
    top: 6px;
    bottom: 6px;
    right: 6px;
    
    /* "Height same as day box" (minus padding) */
    /* height: auto; (implied by top/bottom) */
    aspect-ratio: 1 / 1;
    max-width: 50%; /* Safeguard */
    
    display: flex;
    align-items: center;
    justify-content: center;
    
    font-size: 1.1rem;
    font-weight: 800;
    color: white; /* Text color for colored backgrounds */
    
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    
    border-radius: 12px; /* Round corners */
    
    opacity: 0.5; /* "Slightly transparent" */
    z-index: 1; /* Behind content generally, but clickable */
  }

  /* Hover state: full opacity and color */
  .mentor-calendar-root .mentor-month-square:hover {
    opacity: 1;
    /* Remove shadow or scale if it fills height? 
       Maybe just opacity change is cleanest for a "block" interface. 
       Or subtle shadow. */
    box-shadow: -4px 0 10px rgba(0,0,0,0.1);
  }

  /* Status Colors - with transparency in base state handled by opacity: 0.5 above, 
     but user asked for colors to be transparent?
     Actually opacity affects text too (making count hard to read).
     Better: Use rgba backgrounds?
     User: "All colors should be slightly transparent and with full color on hover"
     "blue or red ... slightly transparent ... full color on hover"
  */
  
  /* Reset opacity from .mentor-month-square and handle via background-color */
  .mentor-calendar-root .mentor-month-square {
    opacity: 1; /* logic handled below */
  }

  /* Availability Mode */
  .mentor-calendar-root .mentor-month-square.status-availability {
    background-color: rgba(59, 130, 246, 0.5); /* Blue-500 50% */
  }
  .mentor-calendar-root .mentor-month-square.status-availability:hover {
    background-color: rgba(59, 130, 246, 1);
  }

  /* Session Mode Priorities */
  .mentor-calendar-root .mentor-month-square.status-confirmed {
    background-color: rgba(34, 197, 94, 0.5); /* Green-500 50% */
  }
  .mentor-calendar-root .mentor-month-square.status-confirmed:hover {
    background-color: rgba(34, 197, 94, 1);
  }

  .mentor-calendar-root .mentor-month-square.status-invited {
    background-color: rgba(234, 179, 8, 0.5); /* Yellow-500 50% */
  }
  .mentor-calendar-root .mentor-month-square.status-invited:hover {
    background-color: rgba(234, 179, 8, 1);
  }

  .mentor-calendar-root .mentor-month-square.status-draft {
    background-color: rgba(249, 115, 22, 0.5); /* Orange-500 50% */
  }
  .mentor-calendar-root .mentor-month-square.status-draft:hover {
    background-color: rgba(249, 115, 22, 1);
  }

  .mentor-calendar-root .mentor-month-square.status-expired {
    background-color: rgba(148, 163, 184, 0.5); /* Slate-400 50% */
  }
  .mentor-calendar-root .mentor-month-square.status-expired:hover {
    background-color: rgba(148, 163, 184, 1);
  }

  .mentor-calendar-root .mentor-month-square.status-completed {
    background-color: rgba(21, 128, 61, 0.5); /* Dark green 50% */
  }
  .mentor-calendar-root .mentor-month-square.status-completed:hover {
    background-color: rgba(21, 128, 61, 1);
  }

  .mentor-calendar-root .mentor-month-square.status-refunded {
    background-color: rgba(99, 102, 241, 0.5); /* Indigo-500 50% */
  }
  .mentor-calendar-root .mentor-month-square.status-refunded:hover {
    background-color: rgba(99, 102, 241, 1);
  }

  /* Global Collision */
  .mentor-calendar-root .mentor-month-square.status-collision {
    background-color: rgba(239, 68, 68, 0.6); /* Red-500 60% */
  }
  .mentor-calendar-root .mentor-month-square.status-collision:hover {
    background-color: rgba(239, 68, 68, 1);
  }

  /* Move Date Number to Left to avoid covering */
  .mentor-calendar-root .fc-daygrid-day-top {
    justify-content: flex-start; /* Push number to LEFT */
    flex-direction: row;
    padding-left: 6px;
    padding-top: 4px;
    z-index: 5;
  }

</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.css">
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/locales-all.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fullcalendar/interaction@6.1.10/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fullcalendar/luxon3@6.1.10/index.global.min.js"></script>

<script>
(function() {
  const overlay = document.getElementById('mentorCalendarOverlay');
  const root = document.getElementById('mentorCalendarRoot');
  const dateDisplay = document.getElementById('mentorCalendarDateDisplay');
  const saveBtn = document.getElementById('mentorCalendarSaveBtn');
  const modeSessionsBtn = document.getElementById('mentorCalendarModeSessions');
  const modeAvailabilityBtn = document.getElementById('mentorCalendarModeAvailability');
  const sessionSlotTpl = document.getElementById('mentorCalendarSessionSlotTemplate');
  const availabilitySlotTpl = document.getElementById('mentorCalendarAvailabilitySlotTemplate');

  // Availability settings popup (opens on dblclick availability slot)
  const availabilitySettingsOverlay = document.getElementById('mentorAvailabilitySettingsOverlay');
  const availabilitySettingsDateInput = document.getElementById('availabilitySettingsDate');
  const availabilitySettingsTimeInput = document.getElementById('availabilitySettingsTime');
  const availabilitySettingsDurationMinutesEl = document.getElementById('availabilitySettingsDurationMinutes');
  const availabilitySettingsRecurrenceSelect = document.getElementById('availabilitySettingsRecurrence');
  const availabilitySettingsSaveBtn = document.getElementById('availabilitySettingsSaveBtn');
  const availabilitySwitchOverlay = document.getElementById('mentorAvailabilitySwitchModeOverlay');
  const availabilitySwitchToAvailabilityBtn = document.getElementById('availabilitySwitchToAvailabilityBtn');
  const sessionSwitchOverlay = document.getElementById('mentorSessionSwitchModeOverlay');
  const sessionSwitchToSessionsBtn = document.getElementById('sessionSwitchToSessionsBtn');
  const sessionSettingsOverlay = document.getElementById('mentorSessionSettingsOverlay');
  const sessionSettingsDateInput = document.getElementById('sessionSettingsDate');
  const sessionSettingsTimeInput = document.getElementById('sessionSettingsTime');
  const sessionSettingsEndTimeInput = document.getElementById('sessionSettingsEndTime');
  const sessionSettingsMinutesValueEl = document.getElementById('sessionSettingsMinutesValue');
  const sessionSettingsPriceInput = document.getElementById('sessionSettingsPrice');
  const sessionSettingsPriceWarningEl = document.getElementById('sessionSettingsPriceWarning');
  const sessionSettingsInviteCardTitle = document.getElementById('sessionSettingsInviteCardTitle');
  const sessionSettingsClientEmailInput = document.getElementById('sessionSettingsClientEmail');
  const sessionSettingsClientSuggestionsEl = document.getElementById('sessionSettingsClientSuggestions');
  const sessionSettingsInviteBtn = document.getElementById('sessionSettingsInviteBtn');
  const sessionSettingsInviteSentState = document.getElementById('sessionSettingsInviteSentState');
  const sessionSettingsInviteSentSubtitle = document.getElementById('sessionSettingsInviteSentSubtitle');
  const sessionSettingsReminderBtn = document.getElementById('sessionSettingsReminderBtn');
  const sessionSettingsReminderHelp = document.getElementById('sessionSettingsReminderHelp');
  const sessionSettingsApplyFirstNote = document.getElementById('sessionSettingsApplyFirstNote');
  const sessionSettingsSessionDetailLink = document.getElementById('sessionSettingsSessionDetailLink');
  const sessionSettingsSessionDetailSubtitle = document.getElementById('sessionSettingsSessionDetailSubtitle');
  const sessionSettingsApplyBtn = document.getElementById('sessionSettingsApplyBtn');
  const sessionSettingsRefundSection = document.getElementById('sessionSettingsRefundSection');
  const sessionSettingsRefundPriceValue = document.getElementById('sessionSettingsRefundPriceValue');
  const sessionSettingsRefundBtn = document.getElementById('sessionSettingsRefundBtn');
  const sessionSettingsRefundConfirmOverlay = document.getElementById('sessionSettingsRefundConfirmOverlay');
  const sessionSettingsRefundConfirmPriceValue = document.getElementById('sessionSettingsRefundConfirmPriceValue');
  const sessionSettingsRefundConfirmBtn = document.getElementById('sessionSettingsRefundConfirmBtn');
  const scheduleSessionOverlay = document.getElementById('mentorScheduleSessionOverlay');
  const scheduleSessionEmailInput = document.getElementById('scheduleSessionEmailInput');
  const scheduleSessionEmailSuggestionsEl = document.getElementById('scheduleSessionEmailSuggestions');
  const scheduleSessionSendBtn = document.getElementById('scheduleSessionSendBtn');
  const unsavedChangesOverlay = document.getElementById('mentorCalendarUnsavedChangesOverlay');
  const unsavedChangesDiscardBtn = document.getElementById('unsavedChangesDiscardBtn');
  const recurringDeleteOverlay = document.getElementById('mentorRecurringDeleteOverlay');
  const recurringDeleteOneBtn = document.getElementById('recurringDeleteOneBtn');
  const recurringDeleteAllBtn = document.getElementById('recurringDeleteAllBtn');
  const recurringMoveOverlay = document.getElementById('mentorRecurringMoveOverlay');
  const recurringMoveOneBtn = document.getElementById('recurringMoveOneBtn');
  const recurringMoveAllBtn = document.getElementById('recurringMoveAllBtn');
  const sessionChangesOverlay = document.getElementById('mentorSessionChangesOverlay');
  const sessionChangesList = document.getElementById('sessionChangesList');
  const sessionChangesConfirmBtn = document.getElementById('sessionChangesConfirmBtn');
  
  if (!overlay || !root) return;

  let calendar = null;
  // Used to avoid creating a slot right after we programmatically switch to day view (e.g. from month summary click)
  let suppressNextDateClickUntilMs = 0;
  let availabilitySettingsEventId = null;
  let availabilitySwitchEventId = null;
  let availabilitySwitchOpenSettingsAfterSwitch = false;
  let sessionSwitchEventId = null;
  let sessionSwitchOpenSettingsAfterSwitch = false;
  let sessionSettingsEventId = null;
  let scheduleSessionEventId = null;
  let pendingRecurringDelete = null; // { eventId, recurringId, instanceDate }
  let pendingRecurringMove = null;   // { recurringId, instanceDate, newStartIso, newEndIso }

  // Session change tracking
  let originalSessionsById = new Map(); // Map<sessionId, sessionData> - original data from backend
  let changedSessionsById = new Map(); // Map<sessionId, snapshot> - tracked changes
  let lastBlockedPastSessionDrag = null; // Track blocked past session drag to show notification once

  // Timezone source of truth: mentorprofile.selected_timezone (fallback: detected_timezone)
  function resolveMentorTimezone() {
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const data = JSON.parse(dataEl.textContent);
        const selected = (data.selected_timezone || '').trim();
        const detected = (data.detected_timezone || '').trim();
        const tz = selected || detected || 'UTC';
        // Only accept IANA IDs or UTC
        if (tz === 'UTC' || tz.includes('/')) return tz;
      }
    } catch (e) {
      console.warn('[MentorCalendar] Could not parse userProfileData for timezone:', e);
    }
    return 'UTC';
  }

  // Slot length source of truth: mentorprofile.session_length (minutes)
  function resolveMentorSessionLengthMinutes() {
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const data = JSON.parse(dataEl.textContent);
        const raw = data?.session_length;
        const minutes = Number.parseInt(raw, 10);
        if (Number.isFinite(minutes) && minutes > 0 && minutes <= 24 * 60) return minutes;
      }
    } catch (e) {
      console.warn('[MentorCalendar] Could not parse userProfileData for session_length:', e);
    }
    return 60;
  }

  function resolveMentorPricePerHour() {
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const data = JSON.parse(dataEl.textContent);
        const raw = data?.price_per_hour;
        const n = Number(raw);
        if (Number.isFinite(n) && n >= 0) return n;
      }
    } catch (e) {}
    return null;
  }

  function computeDefaultSessionPrice(minutes) {
    const pph = resolveMentorPricePerHour();
    const m = Number(minutes);
    if (!Number.isFinite(m) || m <= 0) return null;
    if (!Number.isFinite(pph) || pph === null) return null;
    const val = (pph * (m / 60));
    return Math.round(val);
  }

  // Calendar timezone variable (used by FullCalendar init + save grouping)
  let timezone_variable = resolveMentorTimezone();

  // --- Availability settings popup helpers ---
  function setAvailabilitySettingsVisible(isVisible) {
    if (!availabilitySettingsOverlay) return;
    availabilitySettingsOverlay.classList.toggle('is-visible', !!isVisible);
    availabilitySettingsOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeAvailabilitySettings() {
    availabilitySettingsEventId = null;
    setAvailabilitySettingsVisible(false);
  }

  function openAvailabilitySettingsForEvent(fcEvent) {
    if (!availabilitySettingsOverlay || !fcEvent) return;
    if (!availabilitySettingsDateInput || !availabilitySettingsTimeInput) return;

    availabilitySettingsEventId = fcEvent.id || null;

    // Duration comes from mentor profile session_length
    const durationMinutes = resolveMentorSessionLengthMinutes();
    if (availabilitySettingsDurationMinutesEl) {
      availabilitySettingsDurationMinutesEl.textContent = String(durationMinutes);
    }

    // Populate start date/time in the calendar timezone
    try {
      if (window.luxon && window.luxon.DateTime && fcEvent.start) {
        const dt = window.luxon.DateTime.fromJSDate(fcEvent.start).setZone(timezone_variable);
        availabilitySettingsDateInput.value = dt.toISODate();      // YYYY-MM-DD
        availabilitySettingsTimeInput.value = dt.toFormat('HH:mm'); // 24h time
      }
    } catch (e) {
      console.warn('[MentorCalendar] Could not prefill availability settings:', e);
    }

    // Prefill recurrence
    try {
      if (availabilitySettingsRecurrenceSelect) {
        let value = 'none';
        if (fcEvent.extendedProps?.isRecurringInstance && fcEvent.extendedProps?.recurringId) {
          const rid = String(fcEvent.extendedProps.recurringId);
          const rule = recurringAvailabilityRules.get(rid);
          if (rule && rule.type) value = String(rule.type);
        } else {
          const key = String(fcEvent.id || '');
          value = (window.MentorCalendarRecurrenceSelections && window.MentorCalendarRecurrenceSelections[key])
            ? String(window.MentorCalendarRecurrenceSelections[key])
            : 'none';
        }
        availabilitySettingsRecurrenceSelect.value = value;
      }
    } catch (e) {}

    setAvailabilitySettingsVisible(true);
  }

  function applyAvailabilitySettings() {
    if (!calendar) return;
    if (!availabilitySettingsEventId) return;
    if (!availabilitySettingsDateInput || !availabilitySettingsTimeInput) return;

    const ev = calendar.getEventById(availabilitySettingsEventId);
    if (!ev) {
      closeAvailabilitySettings();
      return;
    }

    const dateStr = (availabilitySettingsDateInput.value || '').trim();
    const timeStr = (availabilitySettingsTimeInput.value || '').trim();
    if (!dateStr || !timeStr) {
      if (typeof showNotification === 'function') {
        showNotification('Please choose a date and time.', 'error');
      } else {
        alert('Please choose a date and time.');
      }
      return;
    }

    if (!(window.luxon && window.luxon.DateTime)) {
      console.warn('[MentorCalendar] Luxon is required for availability settings editing.');
      return;
    }

    const durationMinutes = resolveMentorSessionLengthMinutes();
    const dt = window.luxon.DateTime.fromISO(`${dateStr}T${timeStr}`, { zone: timezone_variable });
    if (!dt.isValid) {
      if (typeof showNotification === 'function') {
        showNotification('Invalid date/time.', 'error');
      } else {
        alert('Invalid date/time.');
      }
      return;
    }

    const selectedRecurrence = availabilitySettingsRecurrenceSelect
      ? String(availabilitySettingsRecurrenceSelect.value || 'none')
      : 'none';

    // If this is a recurring instance, update the recurring rule (not just this single rendered instance)
    if (ev.extendedProps?.isRecurringInstance && ev.extendedProps?.recurringId) {
      const recurringId = ev.extendedProps.recurringId;
      const rule = recurringAvailabilityRules.get(recurringId);
      if (rule) {
        // Recurrence change (including converting to one-time)
        const nextType = (selectedRecurrence === 'daily' || selectedRecurrence === 'weekly' || selectedRecurrence === 'monthly')
          ? selectedRecurrence
          : 'none';

        if (nextType === 'none') {
          // Convert series -> one-time for this (edited) occurrence and remove series
          const startIso = dt.toJSDate().toISOString();
          const endIso = dt.plus({ minutes: durationMinutes }).toJSDate().toISOString();
          const newId = String(recurringId); // preserve id across conversion (matches dropdown behavior)
          recurringAvailabilityRules.delete(recurringId);
          clearRecurringInstanceEvents();
          calendar.addEvent({
            id: newId,
            start: startIso,
            end: endIso,
            allDay: false,
            backgroundColor: '#3b82f6',
            borderColor: '#2563eb',
            textColor: '#ffffff',
            classNames: ['event-type-availability'],
            editable: true,
            extendedProps: { slotMode: 'availability', type: 'availability_slot', recurringSlotId: recurringId }
          });
          markDirty('availability');
          renderRecurringInstancesForCurrentView();
          recomputeCollisions();
          closeAvailabilitySettings();
          return;
        }

        rule.type = nextType;
        rule.start_date = dateStr;
        rule.start_time = timeStr;
        rule.end_time = dt.plus({ minutes: durationMinutes }).toFormat('HH:mm');
        rule.anchor_date = dateStr;
        if (rule.type === 'weekly') {
          const wd = weekdayNameFromIsoDate(dateStr);
          rule.weekdays = wd ? [wd] : (rule.weekdays || []);
          rule.day_of_month = null;
        } else if (rule.type === 'monthly') {
          rule.day_of_month = dt.day;
          rule.weekdays = [];
        } else if (rule.type === 'daily') {
          rule.weekdays = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];
          rule.day_of_month = null;
        }
        recurringAvailabilityRules.set(recurringId, rule);
        if (window.MentorCalendarRecurrenceSelections) window.MentorCalendarRecurrenceSelections[recurringId] = rule.type;
        markDirty('availability');
        renderRecurringInstancesForCurrentView();
        recomputeCollisions();
        closeAvailabilitySettings();
        return;
      }
    }

    // One-time slot: update this event directly
    const startJs = dt.toJSDate();
    const endJs = dt.plus({ minutes: durationMinutes }).toJSDate();

    // If recurrence changed from one-time -> recurring, convert using the same rules as the dropdown.
    if (selectedRecurrence !== 'none') {
      const nextType = (selectedRecurrence === 'daily' || selectedRecurrence === 'weekly' || selectedRecurrence === 'monthly')
        ? selectedRecurrence
        : 'none';
      if (nextType !== 'none') {
        const startTime = timeStr;
        const endTime = dt.plus({ minutes: durationMinutes }).toFormat('HH:mm');
        const rule = {
          id: String(ev.id),
          type: nextType,
          slot_type: 'availability_slot',
          start_date: dateStr,
          start_time: startTime,
          end_time: endTime,
          skip_dates: [],
          booked_dates: [],
          anchor_date: dateStr
        };
        if (nextType === 'weekly') {
          const wd = weekdayNameFromIsoDate(dateStr);
          rule.weekdays = wd ? [wd] : [];
        } else if (nextType === 'monthly') {
          rule.day_of_month = dt.day;
        } else if (nextType === 'daily') {
          rule.weekdays = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];
        }
        recurringAvailabilityRules.set(rule.id, rule);
        if (window.MentorCalendarRecurrenceSelections) window.MentorCalendarRecurrenceSelections[rule.id] = rule.type;
        ev.remove();
        markDirty('availability');
        renderRecurringInstancesForCurrentView();
        recomputeCollisions();
        closeAvailabilitySettings();
        return;
      }
    }

    ev.setStart(startJs);
    ev.setEnd(endJs);
    if (window.MentorCalendarRecurrenceSelections) window.MentorCalendarRecurrenceSelections[String(ev.id)] = 'none';

    markDirty('availability');
    recomputeCollisions();
    closeAvailabilitySettings();
  }

  // --- Switch-to-availability-mode popup helpers ---
  function setAvailabilitySwitchVisible(isVisible) {
    if (!availabilitySwitchOverlay) return;
    availabilitySwitchOverlay.classList.toggle('is-visible', !!isVisible);
    availabilitySwitchOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeAvailabilitySwitchPopup() {
    availabilitySwitchEventId = null;
    setAvailabilitySwitchVisible(false);
  }

  function openAvailabilitySwitchPopupForEventId(eventId, openSettingsAfterSwitch) {
    if (!availabilitySwitchOverlay) return;
    availabilitySwitchEventId = eventId || null;
    availabilitySwitchOpenSettingsAfterSwitch = !!openSettingsAfterSwitch;
    setAvailabilitySwitchVisible(true);
  }

  function switchToAvailabilityModeAndOpenSettings() {
    if (!calendar) return;
    const id = availabilitySwitchEventId;
    const shouldOpenSettings = !!availabilitySwitchOpenSettingsAfterSwitch;
    closeAvailabilitySwitchPopup();
    if (!id) return;

    setMode(true);
    const ev = calendar.getEventById(id);
    if (ev && shouldOpenSettings) openAvailabilitySettingsForEvent(ev);
  }

  // --- Session settings popup helpers ---
  function setSessionSettingsVisible(isVisible) {
    if (!sessionSettingsOverlay) return;
    sessionSettingsOverlay.classList.toggle('is-visible', !!isVisible);
    sessionSettingsOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeSessionSettings() {
    sessionSettingsEventId = null;
    __sessionSettingsOriginal = null;
    setSessionSettingsVisible(false);
  }

  let __sessionSettingsOriginal = null;
  let __clientSuggestions = [];

  function isValidEmail(email) {
    const v = String(email || '').trim();
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v);
  }

  function setSessionSettingsApplyEnabled(isEnabled) {
    if (!sessionSettingsApplyBtn) return;
    sessionSettingsApplyBtn.disabled = !isEnabled;
  }

  function updateSessionSettingsDerivedUI() {
    if (!sessionSettingsDateInput || !sessionSettingsTimeInput || !sessionSettingsEndTimeInput) return;
    if (!(window.luxon && window.luxon.DateTime)) return;
    const dateStr = (sessionSettingsDateInput.value || '').trim();
    const startStr = (sessionSettingsTimeInput.value || '').trim();
    const endStr = (sessionSettingsEndTimeInput.value || '').trim();
    if (!dateStr || !startStr || !endStr) return;

    const startDt = window.luxon.DateTime.fromISO(`${dateStr}T${startStr}`, { zone: timezone_variable });
    const endDt = window.luxon.DateTime.fromISO(`${dateStr}T${endStr}`, { zone: timezone_variable });
    if (!startDt.isValid || !endDt.isValid || endDt <= startDt) return;

    const minutes = Math.max(0, Math.round(endDt.diff(startDt, 'minutes').minutes));
    if (sessionSettingsMinutesValueEl) sessionSettingsMinutesValueEl.textContent = String(minutes);

    const standardMinutes = resolveMentorSessionLengthMinutes();
    const mismatch = Number.isFinite(standardMinutes) && minutes !== standardMinutes;

    // highlight minutes row + price input when mismatch
    try {
      const minutesRow = sessionSettingsMinutesValueEl ? sessionSettingsMinutesValueEl.closest('.session-settings-row') : null;
      if (minutesRow) minutesRow.classList.toggle('session-settings-row--mismatch', !!mismatch);
      if (sessionSettingsPriceInput) {
        sessionSettingsPriceInput.classList.toggle('session-settings-input--mismatch', !!mismatch);
      }
      const defaultPrice = computeDefaultSessionPrice(standardMinutes);
      const rawPrice = sessionSettingsPriceInput ? String(sessionSettingsPriceInput.value || '').trim() : '';
      const priceVal = rawPrice ? Number(rawPrice) : null;
      const hasOverride = (priceVal !== null) && Number.isFinite(priceVal) && (defaultPrice !== null) && (Number(priceVal) !== Number(defaultPrice));

      if (sessionSettingsPriceWarningEl) {
        if (hasOverride) {
          sessionSettingsPriceWarningEl.hidden = false;
          sessionSettingsPriceWarningEl.classList.add('session-settings-warning--info');
          sessionSettingsPriceWarningEl.textContent = 'You set different price to this session';
        } else if (mismatch) {
          sessionSettingsPriceWarningEl.hidden = false;
          sessionSettingsPriceWarningEl.classList.remove('session-settings-warning--info');
          sessionSettingsPriceWarningEl.textContent = "The time of this session doesn't match your standard session length. Do you want to set a different price?";
        } else {
          sessionSettingsPriceWarningEl.hidden = true;
          sessionSettingsPriceWarningEl.classList.remove('session-settings-warning--info');
        }
      }
    } catch (e) {}

    // Prepopulate price if empty, based on standard session length
    if (sessionSettingsPriceInput && (!sessionSettingsPriceInput.value || String(sessionSettingsPriceInput.value).trim() === '')) {
      const defaultPrice = computeDefaultSessionPrice(standardMinutes);
      if (defaultPrice !== null) sessionSettingsPriceInput.value = String(defaultPrice);
    }
  }

  async function ensureClientSuggestionsLoaded() {
    if (__clientSuggestions && __clientSuggestions.length > 0) return __clientSuggestions;
    try {
      const res = await fetch(CLIENT_SUGGESTIONS_URL, { headers: { 'Accept': 'application/json' } });
      const data = await res.json();
      if (data && data.success && Array.isArray(data.clients)) {
        __clientSuggestions = data.clients.map(c => ({
          first_name: String(c.first_name || ''),
          last_name: String(c.last_name || ''),
          email: String(c.email || '')
        })).filter(c => c.email);
      }
    } catch (e) {}
    return __clientSuggestions;
  }

  function renderClientSuggestionsList(items) {
    if (!sessionSettingsClientSuggestionsEl) return;
    if (!items || items.length === 0) {
      sessionSettingsClientSuggestionsEl.hidden = true;
      sessionSettingsClientSuggestionsEl.innerHTML = '';
      return;
    }
    sessionSettingsClientSuggestionsEl.hidden = false;
    sessionSettingsClientSuggestionsEl.innerHTML = items.slice(0, 8).map((c) => {
      const name = `${c.first_name} ${c.last_name}`.trim() || c.email;
      return `
        <div class="session-settings-suggestion-item" data-email="${c.email}">
          <div class="session-settings-suggestion-name">${name}</div>
          <div class="session-settings-suggestion-email">${c.email}</div>
        </div>
      `;
    }).join('');
    sessionSettingsClientSuggestionsEl.querySelectorAll('[data-email]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const email = el.getAttribute('data-email') || '';
        if (sessionSettingsClientEmailInput) sessionSettingsClientEmailInput.value = email;
        if (sessionSettingsInviteBtn) sessionSettingsInviteBtn.disabled = !isValidEmail(email);
        sessionSettingsClientSuggestionsEl.hidden = true;
        sessionSettingsClientSuggestionsEl.innerHTML = '';
      });
    });
  }

  function openSessionSettingsForEvent(fcEvent) {
    if (!sessionSettingsOverlay || !fcEvent) return;
    if (!sessionSettingsDateInput || !sessionSettingsTimeInput) return;

    sessionSettingsEventId = fcEvent.id || null;

    try {
      if (window.luxon && window.luxon.DateTime && fcEvent.start) {
        const dt = window.luxon.DateTime.fromJSDate(fcEvent.start).setZone(timezone_variable);
        sessionSettingsDateInput.value = dt.toISODate();
        sessionSettingsTimeInput.value = dt.toFormat('HH:mm');
      }
      if (window.luxon && window.luxon.DateTime && fcEvent.end && sessionSettingsEndTimeInput) {
        const dtEnd = window.luxon.DateTime.fromJSDate(fcEvent.end).setZone(timezone_variable);
        sessionSettingsEndTimeInput.value = dtEnd.toFormat('HH:mm');
      }
      if (sessionSettingsPriceInput) {
        const p = fcEvent.extendedProps?.sessionPrice;
        sessionSettingsPriceInput.value = (p !== undefined && p !== null) ? String(p) : '';
      }
      if (sessionSettingsClientEmailInput) {
        sessionSettingsClientEmailInput.value = fcEvent.extendedProps?.clientEmail ? String(fcEvent.extendedProps.clientEmail) : '';
      }
      if (sessionSettingsInviteBtn) {
        sessionSettingsInviteBtn.disabled = !isValidEmail(sessionSettingsClientEmailInput?.value || '');
        // Reset invitation sent flag and loading state when opening a new session
        const status = String(fcEvent?.extendedProps?.status || '').toLowerCase();
        const email = String(fcEvent?.extendedProps?.clientEmail || '').trim();
        const invitationSent = !!fcEvent?.extendedProps?.invitationSent || (status === 'invited' && !!email);
        sessionSettingsInviteBtn.__invitationSent = invitationSent;
        sessionSettingsInviteBtn.classList.remove('is-loading');
      }
      // Let derived UI decide whether to show mismatch/override messages
    } catch (e) {
      console.warn('[MentorCalendar] Could not prefill session settings:', e);
    }

    async function setInviteUiForEvent(ev) {
      const status = String(ev?.extendedProps?.status || '').toLowerCase();
      const email = String(ev?.extendedProps?.clientEmail || '').trim();
      const invitationSent = !!ev?.extendedProps?.invitationSent || (status === 'invited' && !!email);
      const canRemind = !!ev?.extendedProps?.canRemind;
      const lastSentAt = String(ev?.extendedProps?.lastInviteSentAt || '').trim();

      const isInvited = status === 'invited';
      const isConfirmed = status === 'confirmed';
      const isCompleted = status === 'completed';
      const isRefunded = status === 'refunded';
      const isDraft = status === 'draft' || !status;
      // Never show "sent" UI for draft sessions
      const showSent = (!!email) && (isInvited || isConfirmed);
      const sessionDbId = ev?.extendedProps?.sessionDbId;
      // Show the card as soon as the session exists in DB, but disable until invited/confirmed.
      const showSessionDetail = !!sessionDbId;
      const enableSessionDetail = !!sessionDbId && (isInvited || isConfirmed);
      
      // For completed sessions, show refund UI instead of normal settings
      if (isCompleted) {
        // Hide normal session settings section
        const normalSection = document.getElementById('sessionSettingsNormalSection');
        if (normalSection) normalSection.hidden = true;
        
        // Show completed section with all session details
        const completedSection = document.getElementById('sessionSettingsCompletedSection');
        if (completedSection) {
          completedSection.hidden = false;
          
          // Client name and email - look up from client suggestions
          const clientEmail = ev?.extendedProps?.clientEmail || '';
          let clientFirstName = '';
          let clientLastName = '';
          let clientName = '--';
          
          if (clientEmail) {
            // Try to get client name from suggestions
            try {
              const clients = await ensureClientSuggestionsLoaded();
              const client = clients.find(c => c.email.toLowerCase() === clientEmail.toLowerCase());
              if (client) {
                clientFirstName = client.first_name || '';
                clientLastName = client.last_name || '';
                clientName = `${clientFirstName} ${clientLastName}`.trim() || '--';
              } else {
                // Fallback to email prefix if name not found
                const emailPrefix = clientEmail.split('@')[0];
                clientName = emailPrefix || '--';
              }
            } catch (e) {
              console.warn('[MentorCalendar] Could not load client suggestions:', e);
              const emailPrefix = clientEmail.split('@')[0];
              clientName = emailPrefix || '--';
            }
          }
          
          const clientValueEl = document.getElementById('sessionSettingsCompletedClientValue');
          if (clientValueEl) {
            clientValueEl.textContent = clientName;
          }
          
          const emailValueEl = document.getElementById('sessionSettingsCompletedEmailValue');
          if (emailValueEl) {
            emailValueEl.textContent = clientEmail || '--';
          }
          
          // Date & Time (from - to)
          let dateTimeValue = '--';
          if (window.luxon && window.luxon.DateTime && ev?.start && ev?.end) {
            try {
              const startDt = window.luxon.DateTime.fromJSDate(ev.start).setZone(timezone_variable);
              const endDt = window.luxon.DateTime.fromJSDate(ev.end).setZone(timezone_variable);
              const dateStr = startDt.toFormat('MMM d, yyyy');
              const startTimeStr = startDt.toFormat('h:mm a');
              const endTimeStr = endDt.toFormat('h:mm a');
              dateTimeValue = `${dateStr}  ${startTimeStr} - ${endTimeStr}`;
            } catch (e) {
              console.warn('[MentorCalendar] Could not format date/time for completed session:', e);
            }
          }
          const dateTimeValueEl = document.getElementById('sessionSettingsCompletedDateTimeValue');
          if (dateTimeValueEl) {
            dateTimeValueEl.textContent = dateTimeValue;
          }
          
          // Minutes
          let minutesValue = '--';
          if (ev?.start && ev?.end) {
            try {
              const startMs = ev.start.getTime();
              const endMs = ev.end.getTime();
              const diffMs = endMs - startMs;
              const diffMinutes = Math.round(diffMs / (1000 * 60));
              minutesValue = `${diffMinutes} min`;
            } catch (e) {
              console.warn('[MentorCalendar] Could not calculate minutes for completed session:', e);
            }
          }
          const minutesValueEl = document.getElementById('sessionSettingsCompletedMinutesValue');
          if (minutesValueEl) {
            minutesValueEl.textContent = minutesValue;
          }
          
          // Price
          const price = ev?.extendedProps?.sessionPrice;
          const priceValueEl = document.getElementById('sessionSettingsCompletedPriceValue');
          if (priceValueEl) {
            priceValueEl.textContent = price !== null && price !== undefined 
              ? `$${String(price)}` 
              : 'Free';
          }
          
        }
        
        // Show session detail section (outside completed section, in left column)
        const completedSessionDetailSection = document.getElementById('sessionSettingsCompletedSessionDetailSection');
        const completedSessionDetailLink = document.getElementById('sessionSettingsCompletedSessionDetailLink');
        if (completedSessionDetailSection && completedSessionDetailLink && sessionDbId) {
          completedSessionDetailSection.hidden = false;
          completedSessionDetailLink.hidden = false;
          try {
            completedSessionDetailLink.href = SESSION_DETAIL_URL_TEMPLATE.replace('0', String(sessionDbId));
          } catch (e) {
            completedSessionDetailLink.href = '#';
          }
        }
        
        // Show refund section in right column
        if (sessionSettingsRefundSection) {
          sessionSettingsRefundSection.hidden = false;
          // Show refund price
          const price = ev?.extendedProps?.sessionPrice;
          if (sessionSettingsRefundPriceValue) {
            sessionSettingsRefundPriceValue.textContent = price !== null && price !== undefined 
              ? `$${String(price)}` 
              : 'Free';
          }
        }
        
        // Hide right column invite section
        const rightCol = document.querySelector('.session-settings-col--right');
        if (rightCol) {
          const inviteSection = rightCol.querySelector('.session-settings-section--assign');
          if (inviteSection) inviteSection.hidden = true;
        }
        return; // Early return for completed sessions
      } else {
        // Hide completed section, completed session detail section, and refund section for non-completed sessions
        const completedSection = document.getElementById('sessionSettingsCompletedSection');
        if (completedSection) completedSection.hidden = true;
        
        const completedSessionDetailSection = document.getElementById('sessionSettingsCompletedSessionDetailSection');
        if (completedSessionDetailSection) completedSessionDetailSection.hidden = true;
        
        // Show normal session settings section
        const normalSection = document.getElementById('sessionSettingsNormalSection');
        if (normalSection) normalSection.hidden = false;
        
        if (sessionSettingsRefundSection) {
          sessionSettingsRefundSection.hidden = true;
        }
        
        // Show right column sections
        const rightCol = document.querySelector('.session-settings-col--right');
        if (rightCol) {
          rightCol.querySelectorAll('.session-settings-section:not(.session-settings-section--refund)').forEach(section => {
            section.hidden = false;
          });
        }
      }

      // If Apply is enabled, there are unapplied edits (disable invite/reminder until applied).
      const applyEnabled = !!(sessionSettingsApplyBtn && !sessionSettingsApplyBtn.disabled);
      if (sessionSettingsInviteCardTitle) {
        sessionSettingsInviteCardTitle.textContent = isConfirmed ? 'Session confirmed' : (showSent ? 'Invitation sent' : 'Invite a Client');
      }
      if (sessionSettingsInviteSentState) sessionSettingsInviteSentState.hidden = isDraft || !showSent;
      if (sessionSettingsInviteSentSubtitle) {
        if (isConfirmed) sessionSettingsInviteSentSubtitle.textContent = `Session confirmed by ${email}.`;
        else sessionSettingsInviteSentSubtitle.textContent = showSent ? `Invitation sent to ${email}.` : '';
      }

      if (sessionSettingsClientEmailInput) sessionSettingsClientEmailInput.hidden = showSent;
      if (sessionSettingsInviteBtn) sessionSettingsInviteBtn.hidden = showSent;
      if (sessionSettingsClientSuggestionsEl) {
        sessionSettingsClientSuggestionsEl.hidden = true;
        sessionSettingsClientSuggestionsEl.innerHTML = '';
      }

      if (sessionSettingsReminderBtn) {
        // Reminders only make sense while invited (not confirmed)
        sessionSettingsReminderBtn.hidden = !showSent || isConfirmed;
        sessionSettingsReminderBtn.disabled = (applyEnabled || !showSent || !canRemind || isConfirmed);
      }
      if (sessionSettingsReminderHelp) {
        if (!showSent) sessionSettingsReminderHelp.textContent = '';
        else if (isConfirmed) sessionSettingsReminderHelp.textContent = 'This session is confirmed.';
        else if (canRemind) sessionSettingsReminderHelp.textContent = 'You can send one reminder per day.';
        else sessionSettingsReminderHelp.textContent = lastSentAt ? 'Reminder already sent today.' : 'Invitation already sent today.';
      }

      // Color styling to match session status in calendar
      if (sessionSettingsInviteSentState) {
        sessionSettingsInviteSentState.classList.toggle('session-settings-invite-state--invited', isInvited && !isConfirmed);
        sessionSettingsInviteSentState.classList.toggle('session-settings-invite-state--confirmed', isConfirmed);
      }

      // Apply-first note + disable send invitation when there are unapplied changes
      if (sessionSettingsInviteBtn && !sessionSettingsInviteBtn.hidden) {
        const emailVal = String(sessionSettingsClientEmailInput?.value || '').trim();
        // Sync invitation sent flag with event state
        if (sessionSettingsInviteBtn.__invitationSent !== undefined) {
          sessionSettingsInviteBtn.__invitationSent = invitationSent;
        }
        sessionSettingsInviteBtn.disabled = applyEnabled || !isValidEmail(emailVal) || !sessionDbId || invitationSent;
        sessionSettingsInviteBtn.classList.remove('is-loading');
      }
      if (sessionSettingsApplyFirstNote) {
        const showNote = applyEnabled && (
          (!!sessionSettingsInviteBtn && !sessionSettingsInviteBtn.hidden) ||
          (!!sessionSettingsReminderBtn && !sessionSettingsReminderBtn.hidden)
        );
        sessionSettingsApplyFirstNote.hidden = !showNote;
      }

      // Session detail page link
      if (sessionSettingsSessionDetailLink) {
        sessionSettingsSessionDetailLink.hidden = !showSessionDetail;
        sessionSettingsSessionDetailLink.classList.toggle('is-disabled', !enableSessionDetail);
        sessionSettingsSessionDetailLink.setAttribute('aria-disabled', enableSessionDetail ? 'false' : 'true');
        if (showSessionDetail) {
          try {
            sessionSettingsSessionDetailLink.href = enableSessionDetail
              ? SESSION_DETAIL_URL_TEMPLATE.replace('0', String(sessionDbId))
              : '#';
          } catch (e) {}
        }
        if (sessionSettingsSessionDetailSubtitle) {
          if (!showSessionDetail) sessionSettingsSessionDetailSubtitle.textContent = 'Open the dedicated session page';
          else if (!enableSessionDetail) sessionSettingsSessionDetailSubtitle.textContent = 'Send the invitation to a client to unlock this page';
          else sessionSettingsSessionDetailSubtitle.textContent = 'Open the dedicated session page';
        }
      }
    }

    // Initial render of invite/reminder UI state
    try { setInviteUiForEvent(fcEvent); } catch (e) {}

    // Prevent clicking disabled session detail link (show message instead)
    if (sessionSettingsSessionDetailLink && !sessionSettingsSessionDetailLink.__mentorBound) {
      sessionSettingsSessionDetailLink.__mentorBound = true;
      sessionSettingsSessionDetailLink.addEventListener('click', (e) => {
        try {
          const aria = sessionSettingsSessionDetailLink.getAttribute('aria-disabled');
          const isDisabled = aria === 'true' || sessionSettingsSessionDetailLink.classList.contains('is-disabled');
          if (isDisabled) {
            e.preventDefault();
            e.stopPropagation();
            if (typeof showNotification === 'function') {
              showNotification('Send the invitation to a client first to open the session page.', 'error');
            }
          }
        } catch (err) {}
      });
    }

    __sessionSettingsOriginal = {
      date: sessionSettingsDateInput.value || '',
      start: sessionSettingsTimeInput.value || '',
      end: sessionSettingsEndTimeInput ? (sessionSettingsEndTimeInput.value || '') : '',
      price: sessionSettingsPriceInput ? (sessionSettingsPriceInput.value || '') : ''
    };
    setSessionSettingsApplyEnabled(false);
    updateSessionSettingsDerivedUI();

    // Bind form change listeners once
    [sessionSettingsDateInput, sessionSettingsTimeInput, sessionSettingsEndTimeInput, sessionSettingsPriceInput].forEach((el) => {
      if (!el || el.__mentorBound) return;
      el.__mentorBound = true;
      el.addEventListener('input', () => {
        updateSessionSettingsDerivedUI();
        if (!__sessionSettingsOriginal) return;
        const cur = {
          date: sessionSettingsDateInput.value || '',
          start: sessionSettingsTimeInput.value || '',
          end: sessionSettingsEndTimeInput ? (sessionSettingsEndTimeInput.value || '') : '',
          price: sessionSettingsPriceInput ? (sessionSettingsPriceInput.value || '') : ''
        };
        setSessionSettingsApplyEnabled(JSON.stringify(cur) !== JSON.stringify(__sessionSettingsOriginal));
        try {
          const latestEv = calendar?.getEventById?.(sessionSettingsEventId) || fcEvent;
          if (latestEv) setInviteUiForEvent(latestEv);
        } catch (e) {}
      });
    });

    // Client suggestions filter
    if (sessionSettingsClientEmailInput && sessionSettingsClientSuggestionsEl && !sessionSettingsClientEmailInput.__mentorBound) {
      sessionSettingsClientEmailInput.__mentorBound = true;
      sessionSettingsClientEmailInput.addEventListener('input', async () => {
        const raw = String(sessionSettingsClientEmailInput.value || '');
        const q = raw.toLowerCase().trim();
        if (sessionSettingsInviteBtn) sessionSettingsInviteBtn.disabled = !isValidEmail(raw);
        if (!q) return renderClientSuggestionsList([]);
        const all = await ensureClientSuggestionsLoaded();
        const filtered = all.filter(c => (`${c.first_name} ${c.last_name} ${c.email}`.toLowerCase()).includes(q));
        renderClientSuggestionsList(filtered);
      });
      document.addEventListener('click', (e) => {
        const target = e.target;
        if (!(target instanceof Element)) return;
        if (target.closest('#sessionSettingsClientSuggestions')) return;
        if (target.closest('#sessionSettingsClientEmail')) return;
        if (sessionSettingsClientSuggestionsEl) sessionSettingsClientSuggestionsEl.hidden = true;
      }, { capture: true });
    }

    // Invite button
    if (sessionSettingsInviteBtn && !sessionSettingsInviteBtn.__mentorBound) {
      sessionSettingsInviteBtn.__mentorBound = true;
      sessionSettingsInviteBtn.__invitationSent = false; // Track if invitation has been sent
      sessionSettingsInviteBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        
        // Prevent sending if already sent
        if (sessionSettingsInviteBtn.__invitationSent) {
          return;
        }
        
        const email = (sessionSettingsClientEmailInput?.value || '').trim();
        if (!isValidEmail(email)) return;
        let ev = calendar && sessionSettingsEventId ? calendar.getEventById(sessionSettingsEventId) : null;
        if (!ev) return;
        
        // Show loading spinner and disable button
        sessionSettingsInviteBtn.classList.add('is-loading');
        sessionSettingsInviteBtn.disabled = true;
        
        let sessionId = ev?.extendedProps?.sessionDbId;
        
        // If session hasn't been saved yet, auto-save it first
        if (!sessionId) {
          try {
            // Apply session settings locally first
            const dateStr = (sessionSettingsDateInput?.value || '').trim();
            const timeStr = (sessionSettingsTimeInput?.value || '').trim();
            const endStr = (sessionSettingsEndTimeInput?.value || '').trim();
            
            if (!dateStr || !timeStr || !endStr) {
              sessionSettingsInviteBtn.classList.remove('is-loading');
              sessionSettingsInviteBtn.disabled = false;
              if (typeof showNotification === 'function') {
                showNotification('Please choose a date, start time, and end time.', 'error');
              }
              return;
            }
            
            if (window.luxon && window.luxon.DateTime) {
              const startDt = window.luxon.DateTime.fromISO(`${dateStr}T${timeStr}`, { zone: timezone_variable });
              const endDt = window.luxon.DateTime.fromISO(`${dateStr}T${endStr}`, { zone: timezone_variable });
              
              if (startDt.isValid && endDt.isValid && endDt > startDt) {
                ev.setStart(startDt.toJSDate());
                ev.setEnd(endDt.toJSDate());
                
                // Persist overrides on the event
                if (sessionSettingsPriceInput) {
                  const v = String(sessionSettingsPriceInput.value || '').trim();
                  ev.setExtendedProp('sessionPrice', v === '' ? null : v);
                }
                ev.setExtendedProp('clientEmail', email || null);
                // Look up client name from suggestions
                if (email) {
                  try {
                    const clients = await ensureClientSuggestionsLoaded();
                    const client = clients.find(c => c.email.toLowerCase() === email.toLowerCase());
                    if (client) {
                      ev.setExtendedProp('clientFirstName', client.first_name || null);
                      ev.setExtendedProp('clientLastName', client.last_name || null);
                    } else {
                      ev.setExtendedProp('clientFirstName', null);
                      ev.setExtendedProp('clientLastName', null);
                    }
                  } catch (e) {
                    console.warn('[MentorCalendar] Could not load client suggestions:', e);
                    ev.setExtendedProp('clientFirstName', null);
                    ev.setExtendedProp('clientLastName', null);
                  }
                } else {
                  ev.setExtendedProp('clientFirstName', null);
                  ev.setExtendedProp('clientLastName', null);
                }
                
                markDirty('session');
                recomputeCollisions();
                
                // Check for collisions before saving
                const collisions = computeCalendarCollisionsInHorizon();
                if (collisions.length > 0) {
                  const canOpenPopup = (typeof window.openCollisionResolutionPopup === 'function');
                  if (canOpenPopup) {
                    sessionSettingsInviteBtn.classList.remove('is-loading');
                    sessionSettingsInviteBtn.disabled = false;
                    window.openCollisionResolutionPopup(false);
                    return;
                  } else if (typeof showNotification === 'function') {
                    sessionSettingsInviteBtn.classList.remove('is-loading');
                    sessionSettingsInviteBtn.disabled = false;
                    showNotification('Please resolve collisions before sending invitation.', 'warning');
                    return;
                  }
                }
                
                // Save to backend (this will also call loadSavedAvailability which reloads events)
                await saveAvailabilityToBackend();
                
                // If save was blocked due to collisions, it returns early
                // Check if save actually completed by checking if collisions still exist
                const collisionsAfterSave = computeCalendarCollisionsInHorizon();
                if (collisionsAfterSave.length > 0) {
                  // Save was blocked, collision popup should be open
                  sessionSettingsInviteBtn.classList.remove('is-loading');
                  sessionSettingsInviteBtn.disabled = false;
                  return;
                }
                
                // After save, events are reloaded so we need to find the session by matching start/end time and email
                // The event ID might have changed, so we match by time and client email
                const allSessionEvents = calendar.getEvents().filter(ev => 
                  ev.extendedProps?.slotMode === 'session'
                );
                
                // Find the session that matches our start/end time and client email
                const matchingEv = allSessionEvents.find(ev => {
                  if (!ev.start || !ev.end) return false;
                  const evStartTime = ev.start.getTime();
                  const evEndTime = ev.end.getTime();
                  const targetStartTime = startDt.toJSDate().getTime();
                  const targetEndTime = endDt.toJSDate().getTime();
                  
                  // Match within 1 second tolerance (in case of timezone rounding)
                  const timeMatches = Math.abs(evStartTime - targetStartTime) < 1000 && 
                                     Math.abs(evEndTime - targetEndTime) < 1000;
                  const emailMatches = (ev.extendedProps?.clientEmail || '').trim().toLowerCase() === email.toLowerCase();
                  
                  return timeMatches && emailMatches;
                });
                
                if (matchingEv) {
                  // Extract sessionDbId from event ID (format: session_${dbId}) or extendedProps
                  const evId = String(matchingEv.id || '');
                  if (evId.startsWith('session_')) {
                    const dbIdStr = evId.replace('session_', '');
                    sessionId = dbIdStr ? parseInt(dbIdStr, 10) : null;
                  } else {
                    sessionId = matchingEv.extendedProps?.sessionDbId || null;
                  }
                  
                  // Update sessionSettingsEventId to the new event ID so UI stays in sync
                  sessionSettingsEventId = matchingEv.id;
                }
                
                if (!sessionId) {
                  sessionSettingsInviteBtn.classList.remove('is-loading');
                  sessionSettingsInviteBtn.disabled = false;
                  if (typeof showNotification === 'function') {
                    showNotification('Session was saved but could not be found. Please try sending the invitation again.', 'error');
                  }
                  return;
                }
                
                // Update the event reference to the matched event for later use
                if (matchingEv) {
                  ev = matchingEv;
                }
              } else {
                sessionSettingsInviteBtn.classList.remove('is-loading');
                sessionSettingsInviteBtn.disabled = false;
                if (typeof showNotification === 'function') {
                  showNotification('Invalid date/time.', 'error');
                }
                return;
              }
            }
          } catch (saveErr) {
            console.error('[MentorCalendar] Error auto-saving session:', saveErr);
            sessionSettingsInviteBtn.classList.remove('is-loading');
            sessionSettingsInviteBtn.disabled = false;
            if (typeof showNotification === 'function') {
              showNotification('Failed to save session. Please try again.', 'error');
            }
            return;
          }
        }
        
        // Now send the invitation
        // IMPORTANT: Send the current calendar event position (start/end) to ensure
        // the session is updated to match the current position before creating the invitation
        // This handles the case where the session was moved but not saved
        const currentStart = ev?.start ? ev.start.toISOString() : null;
        const currentEnd = ev?.end ? ev.end.toISOString() : null;
        
        const csrf = getCookie('csrftoken');
        try {
          const res = await fetch(INVITE_SESSION_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrf || '' },
            body: JSON.stringify({ 
              email, 
              session_id: sessionId,
              start_iso: currentStart,
              end_iso: currentEnd
            })
          });
          const data = await res.json();
          if (data && data.success) {
            // Mark as sent and keep button disabled
            sessionSettingsInviteBtn.__invitationSent = true;
            sessionSettingsInviteBtn.classList.remove('is-loading');
            sessionSettingsInviteBtn.disabled = true;
            
            if (typeof showNotification === 'function') showNotification('Session invitation sent.', 'success');
            // Update UI state immediately and refresh from DB
            try {
              ev.setExtendedProp('clientEmail', email);
              // Look up client name from suggestions
              let clientFirstName = null;
              let clientLastName = null;
              try {
                const clients = await ensureClientSuggestionsLoaded();
                const client = clients.find(c => c.email.toLowerCase() === email.toLowerCase());
                if (client) {
                  clientFirstName = client.first_name || null;
                  clientLastName = client.last_name || null;
                }
              } catch (e) {
                console.warn('[MentorCalendar] Could not load client suggestions for name lookup:', e);
              }
              ev.setExtendedProp('clientFirstName', clientFirstName);
              ev.setExtendedProp('clientLastName', clientLastName);
              ev.setExtendedProp('status', 'invited');
              ev.setExtendedProp('invitationSent', true);
              ev.setExtendedProp('canRemind', !!data?.can_remind);
              ev.setExtendedProp('lastInviteSentAt', data?.last_sent_at || null);
              const colors = sessionColorsForStatus('invited');
              ev.setProp('backgroundColor', colors.bg);
              ev.setProp('borderColor', colors.border);
              ev.setProp('textColor', colors.text);
            } catch (e) {}
            try { setInviteUiForEvent(ev); } catch (e) {}
            try { await loadSavedAvailability(); } catch (e) {}
          } else {
            // On error, remove loading state but keep disabled if already sent
            sessionSettingsInviteBtn.classList.remove('is-loading');
            if (!sessionSettingsInviteBtn.__invitationSent) {
              sessionSettingsInviteBtn.disabled = false;
            }
            if (typeof showNotification === 'function') showNotification(data?.error || 'Could not send session invitation.', 'error');
          }
        } catch (err) {
          // On error, remove loading state but keep disabled if already sent
          sessionSettingsInviteBtn.classList.remove('is-loading');
          if (!sessionSettingsInviteBtn.__invitationSent) {
            sessionSettingsInviteBtn.disabled = false;
          }
          if (typeof showNotification === 'function') showNotification('Could not send session invitation.', 'error');
        }
      });
    }

    // Reminder button
    if (sessionSettingsReminderBtn && !sessionSettingsReminderBtn.__mentorBound) {
      sessionSettingsReminderBtn.__mentorBound = true;
      sessionSettingsReminderBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        const ev = calendar && sessionSettingsEventId ? calendar.getEventById(sessionSettingsEventId) : null;
        const sessionId = ev?.extendedProps?.sessionDbId;
        const email = String(ev?.extendedProps?.clientEmail || '').trim();
        if (!sessionId || !email) return;
        const csrf = getCookie('csrftoken');
        try {
          sessionSettingsReminderBtn.disabled = true;
          const res = await fetch(REMIND_SESSION_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrf || '' },
            body: JSON.stringify({ session_id: sessionId })
          });
          const data = await res.json();
          if (data && data.success) {
            if (typeof showNotification === 'function') showNotification('Reminder sent.', 'success');
            try {
              ev.setExtendedProp('canRemind', !!data?.can_remind);
              ev.setExtendedProp('lastInviteSentAt', data?.last_sent_at || null);
            } catch (e) {}
            try { setInviteUiForEvent(ev); } catch (e) {}
          } else {
            if (typeof showNotification === 'function') showNotification(data?.error || 'Could not send reminder.', 'error');
            try { setInviteUiForEvent(ev); } catch (e) {}
          }
        } catch (e2) {
          if (typeof showNotification === 'function') showNotification('Could not send reminder.', 'error');
          try { setInviteUiForEvent(ev); } catch (e3) {}
        }
      });
    }

    setSessionSettingsVisible(true);
  }

  /**
   * Track session mutations (drag & drop, resize, settings popup save)
   * This is the ONLY function allowed to track changes to changedSessionsById
   */
  function onSessionMutated(ev) {
    if (!ev) return;
    const slotMode = ev.extendedProps?.slotMode;
    if (slotMode !== 'session') return;
    
    const sessionDbId = ev.extendedProps?.sessionDbId;
    if (!sessionDbId) return; // New sessions (not saved yet) don't have sessionDbId
    
    const status = ev.extendedProps?.status || 'draft';
    // If session.status is draft, return immediately
    if (status === 'draft') return;
    
    // Create full session snapshot
    const fullSessionSnapshot = {
      id: sessionDbId,
      start: ev.start ? ev.start.toISOString() : null,
      end: ev.end ? ev.end.toISOString() : null,
      status: status,
      session_price: ev.extendedProps?.sessionPrice ?? null,
      client_email: ev.extendedProps?.clientEmail || null,
      client_first_name: ev.extendedProps?.clientFirstName || null,
      client_last_name: ev.extendedProps?.clientLastName || null,
      expires_at: ev.extendedProps?.expiresAt || null,
      session_type: ev.extendedProps?.sessionType || 'individual',
      invitation_sent: !!ev.extendedProps?.invitationSent,
      can_remind: !!ev.extendedProps?.canRemind,
      last_invite_sent_at: ev.extendedProps?.lastInviteSentAt || null
    };
    
    // Check if snapshot already exists in changedSessionsById
    if (changedSessionsById.has(sessionDbId)) {
      // Get original session data
      const original = originalSessionsById.get(sessionDbId);
      if (original) {
        // Normalize ISO strings for comparison (handle format differences)
        const normalizeIso = (iso) => {
          if (!iso) return null;
          try {
            // Parse and re-stringify to normalize format
            return new Date(iso).toISOString();
          } catch (e) {
            return String(iso);
          }
        };
        
        const normalizedStart = normalizeIso(fullSessionSnapshot.start);
        const normalizedEnd = normalizeIso(fullSessionSnapshot.end);
        const normalizedExpiresAt = normalizeIso(fullSessionSnapshot.expires_at);
        const normalizedLastInviteSentAt = normalizeIso(fullSessionSnapshot.last_invite_sent_at);
        
        const originalNormalizedStart = normalizeIso(original.start);
        const originalNormalizedEnd = normalizeIso(original.end);
        const originalNormalizedExpiresAt = normalizeIso(original.expires_at);
        const originalNormalizedLastInviteSentAt = normalizeIso(original.last_invite_sent_at);
        
        // Normalize session_price for comparison (handle string vs number)
        const normalizePrice = (price) => {
          if (price === null || price === undefined) return null;
          return String(price);
        };
        
        // Compare new snapshot with original
        const isSame = 
          fullSessionSnapshot.id === original.id &&
          normalizedStart === originalNormalizedStart &&
          normalizedEnd === originalNormalizedEnd &&
          fullSessionSnapshot.status === original.status &&
          normalizePrice(fullSessionSnapshot.session_price) === normalizePrice(original.session_price) &&
          (fullSessionSnapshot.client_email === original.client_email || 
           (fullSessionSnapshot.client_email === null && original.client_email === null)) &&
          normalizedExpiresAt === originalNormalizedExpiresAt &&
          fullSessionSnapshot.session_type === original.session_type &&
          fullSessionSnapshot.invitation_sent === original.invitation_sent &&
          fullSessionSnapshot.can_remind === original.can_remind &&
          normalizedLastInviteSentAt === originalNormalizedLastInviteSentAt;
        
        // Debug logging for comparison
        if (!isSame) {
          console.log('[MentorCalendar] onSessionMutated - Comparison failed for session', sessionDbId, {
            start: { snapshot: normalizedStart, original: originalNormalizedStart, match: normalizedStart === originalNormalizedStart },
            end: { snapshot: normalizedEnd, original: originalNormalizedEnd, match: normalizedEnd === originalNormalizedEnd },
            status: { snapshot: fullSessionSnapshot.status, original: original.status, match: fullSessionSnapshot.status === original.status },
            price: { snapshot: normalizePrice(fullSessionSnapshot.session_price), original: normalizePrice(original.session_price), match: normalizePrice(fullSessionSnapshot.session_price) === normalizePrice(original.session_price) },
            email: { snapshot: fullSessionSnapshot.client_email, original: original.client_email, match: fullSessionSnapshot.client_email === original.client_email }
          });
        }
        
        if (isSame) {
          // If they are completely same, delete the snapshot
          changedSessionsById.delete(sessionDbId);
          console.log('[MentorCalendar] onSessionMutated - Session', sessionDbId, 'matches original, removed from changedSessionsById');
        } else {
          // If they are not the same, always REWRITE the snapshot
          changedSessionsById.set(sessionDbId, fullSessionSnapshot);
        }
      } else {
        // Original not found, but we have a change - keep it
        console.warn('[MentorCalendar] onSessionMutated - Original not found for session', sessionDbId);
        changedSessionsById.set(sessionDbId, fullSessionSnapshot);
      }
    } else {
      // No snapshot exists, simply add it
      changedSessionsById.set(sessionDbId, fullSessionSnapshot);
    }
    
    // Log changedSessionsById after mutation (convert Map to object for better console readability)
    const changedSessionsObj = Object.fromEntries(changedSessionsById);
    console.log('[MentorCalendar] onSessionMutated - changedSessionsById:', changedSessionsObj, `(size: ${changedSessionsById.size})`);
  }

  async function applySessionSettings() {
    if (!calendar) return;
    if (!sessionSettingsEventId) return;
    if (!sessionSettingsDateInput || !sessionSettingsTimeInput) return;

    const ev = calendar.getEventById(sessionSettingsEventId);
    if (!ev) {
      closeSessionSettings();
      return;
    }

    const dateStr = (sessionSettingsDateInput.value || '').trim();
    const timeStr = (sessionSettingsTimeInput.value || '').trim();
    const endStr = (sessionSettingsEndTimeInput?.value || '').trim();
    if (!dateStr || !timeStr || !endStr) {
      if (typeof showNotification === 'function') {
        showNotification('Please choose a date, start time, and end time.', 'error');
      } else {
        alert('Please choose a date, start time, and end time.');
      }
      return;
    }

    if (!(window.luxon && window.luxon.DateTime)) {
      console.warn('[MentorCalendar] Luxon is required for session settings editing.');
      return;
    }

    const startDt = window.luxon.DateTime.fromISO(`${dateStr}T${timeStr}`, { zone: timezone_variable });
    const endDt = window.luxon.DateTime.fromISO(`${dateStr}T${endStr}`, { zone: timezone_variable });
    if (!startDt.isValid || !endDt.isValid || endDt <= startDt) {
      if (typeof showNotification === 'function') {
        showNotification('Invalid date/time.', 'error');
      } else {
        alert('Invalid date/time.');
      }
      return;
    }

    ev.setStart(startDt.toJSDate());
    ev.setEnd(endDt.toJSDate());

    // Persist overrides on the event (saved to DB on Save)
    if (sessionSettingsPriceInput) {
      const v = String(sessionSettingsPriceInput.value || '').trim();
      ev.setExtendedProp('sessionPrice', v === '' ? null : v);
    }
    if (sessionSettingsClientEmailInput) {
      const email = String(sessionSettingsClientEmailInput.value || '').trim();
      ev.setExtendedProp('clientEmail', email || null);
      // Look up client name from suggestions
      if (email) {
        try {
          const clients = await ensureClientSuggestionsLoaded();
          const client = clients.find(c => c.email.toLowerCase() === email.toLowerCase());
          if (client) {
            ev.setExtendedProp('clientFirstName', client.first_name || null);
            ev.setExtendedProp('clientLastName', client.last_name || null);
          } else {
            ev.setExtendedProp('clientFirstName', null);
            ev.setExtendedProp('clientLastName', null);
          }
        } catch (e) {
          console.warn('[MentorCalendar] Could not load client suggestions:', e);
          ev.setExtendedProp('clientFirstName', null);
          ev.setExtendedProp('clientLastName', null);
        }
      } else {
        ev.setExtendedProp('clientFirstName', null);
        ev.setExtendedProp('clientLastName', null);
      }
    }

    markDirty('session');
    recomputeCollisions();
    
    // Track session mutation
    onSessionMutated(ev);
    
    setSessionSettingsApplyEnabled(false);
    closeSessionSettings();
  }

  // --- Schedule session popup helpers ---
  function setScheduleSessionVisible(isVisible) {
    if (!scheduleSessionOverlay) return;
    scheduleSessionOverlay.classList.toggle('is-visible', !!isVisible);
    scheduleSessionOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeScheduleSessionPopup() {
    scheduleSessionEventId = null;
    if (scheduleSessionEmailInput) scheduleSessionEmailInput.value = '';
    if (scheduleSessionEmailSuggestionsEl) {
      scheduleSessionEmailSuggestionsEl.hidden = true;
      scheduleSessionEmailSuggestionsEl.innerHTML = '';
    }
    if (scheduleSessionSendBtn) scheduleSessionSendBtn.disabled = true;
    setScheduleSessionVisible(false);
  }

  function openScheduleSessionPopupForEvent(fcEvent) {
    if (!scheduleSessionOverlay || !fcEvent) return;
    scheduleSessionEventId = fcEvent.id || null;
    setScheduleSessionVisible(true);
    if (scheduleSessionEmailInput) {
      scheduleSessionEmailInput.focus();
      scheduleSessionEmailInput.select?.();
    }
    if (scheduleSessionSendBtn) scheduleSessionSendBtn.disabled = !isValidEmail(scheduleSessionEmailInput?.value || '');

    // Suggestions + validation
    if (scheduleSessionEmailInput && scheduleSessionEmailSuggestionsEl && !scheduleSessionEmailInput.__mentorBound) {
      scheduleSessionEmailInput.__mentorBound = true;
      scheduleSessionEmailInput.addEventListener('input', async () => {
        const raw = String(scheduleSessionEmailInput.value || '');
        const q = raw.toLowerCase().trim();
        if (scheduleSessionSendBtn) scheduleSessionSendBtn.disabled = !isValidEmail(raw);

        if (!q) {
          scheduleSessionEmailSuggestionsEl.hidden = true;
          scheduleSessionEmailSuggestionsEl.innerHTML = '';
          return;
        }

        const all = await ensureClientSuggestionsLoaded();
        const filtered = all.filter(c => (`${c.first_name} ${c.last_name} ${c.email}`.toLowerCase()).includes(q));

        scheduleSessionEmailSuggestionsEl.hidden = filtered.length === 0;
        scheduleSessionEmailSuggestionsEl.innerHTML = filtered.slice(0, 8).map((c) => {
          const name = `${c.first_name} ${c.last_name}`.trim() || c.email;
          return `
            <div class="schedule-session-suggestion-item" data-email="${c.email}">
              <div class="schedule-session-suggestion-name">${name}</div>
              <div class="schedule-session-suggestion-email">${c.email}</div>
            </div>
          `;
        }).join('');

        scheduleSessionEmailSuggestionsEl.querySelectorAll('[data-email]').forEach(el => {
          el.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const email = el.getAttribute('data-email') || '';
            scheduleSessionEmailInput.value = email;
            scheduleSessionEmailSuggestionsEl.hidden = true;
            scheduleSessionEmailSuggestionsEl.innerHTML = '';
            if (scheduleSessionSendBtn) scheduleSessionSendBtn.disabled = !isValidEmail(email);
          });
        });
      });

      document.addEventListener('click', (e) => {
        const target = e.target;
        if (!(target instanceof Element)) return;
        if (target.closest('#scheduleSessionEmailSuggestions')) return;
        if (target.closest('#scheduleSessionEmailInput')) return;
        if (scheduleSessionEmailSuggestionsEl) scheduleSessionEmailSuggestionsEl.hidden = true;
      }, { capture: true });
    }
  }

  function sendScheduleSessionEmail() {
    const email = (scheduleSessionEmailInput?.value || '').trim();
    if (!isValidEmail(email)) {
      if (typeof showNotification === 'function') showNotification('Please enter an email.', 'error');
      else alert('Please enter an email.');
      return;
    }
    const ev = calendar && scheduleSessionEventId ? calendar.getEventById(scheduleSessionEventId) : null;
    if (!ev || !ev.start || !ev.end) {
      if (typeof showNotification === 'function') showNotification('Could not schedule this slot.', 'error');
      closeScheduleSessionPopup();
      return;
    }

    const csrf = getCookie('csrftoken');
    const payload = {
      email,
      start_iso: ev.start.toISOString(),
      end_iso: ev.end.toISOString(),
      availability_slot_id: null,
      recurring_id: null,
      instance_date: null
    };
    try {
      if (ev.extendedProps?.isRecurringInstance && ev.extendedProps?.recurringId && ev.extendedProps?.instanceDate) {
        payload.recurring_id = String(ev.extendedProps.recurringId);
        payload.instance_date = String(ev.extendedProps.instanceDate);
      } else {
        payload.availability_slot_id = String(ev.id || '');
      }
    } catch (e) {}

    (async () => {
      try {
        const res = await fetch(SCHEDULE_SESSION_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrf || '' },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (data && data.success) {
          if (typeof showNotification === 'function') showNotification('Session scheduled and invitation sent.', 'success');
          try { await loadSavedAvailability(); } catch (e) {}
        } else {
          if (typeof showNotification === 'function') showNotification(data?.error || 'Could not schedule session.', 'error');
        }
      } catch (e) {
        if (typeof showNotification === 'function') showNotification('Could not schedule session.', 'error');
      } finally {
        closeScheduleSessionPopup();
      }
    })();
  }

  // --- Switch-to-sessions-mode popup helpers ---
  function setSessionSwitchVisible(isVisible) {
    if (!sessionSwitchOverlay) return;
    sessionSwitchOverlay.classList.toggle('is-visible', !!isVisible);
    sessionSwitchOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeSessionSwitchPopup() {
    sessionSwitchEventId = null;
    sessionSwitchOpenSettingsAfterSwitch = false;
    setSessionSwitchVisible(false);
  }

  function openSessionSwitchPopupForEventId(eventId, openSettingsAfterSwitch) {
    if (!sessionSwitchOverlay) return;
    sessionSwitchEventId = eventId || null;
    sessionSwitchOpenSettingsAfterSwitch = !!openSettingsAfterSwitch;
    setSessionSwitchVisible(true);
  }

  function switchToSessionsMode() {
    const id = sessionSwitchEventId;
    const shouldOpenSettings = !!sessionSwitchOpenSettingsAfterSwitch;
    closeSessionSwitchPopup();
    setMode(false);
    if (shouldOpenSettings && calendar && id) {
      const ev = calendar.getEventById(id);
      if (ev) openSessionSettingsForEvent(ev);
    }
  }

  // Track dates which originally had availability (for deletion support)
  let originalAvailabilityDates = new Set();

  // Distinguish single click vs double click on availability slots (Sessions mode)
  // Single click opens "Schedule session" popup, but we wait briefly to see if it's a double-click.
  let __availabilityClickTimer = null;
  let __availabilityClickEventId = null;

  // Recurring availability rules (source of truth, persisted to mentor_profile.recurring_slots)
  // Map<recurringId, rule>
  // rule: { id, type: 'daily'|'weekly'|'monthly', start_date, start_time, end_time, weekdays?, day_of_month?, skip_dates?, booked_dates?, slot_type }
  let recurringAvailabilityRules = new Map();
  // Track full-series deletions so backend removes them from recurring_slots
  let deletedRecurringRules = new Map(); // Map<recurringId, ruleSnapshot>

  // If the user tries to drag a recurring occurrence in a blocked view (month),
  // we'll blink the whole series to hint it's recurring.
  let lastBlockedRecurringDrag = null; // { recurringId: string, atMs: number }

  function generateClientId(prefix) {
    const rand = Math.random().toString(36).slice(2, 10);
    return `${prefix || 'id'}_${Date.now()}_${rand}`;
  }

  function blinkRecurringSeries(recurringId) {
    if (!root || !recurringId) return;
    const els = root.querySelectorAll(`.fc-event[data-recurring-id="${CSS.escape(recurringId)}"]`);
    els.forEach((el) => {
      el.classList.remove('recurring-blink');
      // restart animation
      // eslint-disable-next-line no-unused-expressions
      void el.offsetWidth;
      el.classList.add('recurring-blink');
      el.addEventListener('animationend', () => el.classList.remove('recurring-blink'), { once: true });
    });
  }

  function getLocalDateKeyFromJsDate(dateObj) {
    try {
      if (window.luxon && window.luxon.DateTime && dateObj instanceof Date) {
        return window.luxon.DateTime.fromJSDate(dateObj).setZone(timezone_variable).toISODate();
      }
    } catch (e) {}
    return dateObj instanceof Date ? dateObj.toISOString().split('T')[0] : '';
  }

  function getLocalTimeHHmmFromJsDate(dateObj) {
    try {
      if (window.luxon && window.luxon.DateTime && dateObj instanceof Date) {
        return window.luxon.DateTime.fromJSDate(dateObj).setZone(timezone_variable).toFormat('HH:mm');
      }
    } catch (e) {}
    return '';
  }

  function weekdayNameFromIsoDate(isoDate) {
    try {
      if (window.luxon && window.luxon.DateTime) {
        const dt = window.luxon.DateTime.fromISO(isoDate, { zone: timezone_variable });
        const names = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];
        // Luxon: 1=Monday..7=Sunday
        return names[Math.max(0, Math.min(6, dt.weekday - 1))];
      }
    } catch (e) {}
    return '';
  }

  function computeAnchorDateForRecurringRule(rule) {
    // Used only for saving weekly/monthly rules (backend derives weekdays/day_of_month from provided date)
    try {
      if (!(window.luxon && window.luxon.DateTime)) return null;
      const now = window.luxon.DateTime.now().setZone(timezone_variable).startOf('day');
      if (!rule || !rule.type) return now.toISODate();
      if (rule.type === 'daily') return now.toISODate();
      if (rule.type === 'weekly') {
        const target = Array.isArray(rule.weekdays) && rule.weekdays.length ? rule.weekdays[0] : null;
        if (!target) return now.toISODate();
        for (let i = 0; i < 14; i++) {
          const d = now.plus({ days: i });
          if (weekdayNameFromIsoDate(d.toISODate()) === target) return d.toISODate();
        }
        return now.toISODate();
      }
      if (rule.type === 'monthly') {
        const dom = Number(rule.day_of_month);
        if (!Number.isFinite(dom) || dom < 1) return now.toISODate();
        // choose current month if possible, else next month
        const candidateMonths = [0, 1];
        for (const addMonths of candidateMonths) {
          const m = now.plus({ months: addMonths });
          const daysInMonth = m.daysInMonth;
          const day = dom > daysInMonth ? daysInMonth : dom;
          const d = m.set({ day });
          if (d >= now) return d.toISODate();
        }
        return now.toISODate();
      }
    } catch (e) {}
    return null;
  }

  function clearRecurringInstanceEvents() {
    if (!calendar) return;
    calendar.getEvents().forEach(ev => {
      if (ev.extendedProps?.isRecurringInstance) ev.remove();
    });
  }

  function clearMonthSummary() {
    try {
      root?.querySelectorAll?.('.mentor-month-summary')?.forEach?.(el => el.remove());
    } catch (e) {}
  }

  function recurringRuleMatchesDate(rule, dateStr) {
    try {
      if (!rule || !rule.type) return false;
      const startDate = String(rule.start_date || '');
      if (startDate && dateStr < startDate) return false;
      const skip = new Set(rule.skip_dates || []);
      const booked = new Set(rule.booked_dates || []);
      if (skip.has(dateStr) || booked.has(dateStr)) return false;

      if (rule.type === 'daily') return true;
      if (rule.type === 'weekly') {
        const wd = weekdayNameFromIsoDate(dateStr);
        return Array.isArray(rule.weekdays) ? rule.weekdays.includes(wd) : false;
      }
      if (rule.type === 'monthly') {
        if (!(window.luxon && window.luxon.DateTime)) return false;
        const dom = Number(rule.day_of_month);
        if (!Number.isFinite(dom) || dom < 1) return false;
        const d = window.luxon.DateTime.fromISO(dateStr, { zone: timezone_variable });
        if (!d.isValid) return false;
        const daysInMonth = d.daysInMonth;
        const targetDay = dom > daysInMonth ? daysInMonth : dom;
        return d.day === targetDay;
      }
    } catch (e) {}
    return false;
  }

  function computeMonthCountsForDate(dateStr) {
    let sessionsCount = 0;
    let availabilityCount = 0;

    // One-time availability + sessions from existing events (reflects unsaved edits).
    try {
      if (calendar) {
        calendar.getEvents().forEach((ev) => {
          const mode = ev?.extendedProps?.slotMode;
          if (!mode || !ev.start) return;
          // Ignore rendered recurring instances (we count rules directly)
          if (ev.extendedProps?.isRecurringInstance) return;
          const d = getLocalDateKeyFromJsDate(ev.start);
          if (d !== dateStr) return;
          if (mode === 'session') sessionsCount += 1;
          else if (mode === 'availability') availabilityCount += 1;
        });
      }
    } catch (e) {}

    // Recurring availability rules (fast match, no rendering)
    try {
      recurringAvailabilityRules.forEach((rule) => {
        if (recurringRuleMatchesDate(rule, dateStr)) availabilityCount += 1;
      });
    } catch (e) {}

    return { sessionsCount, availabilityCount };
  }

  // Determine the single aggregate status for a day based on Mode + Priority
  function computeMonthStatus(dateStr) {
    // 1. Check Collisions (Highest Priority in both modes)
    // We already have collision detection computed globally.
    // However, our global `hasCalendarCollisionsInHorizon` uses *rendered events*.
    // In Month view they are hidden, but they exist in memory (Calendar internals).
    // Better strategy for robustness: iterate events for this day and check .hasCollision prop
    
    let hasCollision = false;
    let hasAvailability = false;
    
    let sessionStatuses = new Set(); // draft, invited, confirmed
    let hasSession = false;

    if (calendar) {
      const modeToCheck = isAvailabilityMode ? 'availability' : 'session';
      const evs = calendar.getEvents();
      
      // Filter for this day
      for (let ev of evs) {
        if (!ev.start) continue;
        const d = getLocalDateKeyFromJsDate(ev.start);
        if (d !== dateStr) continue;

        const m = ev.extendedProps?.slotMode;
        if (!m) continue;
        
        // Only consider events relevant to the CURRENT view mode?
        // User asked: "left side... show sessions or availability based on the selected mode"
        if (m !== modeToCheck) continue;

        // Check collision (computed by recomputeCollisions)
        if (ev.extendedProps?.hasCollision) hasCollision = true;

        if (m === 'availability') {
          hasAvailability = true;
        } else if (m === 'session') {
          hasSession = true;
          const s = normalizeSessionStatus(ev.extendedProps?.status);
          sessionStatuses.add(s);
        }
      }
      
      // Also check recurring availability rules if in Availability mode (they might not be rendered as events in Month view)
      if (isAvailabilityMode && !hasAvailability) {
        recurringAvailabilityRules.forEach(rule => {
           if (recurringRuleMatchesDate(rule, dateStr)) hasAvailability = true;
           // We can't easily check collisions for unrendered recurring slots in month view cheaply without re-running the full collision engine for every cell.
           // However, `computeCalendarCollisionsInHorizon` handles unrendered recurring slots too.
           // Let's rely on the explicit event scan above for collisions (if unrendered, we might miss visual red, but the "Collision" status requires existing overlap).
           // If the user *created* a collision, it typically involves a session which IS an event.
           // For simpler logic: if we just detect the rule, we mark it available.
        });
        
        // To be safe on collisions in Month view for Recurring vs Session (which might be in view):
        // We can check if ANY collision exists for this dateRec
        // But let's stick to the rendered/memory event props for now, improving if needed.
      }
    }

    // Determine Result Color Class AND Count
    let resultClass = null;
    let count = 0;

    if (isAvailabilityMode) {
      // Re-count availability if needed? 
      // We have availabilityCount from helper but helper counts ALL rules, 
      // we need to know if we really have them.
      // Let's just use `computeMonthCountsForDate` for the count, but `computeMonthStatus` for color logic.
      // But we can simplify: just return the object.
      // For now, let's keep it simple: return class. We will get count in render loop.
      if (hasCollision) return 'status-collision';
      if (hasAvailability) return 'status-availability';
      return null;
    } else {
      // Session Mode
      if (hasCollision) return 'status-collision';
      if (!hasSession) return null;
      
      // Priority order: refunded > completed > confirmed > invited > expired > draft
      if (sessionStatuses.has('refunded')) return 'status-refunded';
      if (sessionStatuses.has('completed')) return 'status-completed';
      if (sessionStatuses.has('confirmed')) return 'status-confirmed';
      if (sessionStatuses.has('invited')) return 'status-invited';
      if (sessionStatuses.has('expired')) return 'status-expired';
      if (sessionStatuses.has('draft')) return 'status-draft';
      return 'status-draft';
    }
  }

  function renderMonthSummary() {
    if (!calendar || !root) return;
    const viewType = calendar.view?.type;
    if (viewType !== 'dayGridMonth') {
      try {
        root.querySelectorAll('.mentor-month-square').forEach(el => el.remove());
      } catch(e) {}
      return;
    }
    
    // Cleanup old squares
    root.querySelectorAll('.mentor-month-square').forEach(el => el.remove());

    clearRecurringInstanceEvents(); // standard cleanup

    const dayEls = root.querySelectorAll('.fc-daygrid-day[data-date]');
    dayEls.forEach((dayEl) => {
      const dateStr = dayEl.getAttribute('data-date') || '';
      if (!dateStr) return;
      
      const statusClass = computeMonthStatus(dateStr);
      if (!statusClass) return; // Show nothing if no relevant events

      // Get count
      const counts = computeMonthCountsForDate(dateStr);
      const count = isAvailabilityMode ? counts.availabilityCount : counts.sessionsCount;

      const sq = document.createElement('div');
      sq.className = `mentor-month-square ${statusClass}`;
      sq.textContent = count > 99 ? '99+' : count;
      sq.setAttribute('data-date', dateStr);
      sq.setAttribute('title', `${count} ${isAvailabilityMode ? 'slots' : 'sessions'}. Double-click cell to view.`);

      const frame = dayEl.querySelector('.fc-daygrid-day-frame') || dayEl;
      frame.appendChild(sq);
    });
  }

  function renderRecurringInstancesForCurrentView() {
    if (!calendar) return;
    if (!(window.luxon && window.luxon.DateTime)) return;
    if (calendar.view?.type === 'dayGridMonth') return; // Month view uses summary chips instead
    clearRecurringInstanceEvents();

    const view = calendar.view;
    const start = view?.activeStart;
    const end = view?.activeEnd;
    if (!(start instanceof Date) || !(end instanceof Date)) return;

    const startDay = window.luxon.DateTime.fromJSDate(start).setZone(timezone_variable).startOf('day');
    const endDay = window.luxon.DateTime.fromJSDate(end).setZone(timezone_variable).startOf('day');
    const days = Math.max(0, Math.round(endDay.diff(startDay, 'days').days));

    recurringAvailabilityRules.forEach((rule) => {
      if (!rule || !rule.id || !rule.type) return;
      const skip = new Set(rule.skip_dates || []);
      const booked = new Set(rule.booked_dates || []);
      const startDate = String(rule.start_date || '');

      for (let i = 0; i < days; i++) {
        const d = startDay.plus({ days: i });
        const dateStr = d.toISODate();
        if (startDate && dateStr < startDate) continue;
        if (skip.has(dateStr) || booked.has(dateStr)) continue;

        let matches = false;
        if (rule.type === 'daily') {
          matches = true;
        } else if (rule.type === 'weekly') {
          const wd = weekdayNameFromIsoDate(dateStr);
          matches = Array.isArray(rule.weekdays) ? rule.weekdays.includes(wd) : false;
        } else if (rule.type === 'monthly') {
          const dom = Number(rule.day_of_month);
          if (Number.isFinite(dom) && dom > 0) {
            // Match exact day, or if dom > daysInMonth, match last day (backend behavior)
            const daysInMonth = d.daysInMonth;
            const targetDay = dom > daysInMonth ? daysInMonth : dom;
            matches = d.day === targetDay;
          }
        }
        if (!matches) continue;

        const startDt = window.luxon.DateTime.fromISO(`${dateStr}T${rule.start_time}`, { zone: timezone_variable });
        const endDt = window.luxon.DateTime.fromISO(`${dateStr}T${rule.end_time}`, { zone: timezone_variable });
        if (!startDt.isValid || !endDt.isValid) continue;
        if (endDt <= startDt) continue;

        const instanceId = `${rule.id}__${dateStr}`;
        calendar.addEvent({
          id: instanceId,
          start: startDt.toJSDate(),
          end: endDt.toJSDate(),
          allDay: false,
          backgroundColor: '#3b82f6',
          borderColor: '#2563eb',
          textColor: '#ffffff',
          classNames: ['event-type-availability', 'event-type-availability-recurring'],
          editable: true,
          extendedProps: {
            slotMode: 'availability',
            type: 'availability_slot',
            isRecurringInstance: true,
            recurringId: rule.id,
            instanceDate: dateStr,
            recurrence: rule.type
          }
        });
      }
    });

    // Recurring instances are real events. Some FullCalendar builds mount event DOM asynchronously,
    // so schedule collision recompute right after paint to ensure red styling applies immediately.
    try {
      window.requestAnimationFrame(() => recomputeCollisions());
    } catch (e) {
      setTimeout(() => recomputeCollisions(), 0);
    }
  }

  const GET_AVAILABILITY_URL = "{% url 'general:dashboard_mentor:get_availability' %}";
  const SAVE_AVAILABILITY_URL = "{% url 'general:dashboard_mentor:save_availability' %}";
  const CLIENT_SUGGESTIONS_URL = "{% url 'general:dashboard_mentor:client_suggestions' %}";
  const INVITE_CLIENT_URL = "{% url 'general:dashboard_mentor:invite_client' %}";
  const INVITE_SESSION_URL = "{% url 'general:dashboard_mentor:invite_session' %}";
  const SCHEDULE_SESSION_URL = "{% url 'general:dashboard_mentor:schedule_session' %}";
  const REMIND_SESSION_URL = "{% url 'general:dashboard_mentor:remind_session' %}";
  const REFUND_SESSION_URL = "{% url 'general:dashboard_mentor:refund_session' %}";
  const SESSION_DETAIL_URL_TEMPLATE = "{% url 'general:dashboard_mentor:session_detail' 0 %}";

  // Save button enablement:
  // - availability changes: persisted by Save
  // - session changes: persisted by Save
  let dirtyAvailability = false;
  let dirtySession = false;
  let deletedSessionDbIds = new Set(); // Session ids deleted client-side, persisted on Save

  function updateSaveButtonState() {
    if (!saveBtn) return;
    const isDirty = dirtyAvailability || dirtySession;
    saveBtn.disabled = !isDirty;
  }

  function setSaveButtonLoading(isLoading) {
    if (!saveBtn) return;
    const next = !!isLoading;
    saveBtn.classList.toggle('is-loading', next);
    saveBtn.setAttribute('aria-busy', next ? 'true' : 'false');
    if (next) saveBtn.disabled = true;
  }

  function markDirty(slotMode) {
    if (slotMode === 'availability') dirtyAvailability = true;
    else if (slotMode === 'session') dirtySession = true;
    else dirtyAvailability = true; // conservative fallback
    updateSaveButtonState();
  }

  function clearDirtyAvailability() {
    dirtyAvailability = false;
    updateSaveButtonState();
  }

  function clearDirtySession() {
    dirtySession = false;
    updateSaveButtonState();
  }

  function normalizeSessionStatus(value) {
    const s = String(value || 'draft').toLowerCase().trim();
    if (s === 'draft' || s === 'invited' || s === 'confirmed' || s === 'cancelled' || s === 'expired' || s === 'completed' || s === 'refunded') return s;
    return 'draft';
  }

  function sessionColorsForStatus(status) {
    const s = normalizeSessionStatus(status);
    if (s === 'draft') return { bg: '#f97316', border: '#ea580c', text: '#ffffff' };     // orange
    if (s === 'invited') return { bg: '#fbbf24', border: '#f59e0b', text: '#ffffff' };   // yellow
    if (s === 'confirmed') return { bg: '#22c55e', border: '#16a34a', text: '#ffffff' }; // green
    if (s === 'expired') return { bg: '#94a3b8', border: '#64748b', text: '#ffffff' };   // slate/grey
    if (s === 'completed') return { bg: '#15803d', border: '#166534', text: '#ffffff' }; // dark green
    if (s === 'refunded') return { bg: '#6366f1', border: '#4f46e5', text: '#ffffff' };   // indigo/purple
    // cancelled
    return { bg: '#ffffff', border: '#e2e8f0', text: '#0f172a' };
  }

  function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    return null;
  }

  function getLocalDateKeyFromUtcIso(isoUtc) {
    try {
      if (window.luxon && window.luxon.DateTime) {
        return window.luxon.DateTime.fromISO(isoUtc, { zone: 'utc' })
          .setZone(timezone_variable)
          .toISODate();
      }
    } catch (e) {}
    // Fallback: UTC date
    return String(isoUtc).split('T')[0];
  }

  async function loadSavedAvailability() {
    if (!calendar) return;
    try {
      const res = await fetch(GET_AVAILABILITY_URL, { headers: { 'Accept': 'application/json' } });
      const data = await res.json();
      if (!data.success) {
        console.warn('[MentorCalendar] get_availability failed:', data);
        return;
      }

      // Rebuild from DB snapshot (availability + sessions)
      calendar.getEvents().forEach(ev => {
        const m = ev.extendedProps?.slotMode;
        if (m === 'availability' || m === 'session') ev.remove();
      });
      deletedSessionDbIds = new Set();

      originalAvailabilityDates = new Set();
      recurringAvailabilityRules = new Map();
      deletedRecurringRules = new Map();
      // Ensure recurrence UI selections reflect persisted recurring rules
      window.MentorCalendarRecurrenceSelections = window.MentorCalendarRecurrenceSelections || {};

      const slots = Array.isArray(data.one_time_slots) ? data.one_time_slots : [];
      slots.forEach(slot => {
        // Ignore non-availability for now
        if (slot.type && slot.type !== 'availability_slot') return;

        if (!slot.start || !slot.end) return;
        const startIso = slot.start;
        const endIso = slot.end;

        // Track local date keys for deletion support
        originalAvailabilityDates.add(getLocalDateKeyFromUtcIso(startIso));

        calendar.addEvent({
          id: slot.id || ('availability_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8)),
          start: startIso,
          end: endIso,
          allDay: false,
          backgroundColor: '#3b82f6',
          borderColor: '#2563eb',
          textColor: '#ffffff',
          classNames: ['event-type-availability'], // Added class
          // Allow drag start in Sessions mode so we can show the switch popup on drop.
          // The move will be reverted in eventDrop if not in Availability mode.
          editable: true,
          extendedProps: { slotMode: 'availability', type: 'availability_slot' }
        });
      });

      // Load recurring rules (raw JSON) and render occurrences for the current view
      const recurring = Array.isArray(data.recurring_slots) ? data.recurring_slots : [];
      recurring.forEach((rule) => {
        const id = String(rule?.id || '');
        const type = String(rule?.type || '');
        if (!id || !type) return;
        const start_time = String(rule?.start_time || '');
        const end_time = String(rule?.end_time || '');
        if (!start_time || !end_time) return;

        const start_date = String(rule?.start_date || '') || (rule?.created_at ? String(rule.created_at).split('T')[0] : '') || getLocalDateKeyFromUtcIso(new Date().toISOString());

        const normalized = {
          id,
          type, // daily|weekly|monthly
          slot_type: rule?.slot_type || 'availability_slot',
          start_date,
          start_time,
          end_time,
          weekdays: Array.isArray(rule?.weekdays) ? rule.weekdays : [],
          day_of_month: rule?.day_of_month ?? null,
          skip_dates: Array.isArray(rule?.skip_dates) ? rule.skip_dates : [],
          booked_dates: Array.isArray(rule?.booked_dates) ? rule.booked_dates : [],
          created_at: rule?.created_at || null
        };
        normalized.anchor_date = start_date;
        recurringAvailabilityRules.set(id, normalized);
        window.MentorCalendarRecurrenceSelections[id] = type;
      });
      renderRecurringInstancesForCurrentView();

      // Load Sessions from DB and render as session slots (status-colored)
      const sessions = Array.isArray(data.sessions) ? data.sessions : [];
      
      // CRITICAL: Clear originalSessionsById BEFORE repopulating to remove deleted sessions
      // If we don't clear it, deleted sessions will remain in the map and get recreated on save
      originalSessionsById.clear();
      
      // Always repopulate originalSessionsById from fetched sessions when data is refetched
      // This ensures that when sessions are updated (e.g., status changes from draft to invited),
      // the original data reflects the current state from the database
      sessions.forEach((s) => {
        if (!s || !s.id) return;
        // Create a deep copy of the session data for originalSessionsById
        const sessionSnapshot = {
          id: s.id,
          start: s.start || null,
          end: s.end || null,
          status: normalizeSessionStatus(s.status || 'draft'),
          session_price: s.session_price || null,
          client_email: s.client_email || null,
          client_first_name: s.client_first_name || null,
          client_last_name: s.client_last_name || null,
          expires_at: s.expires_at || null,
          session_type: s.session_type || 'individual',
          invitation_sent: !!s.invitation_sent,
          can_remind: !!s.can_remind,
          last_invite_sent_at: s.last_invite_sent_at || null
        };
        originalSessionsById.set(s.id, sessionSnapshot);
      });
      
      // Clear changedSessionsById after successful load (repopulate original, clear changes)
      changedSessionsById.clear();
      
      sessions.forEach((s) => {
        if (!s || !s.id || !s.start || !s.end) return;
        const status = normalizeSessionStatus(s.status || 'draft');
        // Don't display cancelled sessions in the calendar
        if (status === 'cancelled') return;
        const colors = sessionColorsForStatus(status);
        calendar.addEvent({
          id: `session_${s.id}`,
          start: s.start,
          end: s.end,
          allDay: false,
          backgroundColor: colors.bg,
          borderColor: colors.border,
          textColor: colors.text,
          classNames: ['event-type-session'],
          editable: true,
          extendedProps: {
            slotMode: 'session',
            type: 'session',
            status: status,
            sessionDbId: s.id,
            sessionPrice: s.session_price || null,
            clientEmail: s.client_email || null,
            clientFirstName: s.client_first_name || null,
            clientLastName: s.client_last_name || null,
            expiresAt: s.expires_at || null,
            sessionType: s.session_type || 'individual',
            invitationSent: !!s.invitation_sent,
            canRemind: !!s.can_remind,
            lastInviteSentAt: s.last_invite_sent_at || null
          }
        });
      });

      console.log('[MentorCalendar] loaded availability slots:', slots.length);
      recomputeCollisions();
      // Loaded state matches DB for availability
      clearDirtyAvailability();
      clearDirtySession();
    } catch (e) {
      console.error('[MentorCalendar] error loading availability:', e);
    }
  }

  // --- Collision detection (availability + sessions) ---
  // IMPORTANT:
  // We must block saves when collisions exist in the CURRENTLY VISIBLE range (user can see them),
  // and also for a forward-looking booking horizon to keep the persisted "collisions" flag accurate.
  const COLLISION_HORIZON_DAYS = 365;
  let openedFromSessionLengthChange = false;

  window.setOpenedFromSessionLengthChange = function(value) {
    openedFromSessionLengthChange = !!value;
  };
  window.getOpenedFromSessionLengthChange = function() {
    return !!openedFromSessionLengthChange;
  };

  function computeCalendarCollisionsInHorizon() {
    if (!(window.luxon && window.luxon.DateTime) || !calendar) return [];

    const DateTime = window.luxon.DateTime;
    const todayLocal = DateTime.now().setZone(timezone_variable).startOf('day');
    const bookingEndLocal = todayLocal.plus({ days: COLLISION_HORIZON_DAYS }).startOf('day'); // exclusive

    // Visible range (what the user is looking at). This may be far in the future; we must include it.
    const viewStartLocal = DateTime.fromJSDate(calendar.view?.activeStart || calendar.getDate()).setZone(timezone_variable).startOf('day');
    const viewEndLocal = DateTime.fromJSDate(calendar.view?.activeEnd || calendar.getDate()).setZone(timezone_variable).startOf('day'); // exclusive

    // Union-of-ranges window:
    // - Visible calendar range (prevents "I can see collisions but can still save")
    // - Booking horizon from today (keeps collision flag meaningful)
    const ranges = [
      { start: viewStartLocal, end: viewEndLocal },
      { start: todayLocal, end: bookingEndLocal }
    ].filter((r) => r && r.start && r.end && r.end > r.start);

    const inAnyRange = (dayStart) => {
      return ranges.some((r) => dayStart >= r.start && dayStart < r.end);
    };

    const occurrencesByDate = new Map(); // dateStr -> occurrence[]
    const ensureBucket = (dateStr) => {
      if (!occurrencesByDate.has(dateStr)) occurrencesByDate.set(dateStr, []);
      return occurrencesByDate.get(dateStr);
    };

    // One-time availability events already in the calendar (exclude rendered recurring instances)
    calendar.getEvents().forEach((ev) => {
      if (ev.extendedProps?.slotMode !== 'availability') return;
      if (ev.extendedProps?.isRecurringInstance) return;
      if (!ev.start || !ev.end) return;

      const startDt = DateTime.fromJSDate(ev.start).setZone(timezone_variable);
      const endDt = DateTime.fromJSDate(ev.end).setZone(timezone_variable);
      if (!startDt.isValid || !endDt.isValid || endDt <= startDt) return;

      const day = startDt.startOf('day');
      if (!inAnyRange(day)) return;

      const dateStr = day.toISODate();
      ensureBucket(dateStr).push({
        kind: 'one_time',
        id: String(ev.id || ''),
        startDt,
        endDt
      });
    });

    // Session events (one-time) already in the calendar
    // Deduplicate by event ID to prevent same session from being added multiple times
    const seenSessionIds = new Set();
    calendar.getEvents().forEach((ev) => {
      if (ev.extendedProps?.slotMode !== 'session') return;
      if (!ev.start || !ev.end) return;

      const sessionId = String(ev.id || '');
      // Skip if we've already processed this session ID (prevents duplicates)
      if (seenSessionIds.has(sessionId)) return;
      seenSessionIds.add(sessionId);

      const startDt = DateTime.fromJSDate(ev.start).setZone(timezone_variable);
      const endDt = DateTime.fromJSDate(ev.end).setZone(timezone_variable);
      if (!startDt.isValid || !endDt.isValid || endDt <= startDt) return;

      const day = startDt.startOf('day');
      if (!inAnyRange(day)) return;
      const dateStr = day.toISODate();
      ensureBucket(dateStr).push({
        kind: 'session',
        id: sessionId,
        startDt,
        endDt
      });
    });

    // Recurring rules expanded in-horizon (do not render)
    const matchesRuleOnDate = (ruleObj, dateStr, dayDt) => {
      if (!ruleObj || !ruleObj.type) return false;
      if (ruleObj.start_date && dateStr < ruleObj.start_date) return false;
      if (Array.isArray(ruleObj.skip_dates) && ruleObj.skip_dates.includes(dateStr)) return false;

      if (ruleObj.type === 'daily') return true;
      if (ruleObj.type === 'weekly') {
        const wd = weekdayNameFromIsoDate(dateStr);
        return Array.isArray(ruleObj.weekdays) ? ruleObj.weekdays.includes(wd) : false;
      }
      if (ruleObj.type === 'monthly') {
        const dom = Number(ruleObj.day_of_month);
        if (!Number.isFinite(dom) || dom < 1) return false;
        const daysInMonth = dayDt.daysInMonth;
        const targetDay = dom > daysInMonth ? daysInMonth : dom;
        return dayDt.day === targetDay;
      }
      return false;
    };

    const emittedRecOcc = new Set(); // avoid duplicates across overlapping ranges (recurringId|dateStr)

    recurringAvailabilityRules.forEach((rule) => {
      if (!rule || !rule.id || !rule.type) return;
      const startTime = String(rule.start_time || '');
      const endTime = String(rule.end_time || '');
      if (!startTime || !endTime) return;

      // Expand per range (keeps runtime bounded even if user browses far future)
      ranges.forEach((rng) => {
        let cursor = rng.start;
        if (rule.start_date) {
          const rs = DateTime.fromISO(String(rule.start_date), { zone: timezone_variable }).startOf('day');
          if (rs.isValid && cursor < rs) cursor = rs;
        }

        while (cursor < rng.end) {
          const dateStr = cursor.toISODate();
          if (matchesRuleOnDate(rule, dateStr, cursor)) {
            const startDt = DateTime.fromISO(`${dateStr}T${startTime}`, { zone: timezone_variable });
            const endDt = DateTime.fromISO(`${dateStr}T${endTime}`, { zone: timezone_variable });
            if (startDt.isValid && endDt.isValid && endDt > startDt) {
              const k = `${String(rule.id)}|${dateStr}`;
              if (!emittedRecOcc.has(k)) {
                emittedRecOcc.add(k);
                ensureBucket(dateStr).push({
                  kind: 'rec_occ',
                  recurringId: String(rule.id),
                  instanceDate: dateStr,
                  startDt,
                  endDt
                });
              }
            }
          }
          cursor = cursor.plus({ days: 1 });
        }
      });
    });

    const overlaps = (a, b) => a.startDt < b.endDt && b.startDt < a.endDt;

    const oneOne = [];
    const oneRec = [];
    const sessSessMap = new Map(); // key -> collision (deduplicate session-session collisions)
    const sessOne = [];
    const sessRec = [];
    const recRecMap = new Map(); // pairKey -> collision

    occurrencesByDate.forEach((list, dateStr) => {
      if (!Array.isArray(list) || list.length < 2) return;
      
      // Deduplicate sessions within this date bucket by ID (in case same session appears multiple times)
      const seenInBucket = new Set();
      const deduplicatedList = list.filter((item) => {
        if (item.kind === 'session') {
          if (seenInBucket.has(item.id)) return false;
          seenInBucket.add(item.id);
        }
        return true;
      });
      
      if (deduplicatedList.length < 2) return;
      const sorted = deduplicatedList.slice().sort((x, y) => x.startDt.toMillis() - y.startDt.toMillis());

      for (let i = 0; i < sorted.length; i++) {
        for (let j = i + 1; j < sorted.length; j++) {
          const a = sorted[i];
          const b = sorted[j];
          if (!overlaps(a, b)) continue;

          // session vs session
          if (a.kind === 'session' && b.kind === 'session') {
            const ids = [a.id, b.id].sort();
            const key = `sess_sess|${dateStr}|${ids[0]}|${ids[1]}`;
            // Deduplicate: only add if we haven't seen this collision pair before
            if (!sessSessMap.has(key)) {
              sessSessMap.set(key, {
                type: 'sess_sess',
                deletableAvailability: false,
                key: key,
                slot1: { id: a.id, start: a.startDt.toISO(), end: a.endDt.toISO(), kind: 'session' },
                slot2: { id: b.id, start: b.startDt.toISO(), end: b.endDt.toISO(), kind: 'session' }
              });
            }
            continue;
          }

          // session vs availability (one-time or recurring occurrence)
          if ((a.kind === 'session' && (b.kind === 'one_time' || b.kind === 'rec_occ')) || (b.kind === 'session' && (a.kind === 'one_time' || a.kind === 'rec_occ'))) {
            const sess = (a.kind === 'session') ? a : b;
            const avail = (a.kind === 'session') ? b : a;
            if (avail.kind === 'one_time') {
              sessOne.push({
                type: 'sess_one',
                deletableAvailability: true,
                key: `sess_one|${dateStr}|${sess.id}|${avail.id}`,
                slot1: { id: sess.id, start: sess.startDt.toISO(), end: sess.endDt.toISO(), kind: 'session' },
                slot2: { id: avail.id, start: avail.startDt.toISO(), end: avail.endDt.toISO(), kind: 'one_time' }
              });
            } else if (avail.kind === 'rec_occ') {
              sessRec.push({
                type: 'sess_rec',
                deletableAvailability: true,
                key: `sess_rec|${dateStr}|${sess.id}|${avail.recurringId}`,
                slot1: { id: sess.id, start: sess.startDt.toISO(), end: sess.endDt.toISO(), kind: 'session' },
                slot2: { id: String(avail.recurringId), start: avail.startDt.toISO(), end: avail.endDt.toISO(), kind: 'rec_occ', recurringId: String(avail.recurringId), instanceDate: avail.instanceDate }
              });
            }
            continue;
          }

          // one-time vs one-time
          if (a.kind === 'one_time' && b.kind === 'one_time') {
            const ids = [a.id, b.id].sort();
            oneOne.push({
              type: 'one_one',
              deletableAvailability: true,
              key: `one_one|${dateStr}|${ids[0]}|${ids[1]}`,
              slot1: { id: a.id, start: a.startDt.toISO(), end: a.endDt.toISO(), kind: 'one_time' },
              slot2: { id: b.id, start: b.startDt.toISO(), end: b.endDt.toISO(), kind: 'one_time' }
            });
            continue;
          }

          // one-time vs recurring occurrence
          if ((a.kind === 'one_time' && b.kind === 'rec_occ') || (a.kind === 'rec_occ' && b.kind === 'one_time')) {
            const one = (a.kind === 'one_time') ? a : b;
            const rec = (a.kind === 'rec_occ') ? a : b;
            oneRec.push({
              type: 'one_rec',
              deletableAvailability: true,
              key: `one_rec|${dateStr}|${one.id}|${rec.recurringId}`,
              slot1: { id: one.id, start: one.startDt.toISO(), end: one.endDt.toISO(), kind: 'one_time' },
              slot2: { id: rec.recurringId, start: rec.startDt.toISO(), end: rec.endDt.toISO(), kind: 'rec_occ', recurringId: rec.recurringId, instanceDate: rec.instanceDate }
            });
            continue;
          }

          // recurring occurrence vs recurring occurrence (aggregate)
          if (a.kind === 'rec_occ' && b.kind === 'rec_occ') {
            const ridA = String(a.recurringId);
            const ridB = String(b.recurringId);
            if (!ridA || !ridB || ridA === ridB) continue;
            const pair = [ridA, ridB].sort();
            const pairKey = `rec_rec|${pair[0]}|${pair[1]}`;
            const existing = recRecMap.get(pairKey);
            const candidateStart = (a.startDt < b.startDt ? a.startDt : b.startDt);
            if (!existing || candidateStart.toMillis() < Date.parse(existing.slot1.start || existing.slot2.start || '')) {
              recRecMap.set(pairKey, {
                type: 'rec_rec',
                deletableAvailability: true,
                key: pairKey,
                slot1: { id: pair[0], start: a.startDt.toISO(), end: a.endDt.toISO(), kind: 'rec_occ', recurringId: pair[0], instanceDate: dateStr },
                slot2: { id: pair[1], start: b.startDt.toISO(), end: b.endDt.toISO(), kind: 'rec_occ', recurringId: pair[1], instanceDate: dateStr }
              });
            }
          }
        }
      }
    });

    const recRec = Array.from(recRecMap.values());
    const sessSess = Array.from(sessSessMap.values());
    const all = oneOne.concat(oneRec, recRec, sessOne, sessRec, sessSess);
    all.sort((x, y) => {
      const xs = Date.parse(x?.slot1?.start || '') || 0;
      const ys = Date.parse(y?.slot1?.start || '') || 0;
      return xs - ys;
    });
    return all;
  }

  function hasCalendarCollisionsInHorizon() {
    return computeCalendarCollisionsInHorizon().length > 0;
  }

  window.getCalendarCollisions = function() {
    return computeCalendarCollisionsInHorizon();
  };

  window.navigateToCollisionInCalendarByCollision = function(collision) {
    if (!calendar || !(window.luxon && window.luxon.DateTime)) return;
    try {
      // Prefer Sessions mode if any collision involves a session
      const involvesSession = (collision?.slot1?.kind === 'session') || (collision?.slot2?.kind === 'session');
      setMode(!involvesSession);
      const startIso = collision?.slot1?.start || collision?.slot2?.start;
      if (!startIso) return;
      const dt = window.luxon.DateTime.fromISO(String(startIso)).setZone(timezone_variable);
      if (!dt.isValid) return;

      calendar.changeView('timeGridDay');
      calendar.gotoDate(dt.toJSDate());
      setTimeout(() => {
        try {
          calendar.scrollToTime(dt.toFormat('HH:mm:ss'));
        } catch (e) {}
        // Blink involved series to make recurrence obvious
        if (collision?.type === 'rec_rec') {
          if (collision?.slot1?.id) blinkRecurringSeries(String(collision.slot1.id));
          if (collision?.slot2?.id) blinkRecurringSeries(String(collision.slot2.id));
        } else if (collision?.type === 'one_rec') {
          const rid = collision?.slot2?.recurringId || collision?.slot2?.id;
          if (rid) blinkRecurringSeries(String(rid));
        }
      }, 150);
    } catch (e) {
      console.warn('[MentorCalendar] navigateToCollisionInCalendarByCollision failed:', e);
    }
  };

  window.deleteAllCollidingAvailabilitySlots = async function(collisionList, opts) {
    if (!calendar) return;
    const collisions = Array.isArray(collisionList) ? collisionList : [];
    const oneTimeIdsToDelete = new Set();
    const recurringIdsToDelete = new Set();

    collisions.forEach((c) => {
      const type = c?.type;
      const a = c?.slot1 || {};
      const b = c?.slot2 || {};

      if (type === 'one_one') {
        if (a.id) oneTimeIdsToDelete.add(String(a.id));
        if (b.id) oneTimeIdsToDelete.add(String(b.id));
      } else if (type === 'one_rec') {
        // delete only the one-time slot
        if (a.kind === 'one_time' && a.id) oneTimeIdsToDelete.add(String(a.id));
        else if (b.kind === 'one_time' && b.id) oneTimeIdsToDelete.add(String(b.id));
      } else if (type === 'rec_rec') {
        if (a.id) recurringIdsToDelete.add(String(a.id));
        if (b.id) recurringIdsToDelete.add(String(b.id));
      } else if (type === 'sess_one') {
        // delete the availability one-time slot (never delete sessions)
        if (a.kind === 'one_time' && a.id) oneTimeIdsToDelete.add(String(a.id));
        if (b.kind === 'one_time' && b.id) oneTimeIdsToDelete.add(String(b.id));
      } else if (type === 'sess_rec') {
        // delete the availability recurring series (never delete sessions)
        const rid = a.kind === 'rec_occ' ? (a.recurringId || a.id) : (b.recurringId || b.id);
        if (rid) recurringIdsToDelete.add(String(rid));
      } else if (type === 'sess_sess') {
        // no-op (sessions must be resolved manually)
      }
    });

    // Delete one-time slots (events)
    oneTimeIdsToDelete.forEach((id) => {
      const ev = calendar.getEventById(id);
      if (ev) ev.remove();
      try {
        if (window.MentorCalendarRecurrenceSelections) delete window.MentorCalendarRecurrenceSelections[id];
      } catch (e) {}
    });

    // Delete recurring series completely (both rules, plus rendered instances)
    recurringIdsToDelete.forEach((rid) => {
      const existing = recurringAvailabilityRules.get(rid);
      if (existing) deletedRecurringRules.set(rid, existing);
      recurringAvailabilityRules.delete(rid);
      try {
        if (window.MentorCalendarRecurrenceSelections) delete window.MentorCalendarRecurrenceSelections[rid];
      } catch (e) {}
      // Remove any rendered instances in current view
      calendar.getEvents().forEach((ev) => {
        if (ev.extendedProps?.recurringId === rid || String(ev.id || '').startsWith(rid + '__')) {
          ev.remove();
        }
      });
    });

    if (oneTimeIdsToDelete.size > 0 || recurringIdsToDelete.size > 0) {
      markDirty('availability');
      renderRecurringInstancesForCurrentView();
      recomputeCollisions();
    }
  };

  async function saveAvailabilityToBackend() {
    if (!calendar) return;

    // Block save if there are any collisions (availability and/or sessions) in horizon
    const collisions = computeCalendarCollisionsInHorizon();
    if (collisions.length > 0) {
      const canOpenPopup = (typeof window.openCollisionResolutionPopup === 'function');
      if (canOpenPopup) {
        window.openCollisionResolutionPopup(false);
        // Don't show a toast hereit's noisy and can linger even after user resolves collisions via the popup.
      } else if (typeof showNotification === 'function') {
        showNotification('Please resolve collisions before saving.', 'warning');
      }
      return;
    }

    setSaveButtonLoading(true);

    try {
      const availabilityEvents = calendar.getEvents().filter(ev =>
        ev.extendedProps?.slotMode === 'availability' && !ev.extendedProps?.isRecurringInstance
      );

      // Get visible session events from calendar
      const visibleSessionEvents = calendar.getEvents().filter(ev =>
        ev.extendedProps?.slotMode === 'session'
      );

      // Also include ALL sessions from originalSessionsById to ensure past sessions are preserved
      // This ensures that even if a session is not visible in the current view, it's still sent to the backend
      const visibleSessionIds = new Set(visibleSessionEvents.map(ev => ev.extendedProps?.sessionDbId).filter(Boolean));
      const allSessionEvents = [...visibleSessionEvents];

      // Add sessions from originalSessionsById that aren't currently visible
      // This is critical: we must preserve ALL sessions, not just visible ones
      // BUT: Exclude sessions that are marked for deletion
      originalSessionsById.forEach((sessionData, sessionId) => {
        // Skip if this session is marked for deletion
        if (deletedSessionDbIds && deletedSessionDbIds.has(String(sessionId))) {
          return;
        }
        if (!visibleSessionIds.has(sessionId) && sessionData.start && sessionData.end) {
          // Create a calendar event object for this session so it can be included in the payload
          // This ensures past sessions are preserved even if not visible
          allSessionEvents.push({
            id: `session_${sessionId}`,
            start: new Date(sessionData.start),
            end: new Date(sessionData.end),
            extendedProps: {
              slotMode: 'session',
              sessionDbId: sessionId,
              status: normalizeSessionStatus(sessionData.status || 'draft'),
              sessionPrice: sessionData.session_price || null,
              clientEmail: sessionData.client_email || null,
              clientFirstName: sessionData.client_first_name || null,
              clientLastName: sessionData.client_last_name || null,
              sessionType: sessionData.session_type || 'individual'
            }
          });
        }
      });

      const sessionEvents = allSessionEvents;

      const oneTimePayload = availabilityEvents.map(ev => {
        const startIso = ev.start ? ev.start.toISOString() : null;
        const endIso = ev.end ? ev.end.toISOString() : null;
        if (!startIso || !endIso) return null;

        const dateKey = getLocalDateKeyFromUtcIso(startIso);
        const length = Math.max(0, Math.round((Date.parse(endIso) - Date.parse(startIso)) / 60000));

        const item = {
          id: ev.id,
          type: 'availability_slot',
          date: dateKey,
          start_iso: startIso,
          end_iso: endIso,
          length: length
        };

        // If this event is a conversion from recurring -> one-time, include recurring_slot_id
        if (ev.extendedProps?.recurringSlotId) {
          item.recurring_slot_id = ev.extendedProps.recurringSlotId;
        }
        return item;
      }).filter(Boolean);

      // Recurring rules payload (one item per rule)
      const recurringPayload = Array.from(recurringAvailabilityRules.values()).map((rule) => {
        if (!rule || !rule.id || !rule.type) return null;
        const startDate = rule.start_date || rule.anchor_date || computeAnchorDateForRecurringRule(rule) || getLocalDateKeyFromUtcIso(new Date().toISOString());
        return {
          // Backend uses recurring_slot_id as the source-of-truth ID
          recurring_slot_id: rule.id,
          is_recurring: true,
          recurrence_rule: rule.type, // daily|weekly|monthly
          slot_type: rule.slot_type || 'availability_slot',
          date: startDate,
          start_date: startDate,
          start: rule.start_time,
          end: rule.end_time,
          skip_dates: Array.isArray(rule.skip_dates) ? rule.skip_dates : [],
          booked_dates: Array.isArray(rule.booked_dates) ? rule.booked_dates : []
        };
      }).filter(Boolean);

      // Deleted recurring series (delete_all): backend will remove by id
      const deleteSeriesPayload = Array.from(deletedRecurringRules.values()).map((rule) => {
        if (!rule || !rule.id) return null;
        const startDate = rule.start_date || getLocalDateKeyFromUtcIso(new Date().toISOString());
        return {
          recurring_slot_id: rule.id,
          is_recurring: true,
          recurrence_rule: rule.type || 'weekly',
          delete_all: true,
          date: startDate,
          start_date: startDate,
          start: rule.start_time || '09:00',
          end: rule.end_time || '10:00'
        };
      }).filter(Boolean);

      const availabilityPayload = oneTimePayload.concat(recurringPayload, deleteSeriesPayload);

      const sessionsPayload = sessionEvents.map(ev => {
        const startIso = ev.start ? ev.start.toISOString() : null;
        const endIso = ev.end ? ev.end.toISOString() : null;
        if (!startIso || !endIso) return null;
        return {
          client_id: String(ev.id || ''),
          session_id: ev.extendedProps?.sessionDbId || null,
          start_iso: startIso,
          end_iso: endIso,
          status: normalizeSessionStatus(ev.extendedProps?.status || 'draft'),
          session_type: String(ev.extendedProps?.sessionType || 'individual'),
          session_price: (ev.extendedProps?.sessionPrice ?? null),
          client_email: ev.extendedProps?.clientEmail || null,
          client_first_name: ev.extendedProps?.clientFirstName || null,
          client_last_name: ev.extendedProps?.clientLastName || null
        };
      }).filter(Boolean);

      // edited_dates must include previous dates too, for deletion behavior
      const editedDates = new Set(originalAvailabilityDates);
      oneTimePayload.forEach(item => editedDates.add(item.date));

      const editedDatesArr = Array.from(editedDates);
      const selectedDate = editedDatesArr[0] || getLocalDateKeyFromUtcIso(new Date().toISOString());

      const csrf = getCookie('csrftoken');
      if (!csrf) {
        console.warn('[MentorCalendar] Missing csrftoken cookie');
      }

      // Prepare changed sessions data for backend
      const changedSessionsData = [];
      if (changedSessionsById && changedSessionsById.size > 0) {
        changedSessionsById.forEach((snapshot, sessionId) => {
          const original = originalSessionsById.get(sessionId);
          if (original) {
            // Create original_data snapshot from original session
            // Ensure dates are ISO strings
            const originalStart = original.start ? (typeof original.start === 'string' ? original.start : new Date(original.start).toISOString()) : null;
            const originalEnd = original.end ? (typeof original.end === 'string' ? original.end : new Date(original.end).toISOString()) : null;
            changedSessionsData.push({
              session_id: sessionId,
              original_data: {
                start_datetime: originalStart,
                end_datetime: originalEnd,
                status: original.status,
                session_price: original.session_price,
                session_type: original.session_type || 'individual',
                client_email: original.client_email
              }
            });
          }
        });
      }

      // Filter out terminal state sessions from deleted_sessions array
      // Terminal state sessions (completed, refunded, expired) should NEVER be deleted
      const deletedSessionsArray = Array.from(deletedSessionDbIds || []);
      const filteredDeletedSessions = [];
      for (const sessionId of deletedSessionsArray) {
        // Check if this session is a terminal state session by looking it up in originalSessionsById
        const originalSession = originalSessionsById.get(parseInt(sessionId));
        if (originalSession) {
          const status = normalizeSessionStatus(originalSession.status || 'draft');
          // Only include in deletion if it's NOT a terminal state
          if (status !== 'completed' && status !== 'refunded' && status !== 'expired') {
            filteredDeletedSessions.push(sessionId);
          } else {
            console.warn('[MentorCalendar] Attempted to delete terminal state session:', sessionId, 'status:', status, '- This deletion was blocked.');
          }
        } else {
          // If we can't find the original session, include it (might be a new session that was deleted)
          // But log a warning
          console.warn('[MentorCalendar] Could not find original session data for deletion:', sessionId);
          filteredDeletedSessions.push(sessionId);
        }
      }

      const res = await fetch(SAVE_AVAILABILITY_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': csrf || ''
        },
        body: JSON.stringify({
          availability: availabilityPayload,
          sessions: sessionsPayload,
          deleted_sessions: filteredDeletedSessions,
          selected_date: selectedDate,
          edited_dates: editedDatesArr,
          changed_sessions: changedSessionsData  // New field for changed sessions
        })
      });
      const data = await res.json();
      if (!data.success) {
        console.warn('[MentorCalendar] save_availability failed:', data);
        // Unlock popup on error
        isSavingSessionChanges = false;
        updateSessionChangesLockState();
        return;
      }

      console.log('[MentorCalendar] saved availability:', {
        oneTime: oneTimePayload.length,
        recurring: recurringPayload.length,
        deletedRecurring: deleteSeriesPayload.length
      });
      await loadSavedAvailability();
      deletedSessionDbIds = new Set();
      // changedSessionsById is already cleared in loadSavedAvailability()
      
      // Refresh upcoming sessions in dashboard and my-sessions page
      if (typeof window.refreshDashboardUpcomingSessions === 'function') {
        window.refreshDashboardUpcomingSessions();
      }
      if (typeof window.refreshMySessionsPage === 'function') {
        window.refreshMySessionsPage();
      }
      
      // Show success notification with client notification info
      if (typeof showNotification === 'function') {
        const clientsNotified = data.clients_notified || 0;
        const deletedClientsNotified = data.deleted_clients_notified || 0;
        
        let message = 'Saved successfully.';
        const notifications = [];
        
        if (clientsNotified > 0) {
          notifications.push(clientsNotified === 1 
            ? 'Client was notified about session changes' 
            : `${clientsNotified} clients were notified about session changes`);
        }
        
        if (deletedClientsNotified > 0) {
          notifications.push(deletedClientsNotified === 1 
            ? 'Client was notified about session cancellation' 
            : `${deletedClientsNotified} clients were notified about session cancellation`);
        }
        
        if (notifications.length > 0) {
          message = `Saved successfully. ${notifications.join('. ')}.`;
        }
        
        showNotification(message, 'success');
      }
      // After a successful save, disable the Save button again.
      dirtyAvailability = false;
      dirtySession = false;
      // If we were opened due to a session-length collision recovery flow, saving means resolution is persisted.
      openedFromSessionLengthChange = false;
    } catch (e) {
      console.error('[MentorCalendar] error saving availability:', e);
      // Unlock popup on error
      isSavingSessionChanges = false;
      updateSessionChangesLockState();
    } finally {
      setSaveButtonLoading(false);
      updateSaveButtonState();
    }
  }

  // Mode toggle (for now: only boolean + logs)
  // false = Sessions (green), true = Availability (blue)
  let isAvailabilityMode = false;

  function rangesOverlap(aStart, aEnd, bStart, bEnd) {
    if (!aStart || !aEnd || !bStart || !bEnd) return false;
    const a0 = aStart.getTime();
    const a1 = aEnd.getTime();
    const b0 = bStart.getTime();
    const b1 = bEnd.getTime();
    // Strict overlap (touching at boundary is NOT a collision)
    return a0 < b1 && b0 < a1;
  }

  function recomputeCollisions() {
    if (!calendar) return;

    const activeMode = isAvailabilityMode ? 'availability' : 'session';
    const allEvents = calendar.getEvents();
    const activeEvents = allEvents.filter(ev => ev.extendedProps?.slotMode === activeMode);

    const collisionIds = new Set();

    for (let i = 0; i < activeEvents.length; i++) {
      const a = activeEvents[i];
      const aStart = a.start;
      const aEnd = a.end;
      if (!aStart || !aEnd) continue;

      for (let j = 0; j < allEvents.length; j++) {
        const b = allEvents[j];
        if (!b || b.id === a.id) continue;
        const bStart = b.start;
        const bEnd = b.end;
        if (!bStart || !bEnd) continue;

        if (rangesOverlap(aStart, aEnd, bStart, bEnd)) {
          // Always mark the active-mode event red if it overlaps ANY other event.
          collisionIds.add(a.id);
          // If the other event is ALSO active-mode, it should be marked red too.
          if (b.extendedProps?.slotMode === activeMode) collisionIds.add(b.id);
        }
      }
    }

    let changed = false;
    allEvents.forEach(ev => {
      // Only events for the currently selected mode can be flagged red.
      const shouldFlag = (ev.extendedProps?.slotMode === activeMode) && collisionIds.has(ev.id);
      const currentFlag = !!ev.extendedProps?.hasCollision;
      if (currentFlag !== shouldFlag) {
        ev.setExtendedProp('hasCollision', shouldFlag);
        changed = true;
      }
    });

    // Some FullCalendar builds don't re-run `eventClassNames` when extendedProps change.
    // To ensure collisions appear red immediately, toggle the DOM class directly.
    try {
      if (root) {
        const els = root.querySelectorAll('.fc-event[data-event-id]');
        els.forEach((el) => {
          const id = String(el.dataset.eventId || '');
          if (!id) return;
          const ev = calendar.getEventById(id);
          if (!ev) return;
          const shouldFlag = (ev.extendedProps?.slotMode === activeMode) && collisionIds.has(id);
          el.classList.toggle('is-collision', !!shouldFlag);
        });
      }
    } catch (e) {
      // Never let collision rendering break navigation.
      console.warn('[MentorCalendar] collision DOM update failed:', e);
    }
  }

  function renderModeToggle() {
    if (!modeSessionsBtn || !modeAvailabilityBtn) return;
    modeSessionsBtn.classList.toggle('is-active', !isAvailabilityMode);
    modeAvailabilityBtn.classList.toggle('is-active', isAvailabilityMode);
  }

  function setMode(nextIsAvailability) {
    isAvailabilityMode = !!nextIsAvailability;
    renderModeToggle();
    
    // Toggle class on root for CSS styling
    if (root) {
      if (isAvailabilityMode) {
        root.classList.add('is-mode-availability');
      } else {
        root.classList.remove('is-mode-availability');
      }
      
      // Refresh Month View summary (it depends on mode)
      try {
        if (calendar && calendar.view?.type === 'dayGridMonth') {
          renderMonthSummary();
        }
      } catch (e) {}
    }

    // Update editability of all existing events
    if (calendar) {
      calendar.getEvents().forEach(ev => {
        const slotMode = ev.extendedProps?.slotMode;
        let shouldBeEditable = false;
        
        if (slotMode === 'availability') {
          // Allow drag start in Sessions mode so we can show the switch popup on drop.
          // The move will be reverted if not in Availability mode.
          shouldBeEditable = true;
        } else if (slotMode === 'session') {
          // Allow drag start in Availability mode so we can show the switch popup on drop.
          // The move/resize will be reverted if not in Sessions mode.
          shouldBeEditable = true;
        } else {
          shouldBeEditable = false;
        }
        
        // Use setProp to update the 'editable' property
        ev.setProp('editable', shouldBeEditable);
      });
    }

    console.log('[MentorCalendar] isAvailabilityMode =', isAvailabilityMode);
    recomputeCollisions();
  }

  function initCalendar(initialView, initialDate) {
    if (calendar) return;
    if (!window.FullCalendar || !window.FullCalendar.Calendar) {
      console.error('[MentorCalendar] FullCalendar not loaded');
      return;
    }
    if (!window.FullCalendarLuxon3) {
      console.warn('[MentorCalendar] FullCalendarLuxon3 plugin not loaded. Named IANA timeZone values may behave like local time.');
    }
    if (!window.FullCalendarInteraction) {
      console.warn('[MentorCalendar] FullCalendarInteraction plugin not loaded. Drag/drop and dateClick may not work.');
    }

    calendar = new FullCalendar.Calendar(root, {
      plugins: [
        ...(window.FullCalendarLuxon3 ? [window.FullCalendarLuxon3] : []),
        ...(window.FullCalendarInteraction ? [window.FullCalendarInteraction] : [])
      ],
      timeZone: timezone_variable,
      initialView: initialView || 'timeGridWeek',
      initialDate: initialDate || undefined,
      height: '100%',
      nowIndicator: true,
      headerToolbar: false, // Custom header
      allDaySlot: false,
      editable: true, // enables drag+resize (fine-grained control below)
      eventStartEditable: function(info) {
        // Prevent dragging past sessions (invited/confirmed sessions that have ended)
        if (info.event.extendedProps?.slotMode === 'session') {
          const status = info.event.extendedProps?.status;
          // Block expired, completed, and refunded sessions (terminal states, cannot be moved)
          if (status === 'expired' || status === 'completed' || status === 'refunded') {
            return false;
          }
          // Only block invited/confirmed sessions (draft sessions can be moved)
          if (status === 'invited' || status === 'confirmed') {
            const eventEnd = info.event.end;
            if (eventEnd) {
              const now = new Date();
              // If session has ended (end time < now), prevent dragging
              if (eventEnd < now) {
                return false;
              }
            }
          }
        }
        return true; // allow dragging for both slot types
      },
      eventDurationEditable: function(info) {
        // Only Session slots can be resized
        if (info.event.extendedProps?.slotMode !== 'session') {
          return false;
        }
        // Prevent resizing past sessions (invited/confirmed sessions that have ended)
        const status = info.event.extendedProps?.status;
        // Block expired, completed, and refunded sessions (terminal states, cannot be resized)
        if (status === 'expired' || status === 'completed' || status === 'refunded') {
          return false;
        }
        // Only block invited/confirmed sessions (draft sessions can be resized)
        if (status === 'invited' || status === 'confirmed') {
          const eventEnd = info.event.end;
          if (eventEnd) {
            const now = new Date();
            // If session has ended (end time < now), prevent resizing
            if (eventEnd < now) {
              return false;
            }
          }
        }
        return true;
      },
      eventResizableFromStart: function(info) {
        // Only Session slots can be resized (from either edge)
        if (info.event.extendedProps?.slotMode !== 'session') {
          return false;
        }
        // Prevent resizing past sessions (invited/confirmed sessions that have ended)
        const status = info.event.extendedProps?.status;
        // Block expired, completed, and refunded sessions (terminal states, cannot be resized)
        if (status === 'expired' || status === 'completed' || status === 'refunded') {
          return false;
        }
        // Only block invited/confirmed sessions (draft sessions can be resized)
        if (status === 'invited' || status === 'confirmed') {
          const eventEnd = info.event.end;
          if (eventEnd) {
            const now = new Date();
            // If session has ended (end time < now), prevent resizing
            if (eventEnd < now) {
              return false;
            }
          }
        }
        return true;
      },
      eventAllow: function(dropInfo, draggedEvent) {
        // Prevent dropping sessions to the past (check drop location)
        try {
          if (draggedEvent?.extendedProps?.slotMode === 'session') {
            const status = draggedEvent.extendedProps?.status;
            // Block expired, completed, and refunded sessions (terminal states, cannot be moved)
            if (status === 'expired' || status === 'completed' || status === 'refunded') {
              return false;
            }
            
            // Check if the drop location is in the past
            if (dropInfo && dropInfo.start) {
              const dropEnd = dropInfo.end || dropInfo.start;
              const now = new Date();
              // If the drop location end time is in the past, prevent dropping
              if (dropEnd < now) {
                // Track this blocked drag to show notification once in eventDragStop
                lastBlockedPastSessionDrag = { eventId: String(draggedEvent.id || ''), atMs: Date.now() };
                return false;
              }
            }
          }
          
          // For recurring availability instances:
          // - allow moving across days in timeGrid views (we'll prompt for "this one" vs "all future")
          // - disallow dragging in Month view (dayGridMonth) for clarity
          if (draggedEvent?.extendedProps?.isRecurringInstance) {
            const viewType = calendar?.view?.type;
            if (viewType === 'dayGridMonth') {
              lastBlockedRecurringDrag = { recurringId: String(draggedEvent.extendedProps.recurringId || ''), atMs: Date.now() };
              return false;
            }
          }
        } catch (e) {}
        return true;
      },
      eventClassNames: function(arg) {
        return arg.event.extendedProps?.hasCollision ? ['is-collision'] : [];
      },

      eventDidMount: function(info) {
        // Double-click slots -> open settings (or prompt to switch modes)
        try {
          // Month view: do not render individual slots (we render a per-day summary instead)
          try {
            const viewType = calendar?.view?.type;
            const m = info.event?.extendedProps?.slotMode;
            if (viewType === 'dayGridMonth' && (m === 'availability' || m === 'session')) {
              if (info.el) info.el.style.display = 'none';
              return;
            }
          } catch (e) {}

          const mode = info.event?.extendedProps?.slotMode;
          if (!info.el) return;
          // Used by collision DOM updates (some builds don't rerender classes reliably)
          info.el.dataset.eventId = String(info.event?.id || '');
          
            // Set data-session-status attribute for session slots to enable status-specific styling
            if (mode === 'session') {
              const status = normalizeSessionStatus(info.event?.extendedProps?.status || 'draft');
              info.el.setAttribute('data-session-status', status);
            }

          // Tag recurring instances so we can style the whole series (blink)
          if (info.event?.extendedProps?.isRecurringInstance && info.event?.extendedProps?.recurringId) {
            info.el.dataset.recurringId = String(info.event.extendedProps.recurringId);
            if (info.event.extendedProps.instanceDate) info.el.dataset.instanceDate = String(info.event.extendedProps.instanceDate);
          }

          // Availability slot: in Sessions mode, single click schedules session (debounced).
          if (mode === 'availability') {
            info.el.addEventListener('click', (e) => {
              // Only for Sessions mode
              if (isAvailabilityMode) return;

              // If a previous timer is pending, clear it (we'll overwrite with this click)
              if (__availabilityClickTimer) {
                clearTimeout(__availabilityClickTimer);
                __availabilityClickTimer = null;
              }
              __availabilityClickEventId = info.event.id;

              // Wait a bit to see if this becomes a double-click
              __availabilityClickTimer = window.setTimeout(() => {
                __availabilityClickTimer = null;
                __availabilityClickEventId = null;
                const latestEv = calendar?.getEventById?.(info.event.id) || info.event;
                openScheduleSessionPopupForEvent(latestEv);
              }, 220);

              e.preventDefault();
              e.stopPropagation();
            });
          }

          info.el.addEventListener('dblclick', (e) => {
            // Cancel any pending single-click schedule action for this availability event
            if (mode === 'availability' && __availabilityClickTimer && __availabilityClickEventId === info.event.id) {
              clearTimeout(__availabilityClickTimer);
              __availabilityClickTimer = null;
              __availabilityClickEventId = null;
            }

            e.preventDefault();
            e.stopPropagation();
            if (mode === 'availability') {
              if (!isAvailabilityMode) {
                openAvailabilitySwitchPopupForEventId(info.event.id, true);
                return;
              }
              const latestEv = calendar?.getEventById?.(info.event.id) || info.event;
              openAvailabilitySettingsForEvent(latestEv);
              return;
            }

            if (mode === 'session') {
              if (isAvailabilityMode) {
                openSessionSwitchPopupForEventId(info.event.id, true);
                return;
              }
              const latestEv = calendar?.getEventById?.(info.event.id) || info.event;
              openSessionSettingsForEvent(latestEv);
            }
          });
        } catch (e) {
          // non-fatal
          console.warn('[MentorCalendar] eventDidMount dblclick bind failed:', e);
        }
      },
      eventDragStop: function(info) {
        // Show notification for blocked past session drag (only once per drag attempt)
        try {
          if (lastBlockedPastSessionDrag) {
            const eventId = String(info?.event?.id || '');
            if (lastBlockedPastSessionDrag.eventId === eventId) {
              const dt = Date.now() - (lastBlockedPastSessionDrag.atMs || 0);
              // only trigger near the time the block happened (avoid stale)
              if (dt >= 0 && dt < 800) {
                const status = info?.event?.extendedProps?.status;
                if (status === 'completed' || status === 'refunded') {
                  if (typeof showNotification === 'function') {
                    showNotification('Completed sessions cannot be changed.', 'warning');
                  }
                } else {
                  if (typeof showNotification === 'function') {
                    showNotification('Cannot move past sessions. Please use the session settings to make changes.', 'warning');
                  }
                }
              }
              lastBlockedPastSessionDrag = null;
            }
          }
        } catch (e) {}
        
        // If we just blocked a recurring drag (e.g., Month view), blink the series.
        try {
          if (info?.event?.extendedProps?.isRecurringInstance) {
            const rid = String(info.event.extendedProps.recurringId || '');
            if (lastBlockedRecurringDrag && lastBlockedRecurringDrag.recurringId === rid) {
              const dt = Date.now() - (lastBlockedRecurringDrag.atMs || 0);
              // only trigger near the time the block happened (avoid stale)
              if (dt >= 0 && dt < 800) {
                blinkRecurringSeries(rid);
              }
              lastBlockedRecurringDrag = null;
            }
          }
        } catch (e) {}
      },
      slotDuration: '00:05:00',
      snapDuration: '00:05:00',
      slotLabelInterval: '01:00:00',
      
      // Style past days as disabled
      dayCellClassNames: function(arg) {
        const cellDate = arg.date;
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const cellDateOnly = new Date(cellDate);
        cellDateOnly.setHours(0, 0, 0, 0);
        
        if (cellDateOnly < today) {
          return ['fc-day-past-disabled'];
        }
        return [];
      },
      
      // Events
      datesSet: function(info) {
        updateDateTitle(info.view.title);
        updateActiveViewButton(info.view.type);
        styleGridLines();
        if (info?.view?.type === 'dayGridMonth') {
          renderMonthSummary();
        } else {
          clearMonthSummary();
          renderRecurringInstancesForCurrentView();
        }
      },
      eventDrop: function(info) {
        const mode = info.event.extendedProps?.slotMode;
        
        // Prevent dropping sessions to the past (check NEW drop location)
        if (mode === 'session') {
          const status = info.event.extendedProps?.status;
          // Block expired, completed, and refunded sessions (terminal states, cannot be moved)
          if (status === 'expired' || status === 'completed' || status === 'refunded') {
            info.revert();
            // Track blocked drag for notification in eventDragStop
            lastBlockedPastSessionDrag = { eventId: String(info.event.id || ''), atMs: Date.now() };
            return;
          }
          
          // Check if the NEW drop location is in the past
          const newEnd = info.event.end;
          if (newEnd) {
            const now = new Date();
            // If the new end time is in the past, prevent dropping to the past
            if (newEnd < now) {
              info.revert();
              // Track blocked drag for notification in eventDragStop
              lastBlockedPastSessionDrag = { eventId: String(info.event.id || ''), atMs: Date.now() };
              if (typeof showNotification === 'function') {
                showNotification('Cannot move sessions to the past.', 'warning');
              }
              return;
            }
          }
          
          // Successfully moved session - show reminder to save
          if (status === 'invited' || status === 'confirmed') {
            if (typeof showNotification === 'function') {
              showNotification("Don't forget to save changes for them to take effect.", 'note');
            }
          }
        }
        
        // Recurring instances: confirm move (one occurrence vs all).
        if (mode === 'availability' && info.event.extendedProps?.isRecurringInstance && isAvailabilityMode) {
          const recurringId = info.event.extendedProps?.recurringId;
          const instanceDate = info.event.extendedProps?.instanceDate || getLocalDateKeyFromJsDate(info.event.start);
          const newStartIso = info.event.start ? info.event.start.toISOString() : null;
          const newEndIso = info.event.end ? info.event.end.toISOString() : null;
          info.revert(); // keep UI stable until user chooses
          if (recurringId && instanceDate && newStartIso && newEndIso) {
            pendingRecurringMove = { recurringId, instanceDate, newStartIso, newEndIso };
            // Button label: if we're going to materialize dates between today and instanceDate,
            // make it explicit this affects only future slots.
            try {
              if (window.luxon && window.luxon.DateTime) {
                const rule = recurringAvailabilityRules.get(recurringId);
                const todayLocal = window.luxon.DateTime.now().setZone(timezone_variable).startOf('day');
                const effectiveStart = rule?.start_date
                  ? window.luxon.DateTime.fromISO(String(rule.start_date), { zone: timezone_variable }).startOf('day')
                  : todayLocal;
                const windowStart = (effectiveStart.isValid && effectiveStart > todayLocal) ? effectiveStart : todayLocal;
                const instanceDay = window.luxon.DateTime.fromISO(String(instanceDate), { zone: timezone_variable }).startOf('day');
                const shouldMaterialize = windowStart.isValid && instanceDay.isValid && windowStart < instanceDay;
                setRecurringMoveAllButtonLabel(shouldMaterialize ? 'All future slots' : 'All');
              } else {
                setRecurringMoveAllButtonLabel('All');
              }
            } catch (e) {
              setRecurringMoveAllButtonLabel('All');
            }
            setRecurringMoveVisible(true);
          }
          return;
        }
        // Dragging availability in Sessions mode: revert and prompt to switch
        if (mode === 'availability' && !isAvailabilityMode) {
          info.revert();
          openAvailabilitySwitchPopupForEventId(info.event.id, false);
          return;
        }
        // Dragging session in Availability mode: revert and prompt to switch
        if (mode === 'session' && isAvailabilityMode) {
          info.revert();
          openSessionSwitchPopupForEventId(info.event.id, false);
          return;
        }
        console.log('[MentorCalendar] eventDrop', {
          mode,
          id: info.event.id,
          startIso: info.event.start ? info.event.start.toISOString() : null,
          endIso: info.event.end ? info.event.end.toISOString() : null,
          timeZone: timezone_variable
        });
        markDirty(mode);
        recomputeCollisions();
        
        // Track session mutation (only for sessions)
        if (mode === 'session') {
          onSessionMutated(info.event);
        }
        
        // Force collision popup to refresh immediately if it's open
        if (typeof window.refreshCollisionResolutionPopup === 'function') {
          window.refreshCollisionResolutionPopup();
        }
      },
      // eventClick is intentionally unused for availability slots because we debounce
      // single-click vs double-click inside eventDidMount.
      eventResize: function(info) {
        const mode = info.event.extendedProps?.slotMode;
        if (mode !== 'session') {
          // Safety: availability should never resize
          info.revert();
          console.log('[MentorCalendar] prevented resize for non-session slot', { id: info.event.id, mode });
          return;
        }
        
        // Prevent resizing past sessions (invited/confirmed sessions that have ended)
        const status = info.event.extendedProps?.status;
        // Block expired, completed, and refunded sessions (terminal states, cannot be resized)
        if (status === 'expired' || status === 'completed' || status === 'refunded') {
          info.revert();
          return;
        }
        // Only block invited/confirmed sessions (draft sessions can be resized)
        if (status === 'invited' || status === 'confirmed') {
          // Check original end time (before resize) to see if it was in the past
          const originalEvent = info.oldEvent;
          const originalEnd = originalEvent?.end;
          if (originalEnd) {
            const now = new Date();
            // If original session had ended (end time < now), prevent the resize
            if (originalEnd < now) {
              info.revert();
              if (typeof showNotification === 'function') {
                showNotification('Cannot resize past sessions. Please use the session settings to make changes.', 'warning');
              }
              return;
            }
          }
        }
        
        // Resizing session in Availability mode: revert and prompt to switch
        if (isAvailabilityMode) {
          info.revert();
          openSessionSwitchPopupForEventId(info.event.id, false);
          return;
        }
        console.log('[MentorCalendar] eventResize', {
          mode,
          id: info.event.id,
          startIso: info.event.start ? info.event.start.toISOString() : null,
          endIso: info.event.end ? info.event.end.toISOString() : null,
          timeZone: timezone_variable
        });
        markDirty('session');
        recomputeCollisions();
        
        // Track session mutation
        onSessionMutated(info.event);
        
        // Force collision popup to refresh immediately if it's open
        if (typeof window.refreshCollisionResolutionPopup === 'function') {
          window.refreshCollisionResolutionPopup();
        }
      },
      dateClick: function(info) {
        // One-click slot creation only in Day/Week timeGrid views
        const viewType = info.view?.type;
        if (viewType !== 'timeGridDay' && viewType !== 'timeGridWeek') return;
        // Prevent accidental slot creation immediately after clicking month summary chips
        if (suppressNextDateClickUntilMs && Date.now() < suppressNextDateClickUntilMs) return;

        // Prevent creating slots on past dates or past times
        const clickedDate = info.date;
        const now = new Date();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const clickedDateOnly = new Date(clickedDate);
        clickedDateOnly.setHours(0, 0, 0, 0);
        
        const mode = isAvailabilityMode ? 'availability' : 'session';
        
        // Check if it's a past date
        if (clickedDateOnly < today) {
          // Past date clicked - do not create slot
          if (typeof showNotification === 'function') {
            const slotType = mode === 'availability' ? 'availability slots' : 'session slots';
            showNotification(`Cannot create ${slotType} for past dates.`, 'warning');
          }
          return;
        }
        
        // Check if it's today but the clicked time is in the past
        if (clickedDateOnly.getTime() === today.getTime() && clickedDate < now) {
          // Past time on today clicked - do not create slot
          if (typeof showNotification === 'function') {
            const slotType = mode === 'availability' ? 'availability slots' : 'session slots';
            showNotification(`Cannot create ${slotType} for past times.`, 'warning');
          }
          return;
        }
        // Use mentor profile session_length (minutes) for slot length
        const durationMinutes = resolveMentorSessionLengthMinutes();

        const startIso = info.date.toISOString();
        const endIso = new Date(info.date.getTime() + durationMinutes * 60 * 1000).toISOString();

        if (mode === 'session') {
          const status = 'draft';
          const colors = sessionColorsForStatus(status);
          const defaultPrice = computeDefaultSessionPrice(durationMinutes);
          calendar.addEvent({
            id: 'session_tmp_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8),
            start: startIso,
            end: endIso,
            allDay: false,
            backgroundColor: colors.bg,
            borderColor: colors.border,
            textColor: colors.text,
            classNames: ['event-type-session'],
            editable: true,
            extendedProps: { slotMode: 'session', type: 'session', status: status, sessionDbId: null, sessionPrice: defaultPrice }
          });
        } else {
          calendar.addEvent({
            id: 'availability_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8),
            start: startIso,
            end: endIso,
            allDay: false,
            backgroundColor: '#3b82f6',
            borderColor: '#2563eb',
            textColor: '#ffffff',
            classNames: ['event-type-availability'],
            editable: true,
            extendedProps: { slotMode: 'availability', type: 'availability_slot' }
          });
        }

        console.log('[MentorCalendar] created slot', { mode, startIso, endIso, isAvailabilityMode });
        markDirty(mode);
        recomputeCollisions();
      },
      eventContent: function(arg) {
        const mode = arg.event.extendedProps?.slotMode || 'availability';
        const tpl = mode === 'session' ? sessionSlotTpl : availabilitySlotTpl;
        if (!tpl || !tpl.content) return true;

        const startStr = calendar.formatDate(arg.event.start, { hour: 'numeric', minute: '2-digit', hour12: true });
        const endStr = calendar.formatDate(arg.event.end, { hour: 'numeric', minute: '2-digit', hour12: true });

        const node = tpl.content.firstElementChild.cloneNode(true);
        const timeEl = node.querySelector('[data-slot-time]');
        if (timeEl) timeEl.textContent = `${startStr}  ${endStr}`;

        // "Props" passed to the slot component (keeps calendar.html light)
        const props = {
          slotMode: mode,
          isAvailabilityMode,
          timezone: timezone_variable,
          eventId: arg.event.id,
          status: arg.event.extendedProps?.status || null,
          recurringId: arg.event.extendedProps?.recurringId || null,
          instanceDate: arg.event.extendedProps?.instanceDate || null,
          startIso: arg.event.start ? arg.event.start.toISOString() : null,
          endIso: arg.event.end ? arg.event.end.toISOString() : null,
          clientFirstName: arg.event.extendedProps?.clientFirstName || null,
          clientLastName: arg.event.extendedProps?.clientLastName || null,
          clientEmail: arg.event.extendedProps?.clientEmail || null,
        };

        if (mode === 'session') {
          window.MentorCalendarSlotComponents?.SessionSlot?.mount?.(node, props);
        } else {
          window.MentorCalendarSlotComponents?.AvailabilitySlot?.mount?.(node, props);
        }

        return { domNodes: [node] };
      },
      windowResize: function() {
        calendar.updateSize();
        styleGridLines();
      }
    });

    calendar.render();
    
    // Initial style application
    setTimeout(styleGridLines, 50);
    console.log('[MentorCalendar] Active timeZone:', calendar.getOption('timeZone'));
    // Save starts disabled until the user makes a change
    updateSaveButtonState();
    recomputeCollisions();
  }

  // Internal API for slot components (client-only changes; DB persistence happens on Save)
  window.MentorCalendarInternal = window.MentorCalendarInternal || {};

  // Called by AvailabilitySlot recurrence dropdown
  window.MentorCalendarInternal.setRecurrenceForEvent = function(payload) {
    if (!calendar) return;
    const eventId = payload?.eventId || '';
    const recurringId = payload?.recurringId || '';
    const value = payload?.value || 'none';

    // Existing recurring instance: update recurring rule type
    if (recurringId && recurringAvailabilityRules.has(recurringId)) {
      const rule = recurringAvailabilityRules.get(recurringId);
      if (!rule) return;

      if (value === 'none') {
        // Convert series -> one-time slot for the clicked instance
        const instanceEv = calendar.getEventById(eventId);
        if (instanceEv && instanceEv.start && instanceEv.end) {
          const startIso = instanceEv.start.toISOString();
          const endIso = instanceEv.end.toISOString();
          const newId = recurringId; // preserve ID across conversion
          recurringAvailabilityRules.delete(recurringId);
          clearRecurringInstanceEvents();
          calendar.addEvent({
            id: newId,
            start: startIso,
            end: endIso,
            allDay: false,
            backgroundColor: '#3b82f6',
            borderColor: '#2563eb',
            textColor: '#ffffff',
            classNames: ['event-type-availability'],
            editable: true,
            // Tell backend this is a conversion from recurring -> one-time
            extendedProps: { slotMode: 'availability', type: 'availability_slot', recurringSlotId: recurringId }
          });
          markDirty('availability');
          renderRecurringInstancesForCurrentView();
        }
        return;
      }

      // Switch recurring pattern (keep times)
      rule.type = value;
      // Update weekday/day_of_month anchor based on the instance date (best UX)
      const instanceDate = payload?.instanceDate || rule.anchor_date || rule.start_date || getLocalDateKeyFromUtcIso(new Date().toISOString());
      rule.anchor_date = instanceDate;
      if (!rule.start_date) rule.start_date = instanceDate;
      if (value === 'weekly') {
        const wd = weekdayNameFromIsoDate(instanceDate);
        rule.weekdays = wd ? [wd] : (rule.weekdays || []);
        rule.day_of_month = null;
      } else if (value === 'monthly') {
        try {
          if (window.luxon && window.luxon.DateTime) {
            const dt = window.luxon.DateTime.fromISO(instanceDate, { zone: timezone_variable });
            rule.day_of_month = dt.isValid ? dt.day : rule.day_of_month;
            rule.weekdays = [];
          }
        } catch (e) {}
      } else if (value === 'daily') {
        rule.weekdays = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];
        rule.day_of_month = null;
      }
      recurringAvailabilityRules.set(recurringId, rule);
      markDirty('availability');
      renderRecurringInstancesForCurrentView();
      return;
    }

    // One-time availability event: if recurrence != none, turn it into a recurring rule
    if (eventId && value !== 'none') {
      const ev = calendar.getEventById(eventId);
      if (!ev || !ev.start || !ev.end) return;
      const dateStr = getLocalDateKeyFromJsDate(ev.start);
      const startTime = getLocalTimeHHmmFromJsDate(ev.start);
      const endTime = getLocalTimeHHmmFromJsDate(ev.end);
      if (!dateStr || !startTime || !endTime) return;

      const rule = {
        id: eventId,
        type: value,
        slot_type: 'availability_slot',
        start_date: dateStr,
        start_time: startTime,
        end_time: endTime,
        skip_dates: [],
        booked_dates: [],
        anchor_date: dateStr
      };
      if (value === 'weekly') {
        const wd = weekdayNameFromIsoDate(dateStr);
        rule.weekdays = wd ? [wd] : [];
      } else if (value === 'monthly') {
        try {
          if (window.luxon && window.luxon.DateTime) {
            const dt = window.luxon.DateTime.fromJSDate(ev.start).setZone(timezone_variable);
            rule.day_of_month = dt.day;
          }
        } catch (e) {}
      } else if (value === 'daily') {
        rule.weekdays = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];
      }

      recurringAvailabilityRules.set(eventId, rule);
      // Remove the one-time event to avoid duplicates (series will render occurrences)
      ev.remove();
      markDirty('availability');
      renderRecurringInstancesForCurrentView();
    }
  };

  window.MentorCalendarInternal.removeEventById = function(eventId) {
    if (!calendar || !eventId) return;
    const ev = calendar.getEventById(eventId);
    if (!ev) return;
    const slotMode = ev.extendedProps?.slotMode;
    console.log('[MentorCalendar] removing event (client-only):', {
      id: ev.id,
      slotMode: slotMode
    });
    
    // Session slot: mark for deletion (DB) if persisted
    if (slotMode === 'session') {
      const status = ev.extendedProps?.status;
      // Prevent deletion of expired, completed, or refunded sessions
      if (status === 'expired') {
        if (typeof showNotification === 'function') {
          showNotification('Expired sessions cannot be deleted.', 'warning');
        }
        return;
      }
      if (status === 'completed' || status === 'refunded') {
        if (typeof showNotification === 'function') {
          showNotification('Completed and refunded sessions cannot be deleted.', 'warning');
        }
        return;
      }
      const dbId = ev.extendedProps?.sessionDbId;
      if (dbId) {
        try {
          deletedSessionDbIds.add(String(dbId));
          // Remove from changedSessionsById if it was being tracked as a change
          // When a session is deleted, it should no longer appear in the changes popup
          const dbIdInt = parseInt(dbId);
          if (changedSessionsById && changedSessionsById.has(dbIdInt)) {
            changedSessionsById.delete(dbIdInt);
            console.log('[MentorCalendar] Session', dbId, 'deleted, removed from changedSessionsById');
            // Update the session changes popup if it's open
            if (typeof renderSessionChanges === 'function') {
              renderSessionChanges();
            }
          }
        } catch (e) {}
      }
      markDirty('session');
      ev.remove();
      recomputeCollisions();
      
      // Show notification reminding user to save
      if (typeof showNotification === 'function') {
        showNotification("Don't forget to save changes for them to take effect.", 'note');
      }
      return;
    }

    // Recurring availability instance: ask whether to delete one vs all
    if (slotMode === 'availability' && ev.extendedProps?.isRecurringInstance && ev.extendedProps?.recurringId) {
      const recurringId = ev.extendedProps.recurringId;
      const instanceDate = ev.extendedProps.instanceDate || getLocalDateKeyFromJsDate(ev.start);
      openRecurringDeletePopup({ eventId: ev.id, recurringId, instanceDate });
      return;
    }

    // Reminder: removing availability is client-only until user clicks Save
    if (slotMode === 'availability' && typeof showNotification === 'function') {
      showNotification("Don't forget to save the changes.", 'note');
    }
    
    markDirty(slotMode);
    ev.remove();
    recomputeCollisions();
  };

  function updateDateTitle(title) {
    if (dateDisplay) {
      dateDisplay.textContent = title;
    }
  }

  function updateActiveViewButton(viewType) {
    document.querySelectorAll('.view-toggle-btn').forEach(btn => {
      btn.classList.toggle('is-active', btn.dataset.calendarView === viewType);
    });
  }

  // --- Custom Styling Logic similar to Availability Popup ---
  function styleGridLines() {
    // 1. Mark hour slots for solid borders
    const slots = root.querySelectorAll('tr');
    slots.forEach(slot => {
        // FullCalendar 6 uses data-time on slot rows, or we check structure
        // Simple heuristic: if it has a label or is top of hour
        const labelCell = slot.querySelector('.fc-timegrid-slot-label');
        if (labelCell && labelCell.getAttribute('data-time')) {
           const time = labelCell.getAttribute('data-time');
           if (time.endsWith(':00:00')) {
             slot.classList.add('fc-hour-slot');
             // Also target the sibling td which is the actual lane
             const lane = slot.querySelector('.fc-timegrid-slot-lane');
             if(lane) lane.classList.add('fc-hour-slot');
           }
        }
    });

    // Fallback if needed, but the above usually works well in FC v6
    // Extra pass for rows that might be missed by simple label check
    const timeSlots = root.querySelectorAll('.fc-timegrid-slot-lane');
    timeSlots.forEach((slot, i) => {
       // Assuming 15min slots per tr, index 0 is first. 
       // We can simply trust the label checking above for now.
    });
  }

  // Month summary click handling (event delegation) - SQUARE CLICK
  if (root && !root.__mentorMonthSummaryBound) {
    root.__mentorMonthSummaryBound = true;
    root.addEventListener('click', (e) => {
      try {
        const target = e.target;
        if (!(target instanceof Element)) return;
        
        // Updated to target the new "mentor-month-square"
        const sq = target.closest('.mentor-month-square');
        if (!sq) return;
        
        const dateStr = sq.getAttribute('data-date') || '';
        if (!dateStr || !calendar) return;
        
        e.preventDefault();
        e.stopPropagation();
        
        // Avoid creating a slot due to the same click after switching views.
        suppressNextDateClickUntilMs = Date.now() + 600;
        
        // Switch view but maintain current mode
        window.setTimeout(() => {
          try {
            calendar.changeView('timeGridDay', dateStr);
          } catch (e2) {}
        }, 0);
      } catch (err) {}
    }, { capture: true });
  }

  // Double-click on day cell handling
  if (root && !root.__mentorMonthDblClickBound) {
    root.__mentorMonthDblClickBound = true;
    root.addEventListener('dblclick', (e) => {
      try {
        const viewType = calendar?.view?.type;
        if (viewType !== 'dayGridMonth') return;
        
        const target = e.target;
        if (!(target instanceof Element)) return;
        
        const dayEl = target.closest('.fc-daygrid-day');
        if (!dayEl) return;
        
        const dateStr = dayEl.getAttribute('data-date');
        if (!dateStr) return;
         
        e.preventDefault();
        e.stopPropagation();
        
        window.setTimeout(() => {
          try {
             calendar.changeView('timeGridDay', dateStr);
          } catch(e2) {}
        }, 0);
      } catch (err) {}
    });
  }


  function destroyCalendar() {
    if (!calendar) return;
    try {
      calendar.destroy();
    } finally {
      calendar = null;
      root.innerHTML = '';
    }
  }

  function open(triggerEl) {
    overlay.classList.add('is-visible');
    overlay.setAttribute('aria-hidden', 'false');
    
    // Initialize session tracking maps on calendar open
    originalSessionsById.clear();
    changedSessionsById.clear();
    
    // Optional: allow opener to force initial mode.
    // Supported values: 'sessions' | 'availability'
    const requestedMode = (triggerEl && triggerEl.dataset && triggerEl.dataset.mentorCalendarInitialMode) ? String(triggerEl.dataset.mentorCalendarInitialMode) : '';
    if (requestedMode === 'sessions') setMode(false);
    if (requestedMode === 'availability') setMode(true);

    // Small delay to ensure transitions work and DOM is ready
    setTimeout(() => {
        // Re-resolve timezone from profile on each open (in case it changed)
        timezone_variable = resolveMentorTimezone();
        renderModeToggle();
        initCalendar();
        if (calendar) calendar.updateSize();
        loadSavedAvailability();
    }, 50);
  }

  // Auto-open (used for session-length-change collision recovery flow)
  try {
    const params = new URLSearchParams(window.location.search || '');
    if (params.get('open_calendar') === 'true') {
      openedFromSessionLengthChange = true;
      // Ensure Availability mode when opening for collision resolution
      const trigger = document.querySelector('[data-open-mentor-calendar]') || null;
      if (trigger && trigger.dataset) trigger.dataset.mentorCalendarInitialMode = 'availability';
      open(trigger);
      // Once events load, show collision popup if collisions exist
      setTimeout(() => {
        try {
          if (hasCalendarCollisionsInHorizon() && typeof window.openCollisionResolutionPopup === 'function') {
            window.openCollisionResolutionPopup(true);
          } else {
            // No collisions anymore; exit locked mode.
            openedFromSessionLengthChange = false;
          }
        } catch (e) {}
      }, 1200);

      // Prevent repeatedly re-triggering the auto-open flow on refresh.
      try {
        params.delete('open_calendar');
        const next = params.toString();
        const newUrl = window.location.pathname + (next ? ('?' + next) : '') + window.location.hash;
        window.history.replaceState({}, '', newUrl);
      } catch (e) {}
    }
  } catch (e) {}

  function setUnsavedChangesVisible(isVisible) {
    if (!unsavedChangesOverlay) return;
    unsavedChangesOverlay.classList.toggle('is-visible', !!isVisible);
    unsavedChangesOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeUnsavedChangesPopup() {
    setUnsavedChangesVisible(false);
  }

  function hasUnsavedCalendarChanges() {
    // Don't show unsaved changes popup if save is in progress
    if (isSavingSessionChanges) {
      return false;
    }
    // Contract per your rule: Save enabled => unsaved changes exist
    if (saveBtn && saveBtn.disabled === false) return true;
    return !!(dirtyAvailability || dirtySession);
  }

  function closeNow() {
    // Reset session tracking on close
    originalSessionsById.clear();
    changedSessionsById.clear();
    
    // Always close the settings popup too (if open)
    if (availabilitySettingsOverlay && availabilitySettingsOverlay.classList.contains('is-visible')) {
      closeAvailabilitySettings();
    }
    if (availabilitySwitchOverlay && availabilitySwitchOverlay.classList.contains('is-visible')) {
      closeAvailabilitySwitchPopup();
    }
    if (sessionSwitchOverlay && sessionSwitchOverlay.classList.contains('is-visible')) {
      closeSessionSwitchPopup();
    }
    if (sessionSettingsOverlay && sessionSettingsOverlay.classList.contains('is-visible')) {
      closeSessionSettings();
    }
    if (scheduleSessionOverlay && scheduleSessionOverlay.classList.contains('is-visible')) {
      closeScheduleSessionPopup();
    }
    if (unsavedChangesOverlay && unsavedChangesOverlay.classList.contains('is-visible')) {
      closeUnsavedChangesPopup();
    }
    if (recurringDeleteOverlay && recurringDeleteOverlay.classList.contains('is-visible')) {
      setRecurringDeleteVisible(false);
      pendingRecurringDelete = null;
    }
    overlay.classList.remove('is-visible');
    overlay.setAttribute('aria-hidden', 'true');
    // Destroy calendar so it reconstructs cleanly on next open
    destroyCalendar();
    // Reset save state (fresh on next open)
    dirtyAvailability = false;
    dirtySession = false;
    updateSaveButtonState();
  }

  function attemptClose() {
    // If session length increased and DB now contains collisions, we should not allow closing
    // without addressing collisions (user can still choose "Delete all colliding slots").
    if (openedFromSessionLengthChange && hasCalendarCollisionsInHorizon()) {
      if (typeof window.openCollisionResolutionPopup === 'function') {
        window.openCollisionResolutionPopup(true); // locked popup behavior handled by the popup itself
      }
      return;
    }

    // In the session-length-change recovery flow, do not allow discarding changes.
    // The mentor must save to persist collision resolution to the database.
    if (openedFromSessionLengthChange && hasUnsavedCalendarChanges()) {
      if (typeof showNotification === 'function') {
        showNotification('Please save your changes to resolve collisions.', 'warning');
      }
      return;
    }

    // If there are unsaved changes, ask for confirmation first
    if (hasUnsavedCalendarChanges()) {
      setUnsavedChangesVisible(true);
      return;
    }
    closeNow();
  }

  // --- Event Listeners ---

  // Navigation Buttons
  overlay.querySelectorAll('[data-calendar-nav]').forEach(btn => {
    btn.addEventListener('click', () => {
      if (!calendar) return;
      const action = btn.dataset.calendarNav;
      if (action === 'prev') calendar.prev();
      if (action === 'next') calendar.next();
      if (action === 'today') calendar.today();
    });
  });

  // View Toggle Buttons
  overlay.querySelectorAll('[data-calendar-view]').forEach(btn => {
    btn.addEventListener('click', () => {
      if (!calendar) return;
      calendar.changeView(btn.dataset.calendarView);
    });
  });

  // Mode toggle buttons (boolean only, no behavior yet)
  if (modeSessionsBtn) {
    modeSessionsBtn.addEventListener('click', () => setMode(false));
  }
  if (modeAvailabilityBtn) {
    modeAvailabilityBtn.addEventListener('click', () => setMode(true));
  }

  /**
   * Show/hide session changes popup
   */
  // Track if save is in progress to lock the popup
  let isSavingSessionChanges = false;

  function setSessionChangesVisible(isVisible) {
    if (!sessionChangesOverlay) return;
    sessionChangesOverlay.classList.toggle('is-visible', !!isVisible);
    sessionChangesOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
    
    if (isVisible) {
      renderSessionChanges();
      // Reset save state when opening
      isSavingSessionChanges = false;
      updateSessionChangesLockState();
    }
  }

  function closeSessionChanges() {
    // Don't allow closing if save is in progress
    if (isSavingSessionChanges) {
      return;
    }
    setSessionChangesVisible(false);
  }

  function updateSessionChangesLockState() {
    if (!sessionChangesOverlay) return;
    const isLocked = isSavingSessionChanges;
    
    // Disable/enable close buttons
    sessionChangesOverlay.querySelectorAll('[data-session-changes-close]').forEach(el => {
      if (isLocked) {
        el.style.pointerEvents = 'none';
        el.style.opacity = '0.5';
        el.style.cursor = 'not-allowed';
      } else {
        el.style.pointerEvents = '';
        el.style.opacity = '';
        el.style.cursor = '';
      }
    });
    
    // Disable/enable cancel button
    sessionChangesOverlay.querySelectorAll('[data-session-changes-cancel]').forEach(el => {
      if (isLocked) {
        el.disabled = true;
        el.style.opacity = '0.5';
        el.style.cursor = 'not-allowed';
      } else {
        el.disabled = false;
        el.style.opacity = '';
        el.style.cursor = '';
      }
    });
    
    // Update confirm button with loading state
    if (sessionChangesConfirmBtn) {
      if (isLocked) {
        sessionChangesConfirmBtn.disabled = true;
        sessionChangesConfirmBtn.style.opacity = '0.7';
        sessionChangesConfirmBtn.style.cursor = 'wait';
        // Add loading text
        const originalText = sessionChangesConfirmBtn.innerHTML;
        sessionChangesConfirmBtn.dataset.originalText = originalText;
        sessionChangesConfirmBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 6px; animation: spin 1s linear infinite;"><circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="2" fill="none" stroke-dasharray="43.98" stroke-dashoffset="10.99"/></svg>Saving...';
      } else {
        sessionChangesConfirmBtn.disabled = false;
        sessionChangesConfirmBtn.style.opacity = '';
        sessionChangesConfirmBtn.style.cursor = '';
        // Restore original text
        if (sessionChangesConfirmBtn.dataset.originalText) {
          sessionChangesConfirmBtn.innerHTML = sessionChangesConfirmBtn.dataset.originalText;
          delete sessionChangesConfirmBtn.dataset.originalText;
        }
      }
    }
    
    // Add/remove locked class for styling
    if (isLocked) {
      sessionChangesOverlay.classList.add('is-locked');
    } else {
      sessionChangesOverlay.classList.remove('is-locked');
    }
  }

  /**
   * Render session changes list in the popup
   */
  async function renderSessionChanges() {
    if (!sessionChangesList) {
      console.error('[MentorCalendar] renderSessionChanges: sessionChangesList element not found');
      return;
    }
    
    try {
      if (changedSessionsById.size === 0) {
        sessionChangesList.innerHTML = `
          <div class="session-changes-empty">
            <svg class="session-changes-empty-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <div class="session-changes-empty-text">No changes found.</div>
          </div>
        `;
        return;
      }
      
      // Fetch client names for all sessions
      const clientNameMap = new Map(); // email -> {first_name, last_name}
      try {
        const clients = await ensureClientSuggestionsLoaded();
        if (Array.isArray(clients)) {
          clients.forEach(client => {
            if (client.email) {
              clientNameMap.set(client.email.toLowerCase(), {
                first_name: client.first_name || '',
                last_name: client.last_name || ''
              });
            }
          });
        }
      } catch (e) {
        console.warn('[MentorCalendar] Could not fetch client names:', e);
      }
      
      let html = '';
      changedSessionsById.forEach((snapshot, sessionId) => {
      const original = originalSessionsById.get(sessionId);
      
      // Helper to format dates
      const formatDate = (iso) => {
        if (!iso) return 'N/A';
        if (window.luxon && window.luxon.DateTime) {
          try {
            const dt = window.luxon.DateTime.fromISO(iso).setZone(timezone_variable);
            return dt.toFormat('MMM d, yyyy  h:mm a');
          } catch (e) {
            return iso;
          }
        }
        return iso;
      };
      
      const formatTime = (iso) => {
        if (!iso) return 'N/A';
        if (window.luxon && window.luxon.DateTime) {
          try {
            const dt = window.luxon.DateTime.fromISO(iso).setZone(timezone_variable);
            return dt.toFormat('h:mm a');
          } catch (e) {
            return iso;
          }
        }
        return iso;
      };
      
      // Normalize ISO strings for comparison (handle format differences)
      const normalizeIso = (iso) => {
        if (!iso) return null;
        try {
          // Parse and re-stringify to normalize format
          return new Date(iso).toISOString();
        } catch (e) {
          return String(iso);
        }
      };
      
      // Format dates
      const snapshotStartFormatted = formatDate(snapshot.start);
      const snapshotEndFormatted = formatTime(snapshot.end);
      const originalStartFormatted = original ? formatDate(original.start) : null;
      const originalEndFormatted = original ? formatTime(original.end) : null;
      
      // Check which fields changed (with normalized date comparison)
      const normalizedSnapshotStart = normalizeIso(snapshot.start);
      const normalizedSnapshotEnd = normalizeIso(snapshot.end);
      const normalizedOriginalStart = original ? normalizeIso(original.start) : null;
      const normalizedOriginalEnd = original ? normalizeIso(original.end) : null;
      const dateTimeChanged = original && (
        normalizedSnapshotStart !== normalizedOriginalStart || 
        normalizedSnapshotEnd !== normalizedOriginalEnd
      );
      const priceChanged = original && (
        (snapshot.session_price === null && original.session_price !== null) ||
        (snapshot.session_price !== null && original.session_price === null) ||
        (snapshot.session_price !== null && original.session_price !== null && String(snapshot.session_price) !== String(original.session_price))
      );
      const statusChanged = original && snapshot.status !== original.status;
      
      // Status badges - current and future
      const currentStatus = snapshot.status || 'draft';
      const currentStatusBadgeClass = `session-changes-status-badge--${currentStatus}`;
      const currentStatusLabel = currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1);
      
      // After save, status will change to 'invited' (per requirements)
      const futureStatus = 'invited';
      const futureStatusBadgeClass = `session-changes-status-badge--${futureStatus}`;
      const futureStatusLabel = futureStatus.charAt(0).toUpperCase() + futureStatus.slice(1);
      
      // Get client name from email
      const clientEmail = (snapshot.client_email || '').toLowerCase();
      const clientInfo = clientNameMap.get(clientEmail) || { first_name: '', last_name: '' };
      const clientName = clientInfo.first_name || clientInfo.last_name 
        ? `${clientInfo.first_name} ${clientInfo.last_name}`.trim()
        : (snapshot.client_email || 'No client assigned');
      
      // Build session detail URL
      const sessionDetailUrl = SESSION_DETAIL_URL_TEMPLATE.replace('0', String(sessionId));
      
      html += `<div class="session-changes-item">`;
      html += `<div class="session-changes-item-header">`;
      html += `<div class="session-changes-item-id-wrapper">`;
      html += `<a href="${escapeHtml(sessionDetailUrl)}" class="session-changes-item-id-link" target="_blank" rel="noopener noreferrer">Session #${sessionId}</a>`;
      html += `<span class="session-changes-item-client-label">Client:</span>`;
      html += `<span class="session-changes-item-client-name">${escapeHtml(clientName)}</span>`;
      html += `</div>`;
      html += `<div class="session-changes-status-badges">`;
      html += `<span class="session-changes-status-badge ${currentStatusBadgeClass}">${escapeHtml(currentStatusLabel)}</span>`;
      html += `<svg class="session-changes-status-arrow" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z" fill="currentColor"/></svg>`;
      html += `<span class="session-changes-status-badge ${futureStatusBadgeClass}">${escapeHtml(futureStatusLabel)}</span>`;
      html += `</div>`;
      html += `</div>`;
      html += `<div class="session-changes-item-fields">`;
      
      // Date & Time field - always display
      if (dateTimeChanged && original) {
        // Show comparison when changed
        html += `<div class="session-changes-field session-changes-field-changed">`;
        html += `<div class="session-changes-field-label">`;
        html += `<svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" fill="currentColor"/></svg>`;
        html += `Date & Time</div>`;
        html += `<div class="session-changes-field-changed-content">`;
        html += `<div class="session-changes-field-old">`;
        html += `<div class="session-changes-field-old-label">Previous</div>`;
        html += `${escapeHtml(originalStartFormatted)} - ${escapeHtml(originalEndFormatted)}`;
        html += `</div>`;
        html += `<svg class="session-changes-field-arrow" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z" fill="currentColor"/></svg>`;
        html += `<div class="session-changes-field-new">`;
        html += `<div class="session-changes-field-new-label">Updated</div>`;
        html += `${escapeHtml(snapshotStartFormatted)} - ${escapeHtml(snapshotEndFormatted)}`;
        html += `</div>`;
        html += `</div>`;
        html += `</div>`;
      } else {
        // Show as normal informative data when unchanged
        html += `<div class="session-changes-field">`;
        html += `<div class="session-changes-field-label">`;
        html += `<svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" fill="currentColor"/></svg>`;
        html += `Date & Time</div>`;
        html += `<div class="session-changes-field-value">${escapeHtml(snapshotStartFormatted)} - ${escapeHtml(snapshotEndFormatted)}</div>`;
        html += `</div>`;
      }
      
      // Price field - only show if changed
      if (priceChanged && original) {
        html += `<div class="session-changes-field session-changes-field-changed">`;
        html += `<div class="session-changes-field-label">`;
        html += `<svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.433 7.418c.155-.103.346-.196.567-.267v1.698a2.305 2.305 0 01-.567-.267C8.07 8.34 8 8.114 8 8c0-.114.07-.34.433-.582zM11 12.849v-1.698c.22.071.412.164.567.267.364.243.433.468.433.582 0 .114-.07.34-.433.582a2.305 2.305 0 01-.567.267z" fill="currentColor"/><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a1 1 0 10-2 0v.092a4.535 4.535 0 00-1.676.662C6.602 6.234 6 7.009 6 8c0 .99.602 1.765 1.324 2.246.48.32 1.054.545 1.676.662v1.941c-.391-.127-.68-.317-.843-.504a1 1 0 10-1.314 1.531c.562.499 1.313.93 2.157 1.057V15a1 1 0 102 0v-.092a4.535 4.535 0 001.676-.662C13.398 13.766 14 12.991 14 12c0-.99-.602-1.765-1.324-2.246A4.535 4.535 0 0011 9.092V7.151c.391.127.68.317.843.504a1 1 0 101.314-1.531c-.562-.499-1.313-.93-2.157-1.057V5z" fill="currentColor"/></svg>`;
        html += `Price</div>`;
        html += `<div class="session-changes-field-changed-content">`;
        html += `<div class="session-changes-field-old">`;
        html += `<div class="session-changes-field-old-label">Previous</div>`;
        html += `${escapeHtml(original.session_price !== null ? String(original.session_price) : 'Free')}`;
        html += `</div>`;
        html += `<svg class="session-changes-field-arrow" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z" fill="currentColor"/></svg>`;
        html += `<div class="session-changes-field-new">`;
        html += `<div class="session-changes-field-new-label">Updated</div>`;
        html += `${escapeHtml(snapshot.session_price !== null ? String(snapshot.session_price) : 'Free')}`;
        html += `</div>`;
        html += `</div>`;
        html += `</div>`;
      }
      // If price didn't change, don't display it
      
      // Status field (only show if changed)
      if (statusChanged && original) {
        const newStatusLabel = (snapshot.status || 'draft').charAt(0).toUpperCase() + (snapshot.status || 'draft').slice(1);
        html += `<div class="session-changes-field session-changes-field-changed">`;
        html += `<div class="session-changes-field-label">`;
        html += `<svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" fill="currentColor"/></svg>`;
        html += `Status</div>`;
        html += `<div class="session-changes-field-changed-content">`;
        html += `<div class="session-changes-field-old">`;
        html += `<div class="session-changes-field-old-label">Previous</div>`;
        html += `${escapeHtml((original.status || 'draft').charAt(0).toUpperCase() + (original.status || 'draft').slice(1))}`;
        html += `</div>`;
        html += `<svg class="session-changes-field-arrow" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z" fill="currentColor"/></svg>`;
        html += `<div class="session-changes-field-new">`;
        html += `<div class="session-changes-field-new-label">Updated</div>`;
        html += `${escapeHtml(newStatusLabel)}`;
        html += `</div>`;
        html += `</div>`;
        html += `</div>`;
      }
      
      html += `</div>`;
      html += `</div>`;
      });
      
      sessionChangesList.innerHTML = html;
    } catch (error) {
      console.error('[MentorCalendar] Error rendering session changes:', error);
      sessionChangesList.innerHTML = `
        <div class="session-changes-empty">
          <svg class="session-changes-empty-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          <div class="session-changes-empty-text">Error loading changes. Please try again.</div>
        </div>
      `;
    }
  }

  /**
   * Escape HTML to prevent XSS
   */
  function escapeHtml(text) {
    if (text === null || text === undefined) return '';
    const div = document.createElement('div');
    div.textContent = String(text);
    return div.innerHTML;
  }

  // Save availability button
  if (saveBtn) {
    saveBtn.addEventListener('click', () => {
      console.log('[MentorCalendar] Save clicked. Checking for collisions and changes...');
      
      // First check for collisions
      const collisions = computeCalendarCollisionsInHorizon();
      if (collisions.length > 0) {
        const canOpenPopup = (typeof window.openCollisionResolutionPopup === 'function');
        if (canOpenPopup) {
          window.openCollisionResolutionPopup(false);
        } else if (typeof showNotification === 'function') {
          showNotification('Please resolve collisions before saving.', 'warning');
        }
        return;
      }
      
      // If no collisions, check for tracked session changes
      if (changedSessionsById.size > 0) {
        // Show changes popup
        setSessionChangesVisible(true);
      } else {
        // No changes, proceed with normal save
        saveAvailabilityToBackend();
      }
    });
  }
  
  // Session changes popup handlers
  if (sessionChangesOverlay) {
    sessionChangesOverlay.querySelectorAll('[data-session-changes-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        // Don't allow closing if save is in progress
        if (isSavingSessionChanges) {
          return;
        }
        closeSessionChanges();
      });
    });
    sessionChangesOverlay.querySelectorAll('[data-session-changes-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        // Don't allow closing if save is in progress
        if (isSavingSessionChanges) {
          return;
        }
        closeSessionChanges();
      });
    });
  }
  if (sessionChangesConfirmBtn) {
    sessionChangesConfirmBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      // Don't allow multiple clicks
      if (isSavingSessionChanges) {
        return;
      }
      
      // Lock the popup
      isSavingSessionChanges = true;
      updateSessionChangesLockState();
      
      // Proceed with save (don't close popup yet)
      await saveAvailabilityToBackend();
      
      // Unlock and close after save completes
      isSavingSessionChanges = false;
      updateSessionChangesLockState();
      closeSessionChanges();
    });
  }
  
  // ESC key handler for session changes popup
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && sessionChangesOverlay && sessionChangesOverlay.classList.contains('is-visible')) {
      // Don't allow closing if save is in progress
      if (isSavingSessionChanges) {
        e.preventDefault();
        return;
      }
      closeSessionChanges();
    }
  });

  // Availability settings popup handlers
  if (availabilitySettingsOverlay) {
    availabilitySettingsOverlay.querySelectorAll('[data-availability-settings-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySettings();
      });
    });
    availabilitySettingsOverlay.querySelectorAll('[data-availability-settings-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySettings();
      });
    });
  }
  if (availabilitySettingsSaveBtn) {
    availabilitySettingsSaveBtn.addEventListener('click', (e) => {
      e.preventDefault();
      applyAvailabilitySettings();
    });
  }

  // Switch-to-availability-mode popup handlers
  if (availabilitySwitchOverlay) {
    availabilitySwitchOverlay.querySelectorAll('[data-availability-switch-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySwitchPopup();
      });
    });
    availabilitySwitchOverlay.querySelectorAll('[data-availability-switch-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySwitchPopup();
      });
    });
  }
  if (availabilitySwitchToAvailabilityBtn) {
    availabilitySwitchToAvailabilityBtn.addEventListener('click', (e) => {
      e.preventDefault();
      switchToAvailabilityModeAndOpenSettings();
    });
  }

  // Switch-to-sessions-mode popup handlers
  if (sessionSwitchOverlay) {
    sessionSwitchOverlay.querySelectorAll('[data-session-switch-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSwitchPopup();
      });
    });
    sessionSwitchOverlay.querySelectorAll('[data-session-switch-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSwitchPopup();
      });
    });
  }
  if (sessionSwitchToSessionsBtn) {
    sessionSwitchToSessionsBtn.addEventListener('click', (e) => {
      e.preventDefault();
      switchToSessionsMode();
    });
  }

  // Session settings popup handlers
  if (sessionSettingsOverlay) {
    sessionSettingsOverlay.querySelectorAll('[data-session-settings-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSettings();
      });
    });
    sessionSettingsOverlay.querySelectorAll('[data-session-settings-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSettings();
      });
    });
  }
  if (sessionSettingsApplyBtn) {
    sessionSettingsApplyBtn.addEventListener('click', (e) => {
      e.preventDefault();
      applySessionSettings();
    });
  }

  // Refund session handlers
  function setRefundConfirmVisible(isVisible) {
    if (!sessionSettingsRefundConfirmOverlay) return;
    sessionSettingsRefundConfirmOverlay.classList.toggle('is-visible', !!isVisible);
    sessionSettingsRefundConfirmOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeRefundConfirm() {
    setRefundConfirmVisible(false);
  }

  if (sessionSettingsRefundBtn) {
    sessionSettingsRefundBtn.addEventListener('click', (e) => {
      e.preventDefault();
      const ev = calendar && sessionSettingsEventId ? calendar.getEventById(sessionSettingsEventId) : null;
      if (!ev) return;
      
      const price = ev?.extendedProps?.sessionPrice;
      if (sessionSettingsRefundConfirmPriceValue) {
        sessionSettingsRefundConfirmPriceValue.textContent = price !== null && price !== undefined 
          ? `$${String(price)}` 
          : 'Free';
      }
      setRefundConfirmVisible(true);
    });
  }

  if (sessionSettingsRefundConfirmOverlay) {
    sessionSettingsRefundConfirmOverlay.querySelectorAll('[data-refund-confirm-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeRefundConfirm();
      });
    });
    sessionSettingsRefundConfirmOverlay.querySelectorAll('[data-refund-confirm-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeRefundConfirm();
      });
    });
  }

  if (sessionSettingsRefundConfirmBtn) {
    sessionSettingsRefundConfirmBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      const ev = calendar && sessionSettingsEventId ? calendar.getEventById(sessionSettingsEventId) : null;
      if (!ev) {
        closeRefundConfirm();
        return;
      }
      
      const sessionId = ev?.extendedProps?.sessionDbId;
      if (!sessionId) {
        if (typeof showNotification === 'function') {
          showNotification('Session not found.', 'error');
        }
        closeRefundConfirm();
        return;
      }

      // Disable button and show loading
      sessionSettingsRefundConfirmBtn.disabled = true;
      sessionSettingsRefundConfirmBtn.style.opacity = '0.7';
      sessionSettingsRefundConfirmBtn.style.cursor = 'wait';
      const originalText = sessionSettingsRefundConfirmBtn.textContent;
      sessionSettingsRefundConfirmBtn.textContent = 'Processing...';

      const csrf = getCookie('csrftoken');
      try {
        const res = await fetch(REFUND_SESSION_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrf || '' },
          body: JSON.stringify({ session_id: sessionId })
        });
        const data = await res.json();
        if (data && data.success) {
          if (typeof showNotification === 'function') {
            showNotification('Session refunded successfully.', 'success');
          }
          closeRefundConfirm();
          closeSessionSettings();
          // Reload calendar to reflect status change
          await loadSavedAvailability();
        } else {
          if (typeof showNotification === 'function') {
            showNotification(data?.error || 'Could not refund session.', 'error');
          }
          // Re-enable button on error
          sessionSettingsRefundConfirmBtn.disabled = false;
          sessionSettingsRefundConfirmBtn.style.opacity = '';
          sessionSettingsRefundConfirmBtn.style.cursor = '';
          sessionSettingsRefundConfirmBtn.textContent = originalText;
        }
      } catch (err) {
        if (typeof showNotification === 'function') {
          showNotification('Could not refund session.', 'error');
        }
        // Re-enable button on error
        sessionSettingsRefundConfirmBtn.disabled = false;
        sessionSettingsRefundConfirmBtn.style.opacity = '';
        sessionSettingsRefundConfirmBtn.style.cursor = '';
        sessionSettingsRefundConfirmBtn.textContent = originalText;
      }
    });
  }

  // ESC key handler for refund confirmation dialog
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && sessionSettingsRefundConfirmOverlay && sessionSettingsRefundConfirmOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeRefundConfirm();
    }
  });

  // Schedule session popup handlers
  if (scheduleSessionOverlay) {
    scheduleSessionOverlay.querySelectorAll('[data-schedule-session-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeScheduleSessionPopup();
      });
    });
  }
  if (scheduleSessionSendBtn) {
    scheduleSessionSendBtn.addEventListener('click', (e) => {
      e.preventDefault();
      sendScheduleSessionEmail();
    });
  }

  // Close handlers
  overlay.querySelectorAll('[data-mentor-calendar-close]').forEach(el => {
    el.addEventListener('click', attemptClose);
  });
  
  document.addEventListener('keydown', (e) => {
    if (e.key !== 'Escape') return;
    if (!overlay.classList.contains('is-visible')) return;

    // Priority: close settings popups first, then switch popups, then the calendar popup.
    if (availabilitySettingsOverlay && availabilitySettingsOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeAvailabilitySettings();
      return;
    }
    if (sessionSettingsOverlay && sessionSettingsOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeSessionSettings();
      return;
    }
    if (scheduleSessionOverlay && scheduleSessionOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeScheduleSessionPopup();
      return;
    }
    if (recurringMoveOverlay && recurringMoveOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      cancelRecurringMove();
      return;
    }
    if (recurringDeleteOverlay && recurringDeleteOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      setRecurringDeleteVisible(false);
      pendingRecurringDelete = null;
      return;
    }
    if (unsavedChangesOverlay && unsavedChangesOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeUnsavedChangesPopup();
      return;
    }
    if (availabilitySwitchOverlay && availabilitySwitchOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeAvailabilitySwitchPopup();
      return;
    }
    if (sessionSwitchOverlay && sessionSwitchOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeSessionSwitchPopup();
      return;
    }
    attemptClose();
  });

  // Unsaved changes popup handlers
  if (unsavedChangesOverlay) {
    unsavedChangesOverlay.querySelectorAll('[data-unsaved-changes-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeUnsavedChangesPopup();
      });
    });
    unsavedChangesOverlay.querySelectorAll('[data-unsaved-changes-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeUnsavedChangesPopup();
      });
    });
  }
  if (unsavedChangesDiscardBtn) {
    unsavedChangesDiscardBtn.addEventListener('click', (e) => {
      e.preventDefault();
      closeNow();
    });
  }

  // Recurring delete popup helpers/handlers
  function setRecurringDeleteVisible(isVisible) {
    if (!recurringDeleteOverlay) return;
    recurringDeleteOverlay.classList.toggle('is-visible', !!isVisible);
    recurringDeleteOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function openRecurringDeletePopup(payload) {
    pendingRecurringDelete = payload || null;
    setRecurringDeleteVisible(true);
  }

  function deleteRecurringOccurrenceOnly() {
    const p = pendingRecurringDelete;
    if (!p || !calendar) {
      setRecurringDeleteVisible(false);
      pendingRecurringDelete = null;
      return;
    }
    const rule = recurringAvailabilityRules.get(p.recurringId);
    if (rule && p.instanceDate) {
      rule.skip_dates = Array.isArray(rule.skip_dates) ? rule.skip_dates : [];
      if (!rule.skip_dates.includes(p.instanceDate)) rule.skip_dates.push(p.instanceDate);
      recurringAvailabilityRules.set(p.recurringId, rule);
    }
    const ev = calendar.getEventById(p.eventId);
    if (ev) ev.remove();
    markDirty('availability');
    renderRecurringInstancesForCurrentView();
    recomputeCollisions();
    setRecurringDeleteVisible(false);
    pendingRecurringDelete = null;
  }

  function deleteRecurringSeries() {
    const p = pendingRecurringDelete;
    if (!p || !calendar) {
      setRecurringDeleteVisible(false);
      pendingRecurringDelete = null;
      return;
    }
    const existing = recurringAvailabilityRules.get(p.recurringId);
    if (existing) deletedRecurringRules.set(p.recurringId, existing);
    recurringAvailabilityRules.delete(p.recurringId);
    if (window.MentorCalendarRecurrenceSelections) delete window.MentorCalendarRecurrenceSelections[p.recurringId];

    // Remove all rendered instances for this recurringId
    calendar.getEvents().forEach(ev => {
      if (ev.extendedProps?.recurringId === p.recurringId || String(ev.id || '').startsWith(p.recurringId + '__')) {
        ev.remove();
      }
    });

    markDirty('availability');
    renderRecurringInstancesForCurrentView();
    recomputeCollisions();
    setRecurringDeleteVisible(false);
    pendingRecurringDelete = null;
  }

  if (recurringDeleteOverlay) {
    recurringDeleteOverlay.querySelectorAll('[data-recurring-delete-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        setRecurringDeleteVisible(false);
        pendingRecurringDelete = null;
      });
    });
    recurringDeleteOverlay.querySelectorAll('[data-recurring-delete-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        setRecurringDeleteVisible(false);
        pendingRecurringDelete = null;
      });
    });
  }
  if (recurringDeleteOneBtn) {
    recurringDeleteOneBtn.addEventListener('click', (e) => {
      e.preventDefault();
      deleteRecurringOccurrenceOnly();
    });
  }
  if (recurringDeleteAllBtn) {
    recurringDeleteAllBtn.addEventListener('click', (e) => {
      e.preventDefault();
      deleteRecurringSeries();
    });
  }

  // Recurring move popup helpers/handlers
  function setRecurringMoveVisible(isVisible) {
    if (!recurringMoveOverlay) return;
    recurringMoveOverlay.classList.toggle('is-visible', !!isVisible);
    recurringMoveOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function setRecurringMoveAllButtonLabel(label) {
    if (!recurringMoveAllBtn) return;
    recurringMoveAllBtn.textContent = label || 'All';
  }

  function cancelRecurringMove() {
    pendingRecurringMove = null;
    setRecurringMoveAllButtonLabel('All');
    setRecurringMoveVisible(false);
  }

  function applyRecurringMoveAll() {
    const p = pendingRecurringMove;
    if (!p) return cancelRecurringMove();
    const rule = recurringAvailabilityRules.get(p.recurringId);
    if (!rule || !(window.luxon && window.luxon.DateTime)) return cancelRecurringMove();

    const newStart = window.luxon.DateTime.fromISO(p.newStartIso, { zone: 'utc' }).setZone(timezone_variable);
    const newEnd = window.luxon.DateTime.fromISO(p.newEndIso, { zone: 'utc' }).setZone(timezone_variable);
    if (!newStart.isValid || !newEnd.isValid || newEnd <= newStart) return cancelRecurringMove();

    // Change all future slots:
    // - Materialize occurrences from TODAY (mentor timezone) up to the split point (exclusive) into one-time slots
    //   Split point:
    //   - if moving the occurrence later into the future: use the OLD occurrence date (instanceDate) (so we don't fill the gap)
    //   - otherwise: use the NEW start date (drag target)
    // - Update the recurring rule to start at the new date/time
    // - Reset skip_dates (and we ignore booked_dates per your direction)
    const todayLocal = window.luxon.DateTime.now().setZone(timezone_variable).startOf('day');
    const newStartDate = newStart.toISODate(); // local date of the dragged occurrence
    const newStartDay = window.luxon.DateTime.fromISO(newStartDate, { zone: timezone_variable }).startOf('day');
    const oldInstanceDay = p.instanceDate
      ? window.luxon.DateTime.fromISO(String(p.instanceDate), { zone: timezone_variable }).startOf('day')
      : null;

    // Helper: does rule match a given date?
    const matchesRuleOnDate = (ruleObj, dateStr) => {
      if (!ruleObj || !ruleObj.type) return false;
      if (ruleObj.start_date && dateStr < ruleObj.start_date) return false;
      if (Array.isArray(ruleObj.skip_dates) && ruleObj.skip_dates.includes(dateStr)) return false;

      if (ruleObj.type === 'daily') return true;
      if (ruleObj.type === 'weekly') {
        const wd = weekdayNameFromIsoDate(dateStr);
        return Array.isArray(ruleObj.weekdays) ? ruleObj.weekdays.includes(wd) : false;
      }
      if (ruleObj.type === 'monthly') {
        const dom = Number(ruleObj.day_of_month);
        if (!Number.isFinite(dom) || dom < 1) return false;
        const d = window.luxon.DateTime.fromISO(dateStr, { zone: timezone_variable });
        if (!d.isValid) return false;
        const daysInMonth = d.daysInMonth;
        const targetDay = dom > daysInMonth ? daysInMonth : dom;
        return d.day === targetDay;
      }
      return false;
    };

    // Materialize from max(today, rule.start_date) to newStartDate (exclusive)
    let cursor = todayLocal;
    if (rule.start_date) {
      const rs = window.luxon.DateTime.fromISO(String(rule.start_date), { zone: timezone_variable }).startOf('day');
      if (rs.isValid && cursor < rs) cursor = rs;
    }
    // If moved later (newStartDay > oldInstanceDay), end at oldInstanceDay (exclusive).
    // Otherwise end at newStartDay (exclusive).
    let endExclusive = newStartDay;
    if (oldInstanceDay && oldInstanceDay.isValid && newStartDay.isValid && newStartDay > oldInstanceDay) {
      endExclusive = oldInstanceDay;
    }

    while (cursor < endExclusive) {
      const dStr = cursor.toISODate();
      if (matchesRuleOnDate(rule, dStr)) {
        const startDt = window.luxon.DateTime.fromISO(`${dStr}T${rule.start_time}`, { zone: timezone_variable });
        const endDt = window.luxon.DateTime.fromISO(`${dStr}T${rule.end_time}`, { zone: timezone_variable });
        if (startDt.isValid && endDt.isValid && endDt > startDt) {
          const newId = generateClientId('availability');
          calendar.addEvent({
            id: newId,
            start: startDt.toJSDate(),
            end: endDt.toJSDate(),
            allDay: false,
            backgroundColor: '#3b82f6',
            borderColor: '#2563eb',
            textColor: '#ffffff',
            classNames: ['event-type-availability'],
            editable: true,
            extendedProps: { slotMode: 'availability', type: 'availability_slot' }
          });
        }
      }
      cursor = cursor.plus({ days: 1 });
    }

    // Update recurring rule forward from the dragged occurrence (new date + time)
    rule.start_date = newStartDate;
    rule.start_time = newStart.toFormat('HH:mm');
    rule.end_time = newEnd.toFormat('HH:mm');
    rule.skip_dates = [];

    // If the move changed the day, update weekly/monthly pattern accordingly
    if (rule.type === 'weekly') {
      const wd = weekdayNameFromIsoDate(newStartDate);
      rule.weekdays = wd ? [wd] : (rule.weekdays || []);
      rule.day_of_month = null;
    } else if (rule.type === 'monthly') {
      rule.day_of_month = newStart.day;
      rule.weekdays = [];
    }

    recurringAvailabilityRules.set(p.recurringId, rule);
    markDirty('availability');
    renderRecurringInstancesForCurrentView();
    recomputeCollisions();
    cancelRecurringMove();
  }

  function applyRecurringMoveOne() {
    const p = pendingRecurringMove;
    if (!p || !calendar) return cancelRecurringMove();

    // 1) Skip original occurrence date in the series
    const rule = recurringAvailabilityRules.get(p.recurringId);
    if (rule && p.instanceDate) {
      rule.skip_dates = Array.isArray(rule.skip_dates) ? rule.skip_dates : [];
      if (!rule.skip_dates.includes(p.instanceDate)) rule.skip_dates.push(p.instanceDate);
      recurringAvailabilityRules.set(p.recurringId, rule);
    }

    // 2) Add a new one-time availability slot at the new position
    const newId = generateClientId('availability');
    calendar.addEvent({
      id: newId,
      start: p.newStartIso,
      end: p.newEndIso,
      allDay: false,
      backgroundColor: '#3b82f6',
      borderColor: '#2563eb',
      textColor: '#ffffff',
      classNames: ['event-type-availability'],
      editable: true,
      extendedProps: { slotMode: 'availability', type: 'availability_slot' }
    });

    markDirty('availability');
    renderRecurringInstancesForCurrentView();
    recomputeCollisions();
    cancelRecurringMove();
  }

  if (recurringMoveOverlay) {
    recurringMoveOverlay.querySelectorAll('[data-recurring-move-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        cancelRecurringMove();
      });
    });
    recurringMoveOverlay.querySelectorAll('[data-recurring-move-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        cancelRecurringMove();
      });
    });
  }
  if (recurringMoveOneBtn) {
    recurringMoveOneBtn.addEventListener('click', (e) => {
      e.preventDefault();
      applyRecurringMoveOne();
    });
  }
  if (recurringMoveAllBtn) {
    recurringMoveAllBtn.addEventListener('click', (e) => {
      e.preventDefault();
      applyRecurringMoveAll();
    });
  }

  // Public API
  window.MentorCalendar = { open, close };

  document.querySelectorAll('[data-open-mentor-calendar]').forEach(el => {
    el.addEventListener('click', (e) => {
      e.preventDefault();
      open(el);
    });
  });
})();
</script>
