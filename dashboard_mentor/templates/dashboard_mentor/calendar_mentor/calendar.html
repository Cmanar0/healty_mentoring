{% load static %}

{# Entry-point popup template. Include this from a page via: {% include "dashboard_mentor/calendar_mentor/calendar.html" %} #}

<div id="mentorCalendarOverlay" class="mentor-calendar-overlay" aria-hidden="true">
  <div class="mentor-calendar-backdrop" data-mentor-calendar-close></div>

  <div class="mentor-calendar-modal" role="dialog" aria-modal="true" aria-label="Calendar">
    <header class="mentor-calendar-header">
      <div class="mentor-calendar-date-group">
        <h2 id="mentorCalendarDateDisplay">Loading...</h2>
      </div>

      <div class="mentor-calendar-controls">
        <div class="mentor-calendar-nav">
          <button class="calendar-nav-btn" data-calendar-nav="prev" aria-label="Previous">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <button class="calendar-nav-btn" data-calendar-nav="today" aria-label="Today">Today</button>
          <button class="calendar-nav-btn" data-calendar-nav="next" aria-label="Next">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>

        <div class="mentor-calendar-view-toggle">
          <button class="view-toggle-btn" data-calendar-view="timeGridDay">Day</button>
          <button class="view-toggle-btn is-active" data-calendar-view="timeGridWeek">Week</button>
          <button class="view-toggle-btn" data-calendar-view="dayGridMonth">Month</button>
        </div>

        <div class="mentor-calendar-mode-toggle" aria-label="Mode toggle">
          <button type="button" id="mentorCalendarModeSessions" class="mode-toggle-btn is-active" data-mode="sessions">
            Sessions
          </button>
          <button type="button" id="mentorCalendarModeAvailability" class="mode-toggle-btn" data-mode="availability">
            Availability
          </button>
        </div>

        <button type="button" id="mentorCalendarSaveBtn" class="mentor-calendar-save-btn" aria-label="Save availability" aria-busy="false">
          <span class="btn-label">Save</span>
          <span class="btn-spinner" aria-hidden="true"></span>
        </button>

        <button type="button" class="mentor-calendar-close" data-mentor-calendar-close aria-label="Close">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </header>

    <div class="mentor-calendar-body">
      <div id="mentorCalendarRoot" class="mentor-calendar-root"></div>
    </div>
  </div>
</div>

{% include "dashboard_mentor/calendar_mentor/Session_slot.html" %}
{% include "dashboard_mentor/calendar_mentor/Availability_Slot.html" %}
{% include "dashboard_mentor/calendar_mentor/availability_settings.html" %}
{% include "dashboard_mentor/calendar_mentor/availability_switch_mode_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/session_switch_mode_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/session_settings.html" %}
{% include "dashboard_mentor/calendar_mentor/schedule_session_popup.html" %}

<style>
  /* --- Overlay --- */
  .mentor-calendar-overlay {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(15, 23, 42, 0.6);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    z-index: 9999;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
  }
  .mentor-calendar-overlay.is-visible {
    opacity: 1;
    visibility: visible;
  }
  .mentor-calendar-backdrop {
    position: absolute;
    inset: 0;
  }

  /* --- Modal --- */
  .mentor-calendar-modal {
    background: #ffffff;
    width: 95%;
    max-width: 1400px;
    height: 90vh;
    border-radius: 24px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 
      0 25px 50px -12px rgba(0, 0, 0, 0.25),
      0 0 0 1px rgba(0, 0, 0, 0.05);
    transform: translateY(20px);
    transition: transform 0.3s ease, opacity 0.3s ease;
    opacity: 0;
  }
  .mentor-calendar-overlay.is-visible .mentor-calendar-modal {
    transform: translateY(0);
    opacity: 1;
  }

  /* --- Header --- */
  .mentor-calendar-header {
    padding: 20px 32px;
    background: #ffffff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 24px;
    border-bottom: 1px solid #f1f5f9;
  }

  /* Date Display (Left) */
  .mentor-calendar-date-group h2 {
    margin: 0;
    font-size: 1.5rem;
    font-weight: 700;
    color: #0f172a;
    letter-spacing: -0.025em;
    line-height: 1.2;
    min-width: 200px; /* Prevent jumping */
  }

  /* Controls Group (Right) */
  .mentor-calendar-controls {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  /* Nav Buttons */
  .mentor-calendar-nav {
    display: flex;
    align-items: center;
    gap: 4px;
    background: #f8fafc;
    padding: 4px;
    border-radius: 12px;
    border: 1px solid #e2e8f0;
  }

  .calendar-nav-btn {
    border: none;
    background: transparent;
    width: 32px;
    height: 32px;
    border-radius: 8px;
    cursor: pointer;
    color: #64748b;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    padding: 0;
  }

  .calendar-nav-btn[data-calendar-nav="today"] {
    width: auto;
    padding: 0 12px;
    font-size: 0.875rem;
    font-weight: 600;
    color: #475569;
  }

  .calendar-nav-btn:hover {
    background: #ffffff;
    color: #0f172a;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
  }

  /* View Toggle (Segmented Control) */
  .mentor-calendar-view-toggle {
    min-width: 245px;
    display: flex;
    align-items: center;
    background: #f1f5f9;
    border-radius: 10px;
    padding: 4px;
    gap: 5px;
    border: 1px solid #e2e8f0;
  }

  .view-toggle-btn {
    padding: 6px 16px;
    border: none;
    cursor: pointer;
    border-radius: 8px;
    background: transparent;
    color: #64748b;
    font-size: 0.875rem;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  .view-toggle-btn:hover:not(.is-active) {
    color: #334155;
    background: rgba(0,0,0,0.03);
  }

  .view-toggle-btn.is-active {
    background: #334156;
    color: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    font-weight: 600;
  }

  /* Sessions / Availability toggle */
  .mentor-calendar-mode-toggle {
    display: flex;
    align-items: center;
    background: #f1f5f9;
    border-radius: 10px;
    padding: 4px;
    border: 1px solid #e2e8f0;
    gap: 4px;
  }
  .mode-toggle-btn {
    padding: 6px 14px;
    border: none;
    cursor: pointer;
    border-radius: 8px;
    background: transparent;
    color: #64748b;
    font-size: 0.875rem;
    font-weight: 600;
    transition: all 0.2s ease;
    white-space: nowrap;
  }
  .mode-toggle-btn:hover:not(.is-active) {
    color: #334155;
    background: rgba(0,0,0,0.03);
  }
  .mode-toggle-btn.is-active[data-mode="sessions"] {
    background: #10b981; /* green */
    color: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }
  .mode-toggle-btn.is-active[data-mode="availability"] {
    background: #3b82f6; /* blue */
    color: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  /* Save button */
  .mentor-calendar-save-btn {
    height: 40px;
    padding: 0 14px;
    border-radius: 10px;
    border: 1px solid #e2e8f0;
    background: #0f172a;
    color: #ffffff;
    font-size: 0.875rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 96px; /* prevent width shift when loading spinner shows */
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
  .mentor-calendar-save-btn:hover {
    background: #111827;
  }
  .mentor-calendar-save-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .mentor-calendar-save-btn .btn-spinner {
    display: none;
    width: 16px;
    height: 16px;
    border-radius: 999px;
    border: 2px solid rgba(255, 255, 255, 0.35);
    border-top-color: currentColor;
    animation: mentor-save-spin 0.8s linear infinite;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  .mentor-calendar-save-btn.is-loading {
    cursor: wait;
  }
  .mentor-calendar-save-btn.is-loading .btn-label {
    visibility: hidden;
  }
  .mentor-calendar-save-btn.is-loading .btn-spinner {
    display: inline-block;
  }

  @keyframes mentor-save-spin {
    to { transform: translate(-50%, -50%) rotate(360deg); }
  }

  /* Close Button */
  .mentor-calendar-close {
    border: none;
    background: transparent;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    color: #94a3b8;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    margin-left: 8px;
  }

  .mentor-calendar-close:hover {
    background: #fee2e2;
    color: #ef4444;
    transform: rotate(90deg);
  }

  /* --- Body --- */
  .mentor-calendar-body {
    flex: 1;
    min-height: 0;
    background: #f8fafc;
    position: relative;
    padding: 0;
  }

  .mentor-calendar-root {
    height: 100%;
    background: #ffffff;
  }

  /* --- FullCalendar Overrides (Matching Availability Popup) --- */
  .mentor-calendar-root {
    font-family: inherit;
    --fc-border-color: #cbd5e1;
    --fc-page-bg-color: #ffffff;
    --fc-neutral-bg-color: #f8fafc;
    --fc-today-bg-color: #fefce8;
    --fc-now-indicator-color: #ef4444;
    /* Ensure slots have consistent rounding everywhere (wrapper + inner) */
    --mentor-calendar-slot-radius: 10px;
  }

  /* Headers */
  .mentor-calendar-root .fc-theme-standard th {
    border: 1px solid var(--fc-border-color);
    background: #f8fafc;
    padding: 12px 0;
  }

  .mentor-calendar-root .fc-col-header-cell-cushion {
    color: #64748b;
    font-weight: 600;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  /* Time Labels */
  .mentor-calendar-root .fc-timegrid-axis-cushion,
  .mentor-calendar-root .fc-timegrid-slot-label-cushion {
    color: #64748b;
    font-size: 0.75rem;
    font-weight: 500;
  }

  /* Strictly enforce 1px borders everywhere to match popup */
  .mentor-calendar-root .fc-theme-standard td, 
  .mentor-calendar-root .fc-theme-standard th,
  .mentor-calendar-root .fc-scrollgrid,
  .mentor-calendar-root .fc-timegrid-col,
  .mentor-calendar-root .fc-daygrid-day-frame {
    border: 1px solid var(--fc-border-color) !important;
  }

  /* Prevent double borders in month view */
  .mentor-calendar-root .fc-daygrid-day-frame {
    border: none !important; 
  }
  .mentor-calendar-root .fc-daygrid-day {
    border: 1px solid var(--fc-border-color) !important;
  }

  /* TimeGrid "drop rows" (FullCalendar time slots)
     - slotDuration controls how many rows per hour
     - snapDuration controls drag/drop snapping
  */
  .mentor-calendar-root .fc-timegrid-slot,
  .mentor-calendar-root .fc-timegrid-slot table,
  .mentor-calendar-root .fc-timegrid-slot tr,
  .mentor-calendar-root .fc-timegrid-slot td,
  .mentor-calendar-root .fc-timegrid-slot-lane,
  .mentor-calendar-root .fc-timegrid-slot-lane table,
  .mentor-calendar-root .fc-timegrid-slot-lane tr,
  .mentor-calendar-root .fc-timegrid-slot-lane td {
    height: 9px !important;       /* 5-min row height */
    min-height: 9px !important;
    max-height: 9px !important;
    line-height: 9px !important;
  }

  .mentor-calendar-root table.fc-timegrid-slots tr td {
    padding: 0 !important;
  }

  /* Hide horizontal borders for 5-min rows (we keep strong hour lines instead) */
  .mentor-calendar-root .fc-timegrid-slot {
    border-top: 1px solid #cbd5e12b !important;
    border-bottom: none !important;
  }
  
  /* Class we'll add via JS for strong hour lines */
  .mentor-calendar-root .fc-hour-slot {
    border-top: 1px solid var(--fc-border-color) !important;
  }

  /* --- Dynamic Slot Styling based on Mode --- */

  /* Base Event Styles (handled by FullCalendar inline styles usually, but we set overrides) */
  .mentor-calendar-root .fc-event,
  .mentor-calendar-root .fc-timegrid-event,
  .mentor-calendar-root .fc-daygrid-event {
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    border-width: 2px !important;
    border-style: solid !important;
    border-radius: var(--mentor-calendar-slot-radius) !important;
    overflow: hidden; /* keep slot content fully inside the event */
  }

  /* Inner slot content should match the event wrapper radius */
  .mentor-calendar-root .mentor-calendar-slot {
    height: 100% !important;
    border-radius: var(--mentor-calendar-slot-radius);
    box-sizing: border-box;
  }

  /* When a slot dropdown is open, lift the event above neighbors */
  .mentor-calendar-root .fc-event.is-dropdown-open,
  .mentor-calendar-root .fc-timegrid-event.is-dropdown-open,
  .mentor-calendar-root .fc-daygrid-event.is-dropdown-open {
    /* FullCalendar may set z-index inline; force override */
    z-index: 20000 !important;
  }

  /* 
     Mode: SESSIONS (Default) 
     - Session Slots (Green): Normal
     - Availability Slots (Grey): Disabled/Ghost
  */
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability {
    background-color: #f1f5f9 !important; /* Slate-100 */
    border-color: #cbd5e1 !important;     /* Slate-300 */
    opacity: 0.8;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .fc-event-main,
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .fc-event-time,
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .fc-event-title, 
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability [data-slot-time] {
    color: #94a3b8 !important; /* Slate-400 */
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-slot-title {
    color: #94a3b8 !important; /* Slate-400 */
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-slot-delete {
    display: none !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-slot-duration {
    color: #94a3b8 !important; /* Slate-400 */
    opacity: 0.8 !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-recurrence-trigger {
    background: #f1f5f9 !important; /* Slate-100 */
    border-color: #cbd5e1 !important; /* Slate-300 */
    color: #94a3b8 !important; /* Slate-400 */
    pointer-events: none !important; /* Lock dropdown */
    box-shadow: none !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-recurrence-chevron {
    opacity: 0.5 !important;
  }

  /* 
     Mode: AVAILABILITY 
     - Session Slots (Grey): Disabled/Ghost
     - Availability Slots (Blue): Normal
  */
  .mentor-calendar-root.is-mode-availability .event-type-session {
    background-color: #f1f5f9 !important; /* Slate-100 */
    border-color: #cbd5e1 !important;     /* Slate-300 */
    opacity: 0.8;
  }
  .mentor-calendar-root.is-mode-availability .event-type-session .fc-event-main,
  .mentor-calendar-root.is-mode-availability .event-type-session .fc-event-time,
  .mentor-calendar-root.is-mode-availability .event-type-session .fc-event-title,
  .mentor-calendar-root.is-mode-availability .event-type-session [data-slot-time] {
    color: #94a3b8 !important; /* Slate-400 */
  }
  .mentor-calendar-root.is-mode-availability .event-type-session .mentor-calendar-slot-title {
    color: #94a3b8 !important; /* Slate-400 */
  }

  /* --- Collision styling (red) --- */
  .mentor-calendar-root .fc-event.is-collision,
  .mentor-calendar-root .fc-timegrid-event.is-collision,
  .mentor-calendar-root .fc-daygrid-event.is-collision {
    background-color: #ef4444 !important; /* red-500 */
    border-color: #b91c1c !important;     /* red-700 */
    opacity: 1 !important;
  }
  .mentor-calendar-root .fc-event.is-collision .fc-event-main,
  .mentor-calendar-root .fc-event.is-collision .fc-event-time,
  .mentor-calendar-root .fc-event.is-collision .fc-event-title,
  .mentor-calendar-root .fc-event.is-collision [data-slot-time],
  .mentor-calendar-root .fc-event.is-collision .mentor-calendar-slot-title {
    color: #ffffff !important;
  }

  /* Sessions mode: availability hover is light + clickable */
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability {
    cursor: pointer;
  }
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover {
    background-color: #dbeafe !important;
    border-color: #93c5fd !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover .mentor-calendar-slot,
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover .mentor-calendar-slot-title,
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover [data-slot-time] {
    color: #0f172a !important;
  }

</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.css">
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/locales-all.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fullcalendar/interaction@6.1.10/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fullcalendar/luxon3@6.1.10/index.global.min.js"></script>

<script>
(function() {
  const overlay = document.getElementById('mentorCalendarOverlay');
  const root = document.getElementById('mentorCalendarRoot');
  const dateDisplay = document.getElementById('mentorCalendarDateDisplay');
  const saveBtn = document.getElementById('mentorCalendarSaveBtn');
  const modeSessionsBtn = document.getElementById('mentorCalendarModeSessions');
  const modeAvailabilityBtn = document.getElementById('mentorCalendarModeAvailability');
  const sessionSlotTpl = document.getElementById('mentorCalendarSessionSlotTemplate');
  const availabilitySlotTpl = document.getElementById('mentorCalendarAvailabilitySlotTemplate');

  // Availability settings popup (opens on dblclick availability slot)
  const availabilitySettingsOverlay = document.getElementById('mentorAvailabilitySettingsOverlay');
  const availabilitySettingsDateInput = document.getElementById('availabilitySettingsDate');
  const availabilitySettingsTimeInput = document.getElementById('availabilitySettingsTime');
  const availabilitySettingsDurationMinutesEl = document.getElementById('availabilitySettingsDurationMinutes');
  const availabilitySettingsSaveBtn = document.getElementById('availabilitySettingsSaveBtn');
  const availabilitySwitchOverlay = document.getElementById('mentorAvailabilitySwitchModeOverlay');
  const availabilitySwitchToAvailabilityBtn = document.getElementById('availabilitySwitchToAvailabilityBtn');
  const sessionSwitchOverlay = document.getElementById('mentorSessionSwitchModeOverlay');
  const sessionSwitchToSessionsBtn = document.getElementById('sessionSwitchToSessionsBtn');
  const sessionSettingsOverlay = document.getElementById('mentorSessionSettingsOverlay');
  const sessionSettingsDateInput = document.getElementById('sessionSettingsDate');
  const sessionSettingsTimeInput = document.getElementById('sessionSettingsTime');
  const sessionSettingsApplyBtn = document.getElementById('sessionSettingsApplyBtn');
  const scheduleSessionOverlay = document.getElementById('mentorScheduleSessionOverlay');
  const scheduleSessionEmailInput = document.getElementById('scheduleSessionEmailInput');
  const scheduleSessionSendBtn = document.getElementById('scheduleSessionSendBtn');
  
  if (!overlay || !root) return;

  let calendar = null;
  let availabilitySettingsEventId = null;
  let availabilitySwitchEventId = null;
  let availabilitySwitchOpenSettingsAfterSwitch = false;
  let sessionSwitchEventId = null;
  let sessionSwitchOpenSettingsAfterSwitch = false;
  let sessionSettingsEventId = null;
  let scheduleSessionEventId = null;

  // Timezone source of truth: mentorprofile.selected_timezone (fallback: detected_timezone)
  function resolveMentorTimezone() {
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const data = JSON.parse(dataEl.textContent);
        const selected = (data.selected_timezone || '').trim();
        const detected = (data.detected_timezone || '').trim();
        const tz = selected || detected || 'UTC';
        // Only accept IANA IDs or UTC
        if (tz === 'UTC' || tz.includes('/')) return tz;
      }
    } catch (e) {
      console.warn('[MentorCalendar] Could not parse userProfileData for timezone:', e);
    }
    return 'UTC';
  }

  // Slot length source of truth: mentorprofile.session_length (minutes)
  function resolveMentorSessionLengthMinutes() {
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const data = JSON.parse(dataEl.textContent);
        const raw = data?.session_length;
        const minutes = Number.parseInt(raw, 10);
        if (Number.isFinite(minutes) && minutes > 0 && minutes <= 24 * 60) return minutes;
      }
    } catch (e) {
      console.warn('[MentorCalendar] Could not parse userProfileData for session_length:', e);
    }
    return 60;
  }

  // Calendar timezone variable (used by FullCalendar init + save grouping)
  let timezone_variable = resolveMentorTimezone();

  // --- Availability settings popup helpers ---
  function setAvailabilitySettingsVisible(isVisible) {
    if (!availabilitySettingsOverlay) return;
    availabilitySettingsOverlay.classList.toggle('is-visible', !!isVisible);
    availabilitySettingsOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeAvailabilitySettings() {
    availabilitySettingsEventId = null;
    setAvailabilitySettingsVisible(false);
  }

  function openAvailabilitySettingsForEvent(fcEvent) {
    if (!availabilitySettingsOverlay || !fcEvent) return;
    if (!availabilitySettingsDateInput || !availabilitySettingsTimeInput) return;

    availabilitySettingsEventId = fcEvent.id || null;

    // Duration comes from mentor profile session_length
    const durationMinutes = resolveMentorSessionLengthMinutes();
    if (availabilitySettingsDurationMinutesEl) {
      availabilitySettingsDurationMinutesEl.textContent = String(durationMinutes);
    }

    // Populate start date/time in the calendar timezone
    try {
      if (window.luxon && window.luxon.DateTime && fcEvent.start) {
        const dt = window.luxon.DateTime.fromJSDate(fcEvent.start).setZone(timezone_variable);
        availabilitySettingsDateInput.value = dt.toISODate();      // YYYY-MM-DD
        availabilitySettingsTimeInput.value = dt.toFormat('HH:mm'); // 24h time
      }
    } catch (e) {
      console.warn('[MentorCalendar] Could not prefill availability settings:', e);
    }

    setAvailabilitySettingsVisible(true);
  }

  function applyAvailabilitySettings() {
    if (!calendar) return;
    if (!availabilitySettingsEventId) return;
    if (!availabilitySettingsDateInput || !availabilitySettingsTimeInput) return;

    const ev = calendar.getEventById(availabilitySettingsEventId);
    if (!ev) {
      closeAvailabilitySettings();
      return;
    }

    const dateStr = (availabilitySettingsDateInput.value || '').trim();
    const timeStr = (availabilitySettingsTimeInput.value || '').trim();
    if (!dateStr || !timeStr) {
      if (typeof showNotification === 'function') {
        showNotification('Please choose a date and time.', 'error');
      } else {
        alert('Please choose a date and time.');
      }
      return;
    }

    if (!(window.luxon && window.luxon.DateTime)) {
      console.warn('[MentorCalendar] Luxon is required for availability settings editing.');
      return;
    }

    const durationMinutes = resolveMentorSessionLengthMinutes();
    const dt = window.luxon.DateTime.fromISO(`${dateStr}T${timeStr}`, { zone: timezone_variable });
    if (!dt.isValid) {
      if (typeof showNotification === 'function') {
        showNotification('Invalid date/time.', 'error');
      } else {
        alert('Invalid date/time.');
      }
      return;
    }

    const startJs = dt.toJSDate();
    const endJs = dt.plus({ minutes: durationMinutes }).toJSDate();

    ev.setStart(startJs);
    ev.setEnd(endJs);

    markDirty('availability');
    recomputeCollisions();
    closeAvailabilitySettings();
  }

  // --- Switch-to-availability-mode popup helpers ---
  function setAvailabilitySwitchVisible(isVisible) {
    if (!availabilitySwitchOverlay) return;
    availabilitySwitchOverlay.classList.toggle('is-visible', !!isVisible);
    availabilitySwitchOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeAvailabilitySwitchPopup() {
    availabilitySwitchEventId = null;
    setAvailabilitySwitchVisible(false);
  }

  function openAvailabilitySwitchPopupForEventId(eventId, openSettingsAfterSwitch) {
    if (!availabilitySwitchOverlay) return;
    availabilitySwitchEventId = eventId || null;
    availabilitySwitchOpenSettingsAfterSwitch = !!openSettingsAfterSwitch;
    setAvailabilitySwitchVisible(true);
  }

  function switchToAvailabilityModeAndOpenSettings() {
    if (!calendar) return;
    const id = availabilitySwitchEventId;
    const shouldOpenSettings = !!availabilitySwitchOpenSettingsAfterSwitch;
    closeAvailabilitySwitchPopup();
    if (!id) return;

    setMode(true);
    const ev = calendar.getEventById(id);
    if (ev && shouldOpenSettings) openAvailabilitySettingsForEvent(ev);
  }

  // --- Session settings popup helpers ---
  function setSessionSettingsVisible(isVisible) {
    if (!sessionSettingsOverlay) return;
    sessionSettingsOverlay.classList.toggle('is-visible', !!isVisible);
    sessionSettingsOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeSessionSettings() {
    sessionSettingsEventId = null;
    setSessionSettingsVisible(false);
  }

  function openSessionSettingsForEvent(fcEvent) {
    if (!sessionSettingsOverlay || !fcEvent) return;
    if (!sessionSettingsDateInput || !sessionSettingsTimeInput) return;

    sessionSettingsEventId = fcEvent.id || null;

    try {
      if (window.luxon && window.luxon.DateTime && fcEvent.start) {
        const dt = window.luxon.DateTime.fromJSDate(fcEvent.start).setZone(timezone_variable);
        sessionSettingsDateInput.value = dt.toISODate();
        sessionSettingsTimeInput.value = dt.toFormat('HH:mm');
      }
    } catch (e) {
      console.warn('[MentorCalendar] Could not prefill session settings:', e);
    }

    setSessionSettingsVisible(true);
  }

  function applySessionSettings() {
    if (!calendar) return;
    if (!sessionSettingsEventId) return;
    if (!sessionSettingsDateInput || !sessionSettingsTimeInput) return;

    const ev = calendar.getEventById(sessionSettingsEventId);
    if (!ev) {
      closeSessionSettings();
      return;
    }

    const dateStr = (sessionSettingsDateInput.value || '').trim();
    const timeStr = (sessionSettingsTimeInput.value || '').trim();
    if (!dateStr || !timeStr) {
      if (typeof showNotification === 'function') {
        showNotification('Please choose a date and time.', 'error');
      } else {
        alert('Please choose a date and time.');
      }
      return;
    }

    if (!(window.luxon && window.luxon.DateTime)) {
      console.warn('[MentorCalendar] Luxon is required for session settings editing.');
      return;
    }

    const dt = window.luxon.DateTime.fromISO(`${dateStr}T${timeStr}`, { zone: timezone_variable });
    if (!dt.isValid) {
      if (typeof showNotification === 'function') {
        showNotification('Invalid date/time.', 'error');
      } else {
        alert('Invalid date/time.');
      }
      return;
    }

    // Keep existing duration
    const prevStart = ev.start;
    const prevEnd = ev.end;
    const durationMs = (prevStart && prevEnd) ? (prevEnd.getTime() - prevStart.getTime()) : (resolveMentorSessionLengthMinutes() * 60 * 1000);

    const startJs = dt.toJSDate();
    const endJs = new Date(startJs.getTime() + Math.max(0, durationMs));

    ev.setStart(startJs);
    ev.setEnd(endJs);

    markDirty('session');
    recomputeCollisions();
    closeSessionSettings();
  }

  // --- Schedule session popup helpers ---
  function setScheduleSessionVisible(isVisible) {
    if (!scheduleSessionOverlay) return;
    scheduleSessionOverlay.classList.toggle('is-visible', !!isVisible);
    scheduleSessionOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeScheduleSessionPopup() {
    scheduleSessionEventId = null;
    if (scheduleSessionEmailInput) scheduleSessionEmailInput.value = '';
    setScheduleSessionVisible(false);
  }

  function openScheduleSessionPopupForEvent(fcEvent) {
    if (!scheduleSessionOverlay || !fcEvent) return;
    scheduleSessionEventId = fcEvent.id || null;
    setScheduleSessionVisible(true);
    if (scheduleSessionEmailInput) {
      scheduleSessionEmailInput.focus();
      scheduleSessionEmailInput.select?.();
    }
  }

  function sendScheduleSessionEmail() {
    const email = (scheduleSessionEmailInput?.value || '').trim();
    if (!email) {
      if (typeof showNotification === 'function') showNotification('Please enter an email.', 'error');
      else alert('Please enter an email.');
      return;
    }
    const ev = calendar && scheduleSessionEventId ? calendar.getEventById(scheduleSessionEventId) : null;
    console.log('[MentorCalendar] schedule session send', {
      email,
      eventId: scheduleSessionEventId,
      startIso: ev?.start ? ev.start.toISOString() : null,
      endIso: ev?.end ? ev.end.toISOString() : null
    });
    closeScheduleSessionPopup();
  }

  // --- Switch-to-sessions-mode popup helpers ---
  function setSessionSwitchVisible(isVisible) {
    if (!sessionSwitchOverlay) return;
    sessionSwitchOverlay.classList.toggle('is-visible', !!isVisible);
    sessionSwitchOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeSessionSwitchPopup() {
    sessionSwitchEventId = null;
    sessionSwitchOpenSettingsAfterSwitch = false;
    setSessionSwitchVisible(false);
  }

  function openSessionSwitchPopupForEventId(eventId, openSettingsAfterSwitch) {
    if (!sessionSwitchOverlay) return;
    sessionSwitchEventId = eventId || null;
    sessionSwitchOpenSettingsAfterSwitch = !!openSettingsAfterSwitch;
    setSessionSwitchVisible(true);
  }

  function switchToSessionsMode() {
    const id = sessionSwitchEventId;
    const shouldOpenSettings = !!sessionSwitchOpenSettingsAfterSwitch;
    closeSessionSwitchPopup();
    setMode(false);
    if (shouldOpenSettings && calendar && id) {
      const ev = calendar.getEventById(id);
      if (ev) openSessionSettingsForEvent(ev);
    }
  }

  // Track dates which originally had availability (for deletion support)
  let originalAvailabilityDates = new Set();

  // Distinguish single click vs double click on availability slots (Sessions mode)
  // Single click opens "Schedule session" popup, but we wait briefly to see if it's a double-click.
  let __availabilityClickTimer = null;
  let __availabilityClickEventId = null;

  const GET_AVAILABILITY_URL = "{% url 'general:dashboard_mentor:get_availability' %}";
  const SAVE_AVAILABILITY_URL = "{% url 'general:dashboard_mentor:save_availability' %}";

  // Save button enablement:
  // - availability changes: persisted by Save
  // - session changes: not persisted yet, but should still enable Save (per your rule)
  let dirtyAvailability = false;
  let dirtySession = false;

  function updateSaveButtonState() {
    if (!saveBtn) return;
    const isDirty = dirtyAvailability || dirtySession;
    saveBtn.disabled = !isDirty;
  }

  function setSaveButtonLoading(isLoading) {
    if (!saveBtn) return;
    const next = !!isLoading;
    saveBtn.classList.toggle('is-loading', next);
    saveBtn.setAttribute('aria-busy', next ? 'true' : 'false');
    if (next) saveBtn.disabled = true;
  }

  function markDirty(slotMode) {
    if (slotMode === 'availability') dirtyAvailability = true;
    else if (slotMode === 'session') dirtySession = true;
    else dirtyAvailability = true; // conservative fallback
    updateSaveButtonState();
  }

  function clearDirtyAvailability() {
    dirtyAvailability = false;
    updateSaveButtonState();
  }

  function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    return null;
  }

  function getLocalDateKeyFromUtcIso(isoUtc) {
    try {
      if (window.luxon && window.luxon.DateTime) {
        return window.luxon.DateTime.fromISO(isoUtc, { zone: 'utc' })
          .setZone(timezone_variable)
          .toISODate();
      }
    } catch (e) {}
    // Fallback: UTC date
    return String(isoUtc).split('T')[0];
  }

  async function loadSavedAvailability() {
    if (!calendar) return;
    try {
      const res = await fetch(GET_AVAILABILITY_URL, { headers: { 'Accept': 'application/json' } });
      const data = await res.json();
      if (!data.success) {
        console.warn('[MentorCalendar] get_availability failed:', data);
        return;
      }

      // Remove only availability events; keep session events created client-side (ignored for save)
      calendar.getEvents().forEach(ev => {
        if (ev.extendedProps?.slotMode === 'availability') ev.remove();
      });

      originalAvailabilityDates = new Set();

      const slots = Array.isArray(data.one_time_slots) ? data.one_time_slots : [];
      slots.forEach(slot => {
        // Ignore non-availability for now
        if (slot.type && slot.type !== 'availability_slot') return;

        if (!slot.start || !slot.end) return;
        const startIso = slot.start;
        const endIso = slot.end;

        // Track local date keys for deletion support
        originalAvailabilityDates.add(getLocalDateKeyFromUtcIso(startIso));

        calendar.addEvent({
          id: slot.id || ('availability_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8)),
          start: startIso,
          end: endIso,
          allDay: false,
          backgroundColor: '#3b82f6',
          borderColor: '#2563eb',
          textColor: '#ffffff',
          classNames: ['event-type-availability'], // Added class
          // Allow drag start in Sessions mode so we can show the switch popup on drop.
          // The move will be reverted in eventDrop if not in Availability mode.
          editable: true,
          extendedProps: { slotMode: 'availability', type: 'availability_slot' }
        });
      });

      console.log('[MentorCalendar] loaded availability slots:', slots.length);
      recomputeCollisions();
      // Loaded state matches DB for availability
      clearDirtyAvailability();
    } catch (e) {
      console.error('[MentorCalendar] error loading availability:', e);
    }
  }

  async function saveAvailabilityToBackend() {
    if (!calendar) return;
    setSaveButtonLoading(true);

    try {
      const availabilityEvents = calendar.getEvents().filter(ev => ev.extendedProps?.slotMode === 'availability');

      const availabilityPayload = availabilityEvents.map(ev => {
        const startIso = ev.start ? ev.start.toISOString() : null;
        const endIso = ev.end ? ev.end.toISOString() : null;
        if (!startIso || !endIso) return null;

        const dateKey = getLocalDateKeyFromUtcIso(startIso);
        const length = Math.max(0, Math.round((Date.parse(endIso) - Date.parse(startIso)) / 60000));

        return {
          id: ev.id,
          type: 'availability_slot',
          date: dateKey,
          start_iso: startIso,
          end_iso: endIso,
          length: length
        };
      }).filter(Boolean);

      // edited_dates must include previous dates too, for deletion behavior
      const editedDates = new Set(originalAvailabilityDates);
      availabilityPayload.forEach(item => editedDates.add(item.date));

      const editedDatesArr = Array.from(editedDates);
      const selectedDate = editedDatesArr[0] || getLocalDateKeyFromUtcIso(new Date().toISOString());

      const csrf = getCookie('csrftoken');
      if (!csrf) {
        console.warn('[MentorCalendar] Missing csrftoken cookie');
      }

      const res = await fetch(SAVE_AVAILABILITY_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': csrf || ''
        },
        body: JSON.stringify({
          availability: availabilityPayload,
          selected_date: selectedDate,
          edited_dates: editedDatesArr
        })
      });
      const data = await res.json();
      if (!data.success) {
        console.warn('[MentorCalendar] save_availability failed:', data);
        return;
      }

      console.log('[MentorCalendar] saved availability slots:', availabilityPayload.length);
      await loadSavedAvailability();
      if (typeof showNotification === 'function') {
        showNotification('Saved successfully.', 'success');
      }
      // After a successful save, disable the Save button again.
      dirtyAvailability = false;
      dirtySession = false;
    } catch (e) {
      console.error('[MentorCalendar] error saving availability:', e);
    } finally {
      setSaveButtonLoading(false);
      updateSaveButtonState();
    }
  }

  // Mode toggle (for now: only boolean + logs)
  // false = Sessions (green), true = Availability (blue)
  let isAvailabilityMode = false;

  function rangesOverlap(aStart, aEnd, bStart, bEnd) {
    if (!aStart || !aEnd || !bStart || !bEnd) return false;
    const a0 = aStart.getTime();
    const a1 = aEnd.getTime();
    const b0 = bStart.getTime();
    const b1 = bEnd.getTime();
    // Strict overlap (touching at boundary is NOT a collision)
    return a0 < b1 && b0 < a1;
  }

  function recomputeCollisions() {
    if (!calendar) return;

    const activeMode = isAvailabilityMode ? 'availability' : 'session';
    const allEvents = calendar.getEvents();
    const activeEvents = allEvents.filter(ev => ev.extendedProps?.slotMode === activeMode);

    const collisionIds = new Set();

    for (let i = 0; i < activeEvents.length; i++) {
      const a = activeEvents[i];
      const aStart = a.start;
      const aEnd = a.end;
      if (!aStart || !aEnd) continue;

      for (let j = 0; j < allEvents.length; j++) {
        const b = allEvents[j];
        if (!b || b.id === a.id) continue;
        const bStart = b.start;
        const bEnd = b.end;
        if (!bStart || !bEnd) continue;

        if (rangesOverlap(aStart, aEnd, bStart, bEnd)) {
          // Always mark the active-mode event red if it overlaps ANY other event.
          collisionIds.add(a.id);
          // If the other event is ALSO active-mode, it should be marked red too.
          if (b.extendedProps?.slotMode === activeMode) collisionIds.add(b.id);
        }
      }
    }

    let changed = false;
    allEvents.forEach(ev => {
      // Only events for the currently selected mode can be flagged red.
      const shouldFlag = (ev.extendedProps?.slotMode === activeMode) && collisionIds.has(ev.id);
      const currentFlag = !!ev.extendedProps?.hasCollision;
      if (currentFlag !== shouldFlag) {
        ev.setExtendedProp('hasCollision', shouldFlag);
        changed = true;
      }
    });

    if (changed) calendar.rerenderEvents();
  }

  function renderModeToggle() {
    if (!modeSessionsBtn || !modeAvailabilityBtn) return;
    modeSessionsBtn.classList.toggle('is-active', !isAvailabilityMode);
    modeAvailabilityBtn.classList.toggle('is-active', isAvailabilityMode);
  }

  function setMode(nextIsAvailability) {
    isAvailabilityMode = !!nextIsAvailability;
    renderModeToggle();
    
    // Toggle class on root for CSS styling
    if (root) {
      if (isAvailabilityMode) {
        root.classList.add('is-mode-availability');
      } else {
        root.classList.remove('is-mode-availability');
      }
    }

    // Update editability of all existing events
    if (calendar) {
      calendar.getEvents().forEach(ev => {
        const slotMode = ev.extendedProps?.slotMode;
        let shouldBeEditable = false;
        
        if (slotMode === 'availability') {
          // Allow drag start in Sessions mode so we can show the switch popup on drop.
          // The move will be reverted if not in Availability mode.
          shouldBeEditable = true;
        } else if (slotMode === 'session') {
          // Allow drag start in Availability mode so we can show the switch popup on drop.
          // The move/resize will be reverted if not in Sessions mode.
          shouldBeEditable = true;
        } else {
          shouldBeEditable = false;
        }
        
        // Use setProp to update the 'editable' property
        ev.setProp('editable', shouldBeEditable);
      });
    }

    console.log('[MentorCalendar] isAvailabilityMode =', isAvailabilityMode);
    recomputeCollisions();
  }

  function initCalendar(initialView, initialDate) {
    if (calendar) return;
    if (!window.FullCalendar || !window.FullCalendar.Calendar) {
      console.error('[MentorCalendar] FullCalendar not loaded');
      return;
    }
    if (!window.FullCalendarLuxon3) {
      console.warn('[MentorCalendar] FullCalendarLuxon3 plugin not loaded. Named IANA timeZone values may behave like local time.');
    }
    if (!window.FullCalendarInteraction) {
      console.warn('[MentorCalendar] FullCalendarInteraction plugin not loaded. Drag/drop and dateClick may not work.');
    }

    calendar = new FullCalendar.Calendar(root, {
      plugins: [
        ...(window.FullCalendarLuxon3 ? [window.FullCalendarLuxon3] : []),
        ...(window.FullCalendarInteraction ? [window.FullCalendarInteraction] : [])
      ],
      timeZone: timezone_variable,
      initialView: initialView || 'timeGridWeek',
      initialDate: initialDate || undefined,
      height: '100%',
      nowIndicator: true,
      headerToolbar: false, // Custom header
      allDaySlot: false,
      editable: true, // enables drag+resize (fine-grained control below)
      eventStartEditable: true, // allow dragging for both slot types
      eventDurationEditable: function(info) {
        // Only Session slots can be resized
        return info.event.extendedProps?.slotMode === 'session';
      },
      eventResizableFromStart: function(info) {
        // Only Session slots can be resized (from either edge)
        return info.event.extendedProps?.slotMode === 'session';
      },
      eventClassNames: function(arg) {
        return arg.event.extendedProps?.hasCollision ? ['is-collision'] : [];
      },

      eventDidMount: function(info) {
        // Double-click slots -> open settings (or prompt to switch modes)
        try {
          const mode = info.event?.extendedProps?.slotMode;
          if (!info.el) return;

          // Availability slot: in Sessions mode, single click schedules session (debounced).
          if (mode === 'availability') {
            info.el.addEventListener('click', (e) => {
              // Only for Sessions mode
              if (isAvailabilityMode) return;

              // If a previous timer is pending, clear it (we'll overwrite with this click)
              if (__availabilityClickTimer) {
                clearTimeout(__availabilityClickTimer);
                __availabilityClickTimer = null;
              }
              __availabilityClickEventId = info.event.id;

              // Wait a bit to see if this becomes a double-click
              __availabilityClickTimer = window.setTimeout(() => {
                __availabilityClickTimer = null;
                __availabilityClickEventId = null;
                openScheduleSessionPopupForEvent(info.event);
              }, 220);

              e.preventDefault();
              e.stopPropagation();
            });
          }

          info.el.addEventListener('dblclick', (e) => {
            // Cancel any pending single-click schedule action for this availability event
            if (mode === 'availability' && __availabilityClickTimer && __availabilityClickEventId === info.event.id) {
              clearTimeout(__availabilityClickTimer);
              __availabilityClickTimer = null;
              __availabilityClickEventId = null;
            }

            e.preventDefault();
            e.stopPropagation();
            if (mode === 'availability') {
              if (!isAvailabilityMode) {
                openAvailabilitySwitchPopupForEventId(info.event.id, true);
                return;
              }
              openAvailabilitySettingsForEvent(info.event);
              return;
            }

            if (mode === 'session') {
              if (isAvailabilityMode) {
                openSessionSwitchPopupForEventId(info.event.id, true);
                return;
              }
              openSessionSettingsForEvent(info.event);
            }
          });
        } catch (e) {
          // non-fatal
          console.warn('[MentorCalendar] eventDidMount dblclick bind failed:', e);
        }
      },
      slotDuration: '00:05:00',
      snapDuration: '00:05:00',
      slotLabelInterval: '01:00:00',
      
      // Events
      datesSet: function(info) {
        updateDateTitle(info.view.title);
        updateActiveViewButton(info.view.type);
        styleGridLines();
      },
      eventDrop: function(info) {
        const mode = info.event.extendedProps?.slotMode;
        // Dragging availability in Sessions mode: revert and prompt to switch
        if (mode === 'availability' && !isAvailabilityMode) {
          info.revert();
          openAvailabilitySwitchPopupForEventId(info.event.id, false);
          return;
        }
        // Dragging session in Availability mode: revert and prompt to switch
        if (mode === 'session' && isAvailabilityMode) {
          info.revert();
          openSessionSwitchPopupForEventId(info.event.id, false);
          return;
        }
        console.log('[MentorCalendar] eventDrop', {
          mode,
          id: info.event.id,
          startIso: info.event.start ? info.event.start.toISOString() : null,
          endIso: info.event.end ? info.event.end.toISOString() : null,
          timeZone: timezone_variable
        });
        markDirty(mode);
        recomputeCollisions();
      },
      // eventClick is intentionally unused for availability slots because we debounce
      // single-click vs double-click inside eventDidMount.
      eventResize: function(info) {
        const mode = info.event.extendedProps?.slotMode;
        if (mode !== 'session') {
          // Safety: availability should never resize
          info.revert();
          console.log('[MentorCalendar] prevented resize for non-session slot', { id: info.event.id, mode });
          return;
        }
        // Resizing session in Availability mode: revert and prompt to switch
        if (isAvailabilityMode) {
          info.revert();
          openSessionSwitchPopupForEventId(info.event.id, false);
          return;
        }
        console.log('[MentorCalendar] eventResize', {
          mode,
          id: info.event.id,
          startIso: info.event.start ? info.event.start.toISOString() : null,
          endIso: info.event.end ? info.event.end.toISOString() : null,
          timeZone: timezone_variable
        });
        markDirty('session');
        recomputeCollisions();
      },
      dateClick: function(info) {
        // One-click slot creation only in Day/Week timeGrid views
        const viewType = info.view?.type;
        if (viewType !== 'timeGridDay' && viewType !== 'timeGridWeek') return;

        const mode = isAvailabilityMode ? 'availability' : 'session';
        // Use mentor profile session_length (minutes) for slot length
        const durationMinutes = resolveMentorSessionLengthMinutes();

        const startIso = info.date.toISOString();
        const endIso = new Date(info.date.getTime() + durationMinutes * 60 * 1000).toISOString();

        calendar.addEvent({
          id: mode + '_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8),
          start: startIso,
          end: endIso,
          allDay: false,
          backgroundColor: mode === 'availability' ? '#3b82f6' : '#10b981',
          borderColor: mode === 'availability' ? '#2563eb' : '#059669',
          textColor: '#ffffff',
          classNames: [mode === 'availability' ? 'event-type-availability' : 'event-type-session'], // Added class
          editable: true, // Always editable on creation (since it matches current mode)
          extendedProps: { slotMode: mode }
        });

        console.log('[MentorCalendar] created slot', { mode, startIso, endIso, isAvailabilityMode });
        markDirty(mode);
        recomputeCollisions();
      },
      eventContent: function(arg) {
        const mode = arg.event.extendedProps?.slotMode || 'availability';
        const tpl = mode === 'session' ? sessionSlotTpl : availabilitySlotTpl;
        if (!tpl || !tpl.content) return true;

        const startStr = calendar.formatDate(arg.event.start, { hour: 'numeric', minute: '2-digit', hour12: true });
        const endStr = calendar.formatDate(arg.event.end, { hour: 'numeric', minute: '2-digit', hour12: true });

        const node = tpl.content.firstElementChild.cloneNode(true);
        const timeEl = node.querySelector('[data-slot-time]');
        if (timeEl) timeEl.textContent = `${startStr}  ${endStr}`;

        // "Props" passed to the slot component (keeps calendar.html light)
        const props = {
          slotMode: mode,
          isAvailabilityMode,
          timezone: timezone_variable,
          eventId: arg.event.id,
          startIso: arg.event.start ? arg.event.start.toISOString() : null,
          endIso: arg.event.end ? arg.event.end.toISOString() : null
        };

        if (mode === 'session') {
          window.MentorCalendarSlotComponents?.SessionSlot?.mount?.(node, props);
        } else {
          window.MentorCalendarSlotComponents?.AvailabilitySlot?.mount?.(node, props);
        }

        return { domNodes: [node] };
      },
      windowResize: function() {
        calendar.updateSize();
        styleGridLines();
      }
    });

    calendar.render();
    
    // Initial style application
    setTimeout(styleGridLines, 50);
    console.log('[MentorCalendar] Active timeZone:', calendar.getOption('timeZone'));
    // Save starts disabled until the user makes a change
    updateSaveButtonState();
    recomputeCollisions();
  }

  // Internal API for slot components (client-only changes; DB persistence happens on Save)
  window.MentorCalendarInternal = window.MentorCalendarInternal || {};
  window.MentorCalendarInternal.removeEventById = function(eventId) {
    if (!calendar || !eventId) return;
    const ev = calendar.getEventById(eventId);
    if (!ev) return;
    const slotMode = ev.extendedProps?.slotMode;
    console.log('[MentorCalendar] removing event (client-only):', {
      id: ev.id,
      slotMode: slotMode
    });
    
    // Reminder: removing availability is client-only until user clicks Save
    if (slotMode === 'availability' && typeof showNotification === 'function') {
      showNotification("Don't forget to save the changes.", 'note');
    }
    
    markDirty(slotMode);
    ev.remove();
    recomputeCollisions();
  };

  function updateDateTitle(title) {
    if (dateDisplay) {
      dateDisplay.textContent = title;
    }
  }

  function updateActiveViewButton(viewType) {
    document.querySelectorAll('.view-toggle-btn').forEach(btn => {
      btn.classList.toggle('is-active', btn.dataset.calendarView === viewType);
    });
  }

  // --- Custom Styling Logic similar to Availability Popup ---
  function styleGridLines() {
    // 1. Mark hour slots for solid borders
    const slots = root.querySelectorAll('tr');
    slots.forEach(slot => {
        // FullCalendar 6 uses data-time on slot rows, or we check structure
        // Simple heuristic: if it has a label or is top of hour
        const labelCell = slot.querySelector('.fc-timegrid-slot-label');
        if (labelCell && labelCell.getAttribute('data-time')) {
           const time = labelCell.getAttribute('data-time');
           if (time.endsWith(':00:00')) {
             slot.classList.add('fc-hour-slot');
             // Also target the sibling td which is the actual lane
             const lane = slot.querySelector('.fc-timegrid-slot-lane');
             if(lane) lane.classList.add('fc-hour-slot');
           }
        }
    });

    // Fallback if needed, but the above usually works well in FC v6
    // Extra pass for rows that might be missed by simple label check
    const timeSlots = root.querySelectorAll('.fc-timegrid-slot-lane');
    timeSlots.forEach((slot, i) => {
       // Assuming 15min slots per tr, index 0 is first. 
       // We can simply trust the label checking above for now.
    });
  }


  function destroyCalendar() {
    if (!calendar) return;
    try {
      calendar.destroy();
    } finally {
      calendar = null;
      root.innerHTML = '';
    }
  }

  function open() {
    overlay.classList.add('is-visible');
    overlay.setAttribute('aria-hidden', 'false');
    // Small delay to ensure transitions work and DOM is ready
    setTimeout(() => {
        // Re-resolve timezone from profile on each open (in case it changed)
        timezone_variable = resolveMentorTimezone();
        renderModeToggle();
        initCalendar();
        if (calendar) calendar.updateSize();
        loadSavedAvailability();
    }, 50);
  }

  function close() {
    // Always close the settings popup too (if open)
    if (availabilitySettingsOverlay && availabilitySettingsOverlay.classList.contains('is-visible')) {
      closeAvailabilitySettings();
    }
    if (availabilitySwitchOverlay && availabilitySwitchOverlay.classList.contains('is-visible')) {
      closeAvailabilitySwitchPopup();
    }
    if (sessionSwitchOverlay && sessionSwitchOverlay.classList.contains('is-visible')) {
      closeSessionSwitchPopup();
    }
    if (sessionSettingsOverlay && sessionSettingsOverlay.classList.contains('is-visible')) {
      closeSessionSettings();
    }
    if (scheduleSessionOverlay && scheduleSessionOverlay.classList.contains('is-visible')) {
      closeScheduleSessionPopup();
    }
    overlay.classList.remove('is-visible');
    overlay.setAttribute('aria-hidden', 'true');
    // Destroy calendar so it reconstructs cleanly on next open
    destroyCalendar();
    // Reset save state (fresh on next open)
    dirtyAvailability = false;
    dirtySession = false;
    updateSaveButtonState();
  }

  // --- Event Listeners ---

  // Navigation Buttons
  overlay.querySelectorAll('[data-calendar-nav]').forEach(btn => {
    btn.addEventListener('click', () => {
      if (!calendar) return;
      const action = btn.dataset.calendarNav;
      if (action === 'prev') calendar.prev();
      if (action === 'next') calendar.next();
      if (action === 'today') calendar.today();
    });
  });

  // View Toggle Buttons
  overlay.querySelectorAll('[data-calendar-view]').forEach(btn => {
    btn.addEventListener('click', () => {
      if (!calendar) return;
      calendar.changeView(btn.dataset.calendarView);
    });
  });

  // Mode toggle buttons (boolean only, no behavior yet)
  if (modeSessionsBtn) {
    modeSessionsBtn.addEventListener('click', () => setMode(false));
  }
  if (modeAvailabilityBtn) {
    modeAvailabilityBtn.addEventListener('click', () => setMode(true));
  }

  // Save availability button
  if (saveBtn) {
    saveBtn.addEventListener('click', () => {
      console.log('[MentorCalendar] Save clicked. Saving availability only (sessions ignored).');
      saveAvailabilityToBackend();
    });
  }

  // Availability settings popup handlers
  if (availabilitySettingsOverlay) {
    availabilitySettingsOverlay.querySelectorAll('[data-availability-settings-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySettings();
      });
    });
    availabilitySettingsOverlay.querySelectorAll('[data-availability-settings-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySettings();
      });
    });
  }
  if (availabilitySettingsSaveBtn) {
    availabilitySettingsSaveBtn.addEventListener('click', (e) => {
      e.preventDefault();
      applyAvailabilitySettings();
    });
  }

  // Switch-to-availability-mode popup handlers
  if (availabilitySwitchOverlay) {
    availabilitySwitchOverlay.querySelectorAll('[data-availability-switch-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySwitchPopup();
      });
    });
    availabilitySwitchOverlay.querySelectorAll('[data-availability-switch-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySwitchPopup();
      });
    });
  }
  if (availabilitySwitchToAvailabilityBtn) {
    availabilitySwitchToAvailabilityBtn.addEventListener('click', (e) => {
      e.preventDefault();
      switchToAvailabilityModeAndOpenSettings();
    });
  }

  // Switch-to-sessions-mode popup handlers
  if (sessionSwitchOverlay) {
    sessionSwitchOverlay.querySelectorAll('[data-session-switch-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSwitchPopup();
      });
    });
    sessionSwitchOverlay.querySelectorAll('[data-session-switch-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSwitchPopup();
      });
    });
  }
  if (sessionSwitchToSessionsBtn) {
    sessionSwitchToSessionsBtn.addEventListener('click', (e) => {
      e.preventDefault();
      switchToSessionsMode();
    });
  }

  // Session settings popup handlers
  if (sessionSettingsOverlay) {
    sessionSettingsOverlay.querySelectorAll('[data-session-settings-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSettings();
      });
    });
    sessionSettingsOverlay.querySelectorAll('[data-session-settings-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSettings();
      });
    });
  }
  if (sessionSettingsApplyBtn) {
    sessionSettingsApplyBtn.addEventListener('click', (e) => {
      e.preventDefault();
      applySessionSettings();
    });
  }

  // Schedule session popup handlers
  if (scheduleSessionOverlay) {
    scheduleSessionOverlay.querySelectorAll('[data-schedule-session-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeScheduleSessionPopup();
      });
    });
  }
  if (scheduleSessionSendBtn) {
    scheduleSessionSendBtn.addEventListener('click', (e) => {
      e.preventDefault();
      sendScheduleSessionEmail();
    });
  }

  // Close handlers
  overlay.querySelectorAll('[data-mentor-calendar-close]').forEach(el => {
    el.addEventListener('click', close);
  });
  
  document.addEventListener('keydown', (e) => {
    if (e.key !== 'Escape') return;
    if (!overlay.classList.contains('is-visible')) return;

    // Priority: close settings popups first, then switch popups, then the calendar popup.
    if (availabilitySettingsOverlay && availabilitySettingsOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeAvailabilitySettings();
      return;
    }
    if (sessionSettingsOverlay && sessionSettingsOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeSessionSettings();
      return;
    }
    if (scheduleSessionOverlay && scheduleSessionOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeScheduleSessionPopup();
      return;
    }
    if (availabilitySwitchOverlay && availabilitySwitchOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeAvailabilitySwitchPopup();
      return;
    }
    if (sessionSwitchOverlay && sessionSwitchOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeSessionSwitchPopup();
      return;
    }
    close();
  });

  // Public API
  window.MentorCalendar = { open, close };

  document.querySelectorAll('[data-open-mentor-calendar]').forEach(el => {
    el.addEventListener('click', (e) => {
      e.preventDefault();
      open();
    });
  });
})();
</script>
