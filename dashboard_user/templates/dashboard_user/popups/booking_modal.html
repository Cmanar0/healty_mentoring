{# Booking Modal Popup #}
<div id="bookingModal" class="booking-modal-overlay">
    <div class="booking-modal-container">
        <button class="booking-close-btn" onclick="closeBookingModal()"><i class="fas fa-times"></i></button>
        
        <div class="booking-grid">
            <!-- Col 1: Mentor Info -->
            <div class="booking-sidebar">
                <div class="booking-mentor-mini">
                    {% if mentor_profile.profile_picture %}
                    <img src="{{ mentor_profile.profile_picture.url }}" alt="Avatar" class="booking-avatar">
                    {% else %}
                    <div class="booking-avatar-placeholder">{{ mentor_profile.first_name|first }}</div>
                    {% endif %}
                    <div>
                        <div class="booking-mentor-name">{{ mentor_profile.first_name }} {{ mentor_profile.last_name }}</div>
                        <div class="booking-session-name">1:1 Session</div>
                    </div>
                </div>
                
                <div class="booking-meta">
                    <div class="booking-meta-item">
                        <i class="fas fa-clock"></i>
                        <span>{{ mentor_profile.session_length|default:"60" }} min</span>
                    </div>
                    <div class="booking-meta-item">
                        <i class="fas fa-video"></i>
                        <span>Google Meet</span>
                    </div>
                    <div class="booking-meta-item">
                        <i class="fas fa-tag"></i>
                        <span>${{ mentor_profile.price_per_hour|floatformat:0 }}</span>
                    </div>
                </div>

                <!-- NEW: Dynamic Selection Summary -->
                <div id="bookingSummary" class="booking-selection-summary" style="display: none;">
                    <div class="summary-label">Your Selection</div>
                    <div class="summary-details">
                        <div class="summary-item">
                            <i class="far fa-calendar-alt"></i>
                            <span id="summaryDate">Select a date</span>
                        </div>
                        <div class="summary-item" id="summaryTimeRow" style="display: none;">
                            <i class="far fa-clock"></i>
                            <span id="summaryTime">Select a time</span>
                        </div>
                    </div>
                </div>
                
                <div class="booking-desc">
                    Book a focused session to discuss your career, goals, or specific challenges.
                </div>
            </div>
            
            <!-- Col 2: Calendar -->
            <div class="booking-calendar-col">
                <h3 class="booking-title">Select a Date & Time</h3>
                
                <div class="calendar-header">
                    <button class="cal-nav-btn" id="prevMonth"><i class="fas fa-chevron-left"></i></button>
                    <div class="current-month-label" id="currentMonthLabel">October 2023</div>
                    <button class="cal-nav-btn" id="nextMonth"><i class="fas fa-chevron-right"></i></button>
                </div>
                
                <div class="calendar-grid-header">
                    <div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div>
                </div>
                <div class="calendar-days" id="calendarDays">
                    <!-- JS generated -->
                </div>
            </div>
            
            <!-- Col 3: Slots -->
            <div class="booking-slots-col" id="slotsCol" style="display: none;">
                <div class="slots-header-row">
                    <h4 class="slots-date-label" id="selectedDateLabel">Thursday, Oct 12</h4>
                </div>
                <div class="slots-list" id="slotsList">
                    <!-- JS generated -->
                </div>
                <div class="slots-footer" id="slotsFooter" style="display: none;">
                    <button class="book-slot-btn" id="bookSlotBtn">
                        <i class="fas fa-calendar-check"></i>
                        <span>Book this slot</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Modal CSS */
.booking-modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(15, 23, 42, 0.6);
    backdrop-filter: blur(4px);
    z-index: 10000;
    display: none;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}
.booking-modal-overlay.open {
    display: flex;
    opacity: 1;
}

.booking-modal-container {
    background: white;
    width: 90%;
    max-width: 1000px;
    height: 600px;
    border-radius: 20px;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.booking-close-btn {
    position: absolute;
    top: 16px;
    right: 16px;
    background: rgba(15, 23, 42, 0.1); /* Subtle dark circle in light modal */
    border: 1px solid rgba(15, 23, 42, 0.1);
    color: #64748b;
    font-size: 1rem;
    cursor: pointer;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 20;
}
.booking-close-btn:hover {
    background: #ef4444;
    border-color: #ef4444;
    color: white;
    transform: rotate(90deg) scale(1.1);
    box-shadow: 0 0 15px rgba(239, 68, 68, 0.4);
}

.booking-grid {
    display: grid;
    grid-template-columns: 300px 1fr 320px; /* Fixed width for slots col to prevent jumping */
    height: 100%;
    max-height: 100%; /* Ensure grid doesn't exceed container */
}

/* Sidebar */
.booking-sidebar {
    padding: 32px;
    border-right: 1px solid #e2e8f0;
    background: #f8fafc;
}
.booking-mentor-mini {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 32px;
}
.booking-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    object-fit: cover;
}
.booking-avatar-placeholder {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: #3b82f6;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
}
.booking-mentor-name { color: #64748b; font-size: 0.9rem; font-weight: 500; }
.booking-session-name { color: #1e293b; font-size: 1.1rem; font-weight: 700; margin-top: 2px; }

.booking-meta { display: flex; flex-direction: column; gap: 12px; margin-bottom: 32px; }
.booking-meta-item { display: flex; align-items: center; gap: 10px; color: #475569; font-weight: 500; }
.booking-meta-item i { color: #94a3b8; width: 20px; text-align: center; }

.booking-desc { font-size: 0.9rem; color: #64748b; line-height: 1.6; }

/* Selection Summary */
.booking-selection-summary {
    background: #f8fafc;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 24px;
    border: 1px solid #e2e8f0;
}
.summary-label {
    text-transform: uppercase;
    font-size: 0.7rem;
    font-weight: 700;
    color: #94a3b8;
    letter-spacing: 0.05em;
    margin-bottom: 10px;
}
.summary-details {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.summary-item {
    display: flex;
    align-items: center;
    gap: 10px;
    color: #1e293b;
    font-size: 0.95rem;
    font-weight: 600;
}
.summary-item i {
    color: #3b82f6;
    width: 16px;
    font-size: 0.9rem;
}

/* Calendar */
.booking-calendar-col {
    padding: 32px;
    flex: 1;
    overflow-y: auto;
}
.booking-title { font-size: 1.5rem; color: #1e293b; margin-bottom: 24px; }

.calendar-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 24px;
}
.current-month-label { font-size: 1.1rem; font-weight: 600; color: #1e293b; }
.cal-nav-btn {
    background: transparent;
    border: 1px solid #e2e8f0;
    width: 32px; height: 32px;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
    color: #64748b;
}
.cal-nav-btn:hover { background: #f1f5f9; color: var(--mp-primary); }

.calendar-grid-header {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    text-align: center;
    font-size: 0.75rem;
    font-weight: 600;
    color: #94a3b8;
    text-transform: uppercase;
    margin-bottom: 12px;
}
.calendar-days {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    row-gap: 8px;
}
.cal-day {
    height: 44px;
    width: 44px;
    margin: 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    cursor: pointer;
    font-size: 0.95rem;
    font-weight: 500;
    color: #334155;
    transition: all 0.2s;
    position: relative;
}
.cal-day:hover:not(.empty):not(.disabled) {
    background: #eff6ff; /* Light Blue */
    color: #3b82f6;
    font-weight: 600;
}
.cal-day.selected {
    background: #3b82f6 !important;
    color: white !important;
}
.cal-day.disabled {
    color: #cbd5e1;
    cursor: default;
}
.cal-day.has-slots:not(.disabled):not(.selected) {
    background: #eff6ff; /* Light Blue tint */
    color: #3b82f6;
    font-weight: 600;
}
.cal-day.has-slots:not(.selected)::after {
    content: '';
    position: absolute;
    bottom: 6px;
    width: 4px; height: 4px;
    background: #3b82f6;
    border-radius: 50%;
}
.cal-day.selected.has-slots::after { background: white; }
.cal-day.today {
    background: #f1f5f9; /* Neutral gray for today since it's disabled */
    border: 1px solid #cbd5e1;
    font-weight: 700;
}

/* Slots Col */
.booking-slots-col {
    width: 320px;
    padding: 32px;
    border-left: 1px solid #e2e8f0;
    display: flex;
    flex-direction: column;
    height: 100%;
    max-height: 100%; /* Force height to match modal */
    min-height: 0;
    background: white;
    box-sizing: border-box;
    overflow: hidden; /* Prevent the column itself from scrolling */
}
.slots-header-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
    flex-shrink: 0; /* Prevent header from shrinking */
}
.slots-date-label {
    font-size: 1rem;
    color: #475569;
    margin: 0;
}

@keyframes slideIn {
    from { opacity: 0; transform: translateX(10px); }
    to { opacity: 1; transform: translateX(0); }
}

.slots-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0; /* Critical for scroll inside flex */
    scrollbar-width: thin; /* Firefox: thin scrollbar */
    scrollbar-color: #cbd5e1 transparent; /* Firefox: thumb and track */
}
.slots-list::-webkit-scrollbar {
    width: 4px; /* Super thin width */
}
.slots-list::-webkit-scrollbar-track {
    background: transparent;
}
.slots-list::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 10px;
}
.slots-list::-webkit-scrollbar-thumb:hover {
    background: #94a3b8;
}
.time-slot-btn {
    padding: 14px;
    border: 1px solid #3b82f6; /* Default Blue Border */
    border-radius: 12px;
    background: #eff6ff; /* Default Light Blue Background */
    color: #3b82f6; /* Default Blue Text */
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    text-align: center;
    box-sizing: border-box;
}
.time-slot-btn:hover {
    border-color: #2563eb; /* Darker Blue Border */
    background: #dbeafe; /* Light Blue Background */
    color: #2563eb; /* Darker Blue Text */
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}
.time-slot-btn.selected {
    border-color: #3b82f6;
    background: #3b82f6; /* High contrast Blue selection */
    color: white; /* White text for visibility */
    box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.3);
}
.time-slot-btn.selected:hover {
    background: #2563eb;
    border-color: #2563eb;
    color: white;
}

.slots-footer {
    padding-top: 20px;
    border-top: 1px solid #e2e8f0;
    margin-top: 20px;
    flex-shrink: 0; /* Keep footer size fixed */
}

.book-slot-btn {
    width: 100%;
    padding: 14px 20px;
    background: var(--mp-primary); /* Green button */
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 4px 6px rgba(16, 185, 129, 0.2);
}
.book-slot-btn:hover {
    background: #059669;
    box-shadow: 0 6px 12px rgba(16, 185, 129, 0.3);
}
.book-slot-btn:active {
    transform: scale(0.98);
}

/* Responsiveness for Modal */
@media (max-width: 900px) {
    .booking-grid {
        grid-template-columns: 250px 1fr;
    }
    .booking-slots-col {
        position: absolute;
        top: 0; right: 0; bottom: 0;
        background: white;
        box-shadow: -10px 0 20px rgba(0,0,0,0.1);
        z-index: 10;
    }
}
@media (max-width: 768px) {
    .booking-modal-container {
        height: 100%;
        max-height: 100%;
        width: 100%;
        border-radius: 0;
    }
    .booking-grid {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
    }
    .booking-sidebar {
        padding: 20px;
        border-right: none;
        border-bottom: 1px solid #e2e8f0;
    }
    .booking-mentor-mini { margin-bottom: 16px; }
    .booking-meta { flex-direction: row; gap: 20px; margin-bottom: 16px; font-size: 0.85rem; }
    .booking-desc { display: none; } /* Hide desc on mobile */
    .booking-slots-col {
        width: 100%;
        border-left: none;
    }
}
</style>

<!-- Data Injection for JS -->
{{ mentor_profile.one_time_slots|json_script:"one-time-slots-data" }}
{{ mentor_profile.recurring_slots|json_script:"recurring-slots-data" }}
<script id="mentor-session-length" type="application/json">{{ mentor_profile.session_length|default:60 }}</script>


<script>
    // --- Data & State ---
    let availabilityData;
    let sessionLengthMinutes = 60; // Default session length
    let currentDate = new Date(); // To track month view
    let selectedDate = null;
    let selectedSlot = null; // Track selected time slot
    
    // --- DOM Elements ---
    let modal, currentMonthLabel, calendarDays, slotsCol, slotsList, selectedDateLabel, prevMonthBtn, nextMonthBtn, slotsFooter, bookSlotBtn;

    document.addEventListener('DOMContentLoaded', function() {
        // Safe access to data script
        const oneTimeData = document.getElementById('one-time-slots-data');
        const recurringData = document.getElementById('recurring-slots-data');
        const sessionLengthEl = document.getElementById('mentor-session-length');
        
        // Get session length
        if (sessionLengthEl) {
            try {
                sessionLengthMinutes = parseInt(JSON.parse(sessionLengthEl.textContent)) || 60;
            } catch (e) {
                sessionLengthMinutes = 60;
            }
        }
        
        // Parse availability data
        let oneTimeSlots = [];
        let recurringSlots = [];
        
        if (oneTimeData) {
            try {
                oneTimeSlots = JSON.parse(oneTimeData.textContent) || [];
            } catch (e) {
                console.error('Error parsing one-time slots:', e);
            }
        }
        
        if (recurringData) {
            try {
                recurringSlots = JSON.parse(recurringData.textContent) || [];
            } catch (e) {
                console.error('Error parsing recurring slots:', e);
            }
        }
        
        // Filter one-time slots to only include future, non-booked slots
        const now = new Date();
        oneTimeSlots = oneTimeSlots.filter(slot => {
            if (!slot.start || !slot.end) return false;
            if (slot.booked === true) return false;
            
            try {
                const endDate = new Date(slot.end.replace('Z', '+00:00'));
                // Only include slots that end in the future
                return endDate > now;
            } catch (e) {
                return false;
            }
        });
        
        availabilityData = {
            one_time_slots: oneTimeSlots,
            recurring_slots: recurringSlots
        };
        
        modal = document.getElementById('bookingModal');
        currentMonthLabel = document.getElementById('currentMonthLabel');
        calendarDays = document.getElementById('calendarDays');
        slotsCol = document.getElementById('slotsCol');
        slotsList = document.getElementById('slotsList');
        selectedDateLabel = document.getElementById('selectedDateLabel');
        prevMonthBtn = document.getElementById('prevMonth');
        nextMonthBtn = document.getElementById('nextMonth');
        slotsFooter = document.getElementById('slotsFooter');
        bookSlotBtn = document.getElementById('bookSlotBtn');

        bookingSummary = document.getElementById('bookingSummary');
        summaryDate = document.getElementById('summaryDate');
        summaryTimeRow = document.getElementById('summaryTimeRow');
        summaryTime = document.getElementById('summaryTime');
        
        // --- Events ---
        if (prevMonthBtn) prevMonthBtn.onclick = () => {
            currentDate.setMonth(currentDate.getMonth() - 1);
            renderCalendar();
        };
        if (nextMonthBtn) nextMonthBtn.onclick = () => {
            currentDate.setMonth(currentDate.getMonth() + 1);
            renderCalendar();
        };
        
        // Close on click outside
        if (modal) modal.addEventListener('click', (e) => {
            if (e.target === modal) closeBookingModal();
        });
        
        // Close on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal && modal.classList.contains('open')) {
                closeBookingModal();
            }
        });
        
        // Book slot button handler
        if (bookSlotBtn) {
            bookSlotBtn.addEventListener('click', function() {
                if (selectedSlot && selectedDate) {
                    alert('Booking flow to be implemented! Selected: ' + selectedDate.toLocaleDateString() + ' at ' + selectedSlot.time);
                    // TODO: Implement actual booking logic
                }
            });
        }
    });

    // --- Modal Logic ---
    function openBookingModal() {
        if (!modal) return; // Guard clause
        
        // Reset State on Open
        currentDate = new Date(); // Reset to current month
        selectedDate = null;      // Clear selection
        selectedSlot = null;      // Clear slot selection
        if (slotsCol) slotsCol.style.display = 'none'; // Hide slots initially
        if (slotsFooter) slotsFooter.style.display = 'none'; // Hide footer
        if (bookingSummary) bookingSummary.style.display = 'none'; // Hide summary
        
        modal.classList.add('open');
        document.body.style.overflow = 'hidden'; // Prevent background scroll
        renderCalendar();
    }

    function closeBookingModal() {
        if (!modal) return;
        modal.classList.remove('open');
        document.body.style.overflow = '';
        // State is reset on next open, but good to clear view
        selectedDate = null;
        selectedSlot = null;
        if (slotsCol) slotsCol.style.display = 'none';
        if (slotsFooter) slotsFooter.style.display = 'none';
        if (bookingSummary) bookingSummary.style.display = 'none';
        renderCalendar();
    }
    
    function closeSlots() {
        if (slotsCol) slotsCol.style.display = 'none';
        if (slotsFooter) slotsFooter.style.display = 'none';
        if (bookingSummary) bookingSummary.style.display = 'none';
        selectedDate = null;
        selectedSlot = null;
        renderCalendar(); // Redraws calendar to remove 'selected' class
    }
    
    // Close on click outside
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeBookingModal();
    });    
        // --- Calendar Logic ---
    function renderCalendar() {
        if (!calendarDays) return;
        
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();

        // Update Header
        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        if (currentMonthLabel) currentMonthLabel.textContent = `${monthNames[month]} ${year}`;

        // Days calculation
        const firstDayOfMonth = new Date(year, month, 1).getDay(); // 0 (Sun) - 6 (Sat)
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        
        // Use a temp date for checking availability
        const today = new Date();
        today.setHours(0,0,0,0);

        calendarDays.innerHTML = '';

        // Empty cells for previous month padding
        for (let i = 0; i < firstDayOfMonth; i++) {
            const emptyCell = document.createElement('div');
            emptyCell.classList.add('cal-day', 'empty');
            calendarDays.appendChild(emptyCell);
        }

        // Days
        for (let day = 1; day <= daysInMonth; day++) {
            const dayEl = document.createElement('div');
            dayEl.classList.add('cal-day');
            dayEl.textContent = day;
            
            const checkDate = new Date(year, month, day);
            checkDate.setHours(0,0,0,0);

            // Disable past dates and today
            if (checkDate <= today) {
                dayEl.classList.add('disabled');
                if (checkDate.getTime() === today.getTime()) {
                    dayEl.classList.add('today');
                }
            } else {
                // Check Availability
                if (hasAvailability(checkDate)) {
                    dayEl.classList.add('has-slots');
                }
                
                dayEl.onclick = () => selectDate(checkDate, dayEl);
            }

            // Selected State
            if (selectedDate && checkDate.getTime() === selectedDate.getTime()) {
                dayEl.classList.add('selected');
            }

            calendarDays.appendChild(dayEl);
        }
    }

    // --- Slot Calculation Logic ---
    function hasAvailability(date) {
        if (!availabilityData) return false;
        
        // Get date string in local timezone (YYYY-MM-DD format)
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const dateStr = `${year}-${month}-${day}`;
        
        const now = new Date();
        // Check if it's today
        const nowYear = now.getFullYear();
        const nowMonth = String(now.getMonth() + 1).padStart(2, '0');
        const nowDay = String(now.getDate()).padStart(2, '0');
        const nowDateStr = `${nowYear}-${nowMonth}-${nowDay}`;
        const isToday = dateStr === nowDateStr;
        
        // 1. One-Time Check
        const hasOneTime = availabilityData.one_time_slots.some(slot => {
            if (!slot.start || !slot.end) return false;
            if (slot.booked === true) return false;
            
            try {
                const slotStart = new Date(slot.start.replace('Z', '+00:00'));
                const slotEnd = new Date(slot.end.replace('Z', '+00:00'));
                
                // Convert slot date to local timezone for comparison
                const slotYear = slotStart.getFullYear();
                const slotMonth = String(slotStart.getMonth() + 1).padStart(2, '0');
                const slotDay = String(slotStart.getDate()).padStart(2, '0');
                const slotDateStr = `${slotYear}-${slotMonth}-${slotDay}`;
                
                if (slotDateStr !== dateStr) return false;
                
                // For today, ensure the slot end is in the future
                // For future dates, any slot is fine
                if (isToday) {
                    return slotEnd > now;
                } else {
                    return slotEnd > now; // Still check future for safety
                }
            } catch (e) {
                return false;
            }
        });
        if (hasOneTime) return true;

        // 2. Recurring Check
        const weekdayMap = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        const dayName = weekdayMap[date.getDay()];
        
        const hasRecurring = availabilityData.recurring_slots.some(rule => {
            if (!rule || !rule.type) return false;
            
            const skipDates = new Set(rule.skip_dates || []);
            const bookedDates = new Set(rule.booked_dates || []);
            
            // Skip if this date is in skip_dates or booked_dates
            if (skipDates.has(dateStr) || bookedDates.has(dateStr)) return false;
            
            // Check if rule applies to this date
            let matches = false;
            if (rule.type === 'daily') {
                matches = true;
            } else if (rule.type === 'weekly') {
                const weekdays = rule.weekdays || [];
                matches = weekdays.includes(dayName);
            } else if (rule.type === 'monthly') {
                const dayOfMonth = rule.day_of_month;
                if (dayOfMonth !== null && dayOfMonth !== undefined) {
                    if (date.getDate() === dayOfMonth) {
                        matches = true;
                    } else if (dayOfMonth > 28) {
                        // Handle edge case: if slot is for day 31 but month doesn't have 31 days
                        const lastDayOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                        if (date.getDate() === lastDayOfMonth && dayOfMonth > lastDayOfMonth) {
                            matches = true;
                        }
                    }
                }
            }
            
            if (!matches) return false;
            
            // For today, check if there are any future slots from this rule
            if (isToday && rule.start_time && rule.end_time) {
                try {
                    const [endH, endM] = rule.end_time.split(':').map(Number);
                    const windowEnd = new Date(date);
                    windowEnd.setHours(endH, endM, 0, 0);
                    return windowEnd > now;
                } catch (e) {
                    return false;
                }
            }
            
            return true;
        });
        
        return hasRecurring;
    }

    function getSlotsForDate(date) {
        if (!availabilityData) return [];

        const slots = [];
        // Get date string in local timezone (YYYY-MM-DD format)
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const dateStr = `${year}-${month}-${day}`;
        
        const weekdayMap = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        const dayName = weekdayMap[date.getDay()];
        const now = new Date();

        // 1. Add One-Time Slots
        availabilityData.one_time_slots.forEach(slot => {
            if (!slot.start || !slot.end) return;
            if (slot.booked === true) return;
            
            try {
                const slotStart = new Date(slot.start.replace('Z', '+00:00'));
                const slotEnd = new Date(slot.end.replace('Z', '+00:00'));
                
                // Convert slot date to local timezone for comparison
                const slotYear = slotStart.getFullYear();
                const slotMonth = String(slotStart.getMonth() + 1).padStart(2, '0');
                const slotDay = String(slotStart.getDate()).padStart(2, '0');
                const slotDateStr = `${slotYear}-${slotMonth}-${slotDay}`;
                
                // Only include slots for this date that end in the future
                if (slotDateStr === dateStr && slotEnd > now) {
                    // Generate time slots from this availability window
                    const windowSlots = generateTimeSlotsFromWindow(slotStart, slotEnd, sessionLengthMinutes);
                    windowSlots.forEach(slotStartTime => {
                        const slotEndTime = new Date(slotStartTime.getTime() + sessionLengthMinutes * 60000);
                        
                        // Format times in 12-hour format with AM/PM
                        // Use local time methods which automatically handle timezone conversion
                        const formatTime = (date) => {
                            // getHours() and getMinutes() already return local time
                            let hours = date.getHours();
                            const minutes = date.getMinutes();
                            const ampm = hours >= 12 ? 'pm' : 'am';
                            hours = hours % 12;
                            hours = hours ? hours : 12; // the hour '0' should be '12'
                            const minutesStr = minutes < 10 ? '0' + minutes : minutes;
                            return `${hours}:${minutesStr} ${ampm}`;
                        };
                        
                        const startTimeStr = formatTime(slotStartTime);
                        const endTimeStr = formatTime(slotEndTime);
                        
                        // Create a unique key for deduplication based on the actual start time
                        const startTimeKey = slotStartTime.getTime(); // Use timestamp for uniqueness
                        
                        slots.push({ 
                            time: `${startTimeStr} - ${endTimeStr}`, 
                            raw: slot, 
                            type: 'one_time',
                            start: slotStartTime.toISOString(),
                            end: slotEndTime.toISOString(),
                            _startTimeKey: startTimeKey // Internal key for deduplication
                        });
                    });
                }
            } catch (e) {
                console.error('Error processing one-time slot:', e);
            }
        });

        // 2. Generate Recurring Slots
        availabilityData.recurring_slots.forEach(rule => {
            if (!rule || !rule.type) return;
            
            const skipDates = new Set(rule.skip_dates || []);
            const bookedDates = new Set(rule.booked_dates || []);
            
            // Skip if this date is in skip_dates or booked_dates
            if (skipDates.has(dateStr) || bookedDates.has(dateStr)) return;
            
            let matches = false;
            
            if (rule.type === 'daily') {
                matches = true;
            } else if (rule.type === 'weekly') {
                const weekdays = rule.weekdays || [];
                matches = weekdays.includes(dayName);
            } else if (rule.type === 'monthly') {
                const dayOfMonth = rule.day_of_month;
                if (dayOfMonth !== null && dayOfMonth !== undefined) {
                    if (date.getDate() === dayOfMonth) {
                        matches = true;
                    } else if (dayOfMonth > 28) {
                        // Handle edge case: if slot is for day 31 but month doesn't have 31 days
                        const lastDayOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                        if (date.getDate() === lastDayOfMonth && dayOfMonth > lastDayOfMonth) {
                            matches = true;
                        }
                    }
                }
            }
            
            if (matches && rule.start_time && rule.end_time) {
                try {
                    // Parse start and end times
                    const [startH, startM] = rule.start_time.split(':').map(Number);
                    const [endH, endM] = rule.end_time.split(':').map(Number);
                    
                    // Create datetime objects for this specific date
                    const windowStart = new Date(date);
                    windowStart.setHours(startH, startM, 0, 0);
                    
                    const windowEnd = new Date(date);
                    windowEnd.setHours(endH, endM, 0, 0);
                    
                    // Only include if the window end is in the future
                    if (windowEnd > now) {
                        const windowSlots = generateTimeSlotsFromWindow(windowStart, windowEnd, sessionLengthMinutes);
                        windowSlots.forEach(slotStart => {
                            const slotEnd = new Date(slotStart.getTime() + sessionLengthMinutes * 60000);
                            
                            // Format times in 12-hour format with AM/PM
                            const formatTime = (date) => {
                                let hours = date.getHours();
                                const minutes = date.getMinutes();
                                const ampm = hours >= 12 ? 'pm' : 'am';
                                hours = hours % 12;
                                hours = hours ? hours : 12; // the hour '0' should be '12'
                                const minutesStr = minutes < 10 ? '0' + minutes : minutes;
                                return `${hours}:${minutesStr} ${ampm}`;
                            };
                            
                            const startTimeStr = formatTime(slotStart);
                            const endTimeStr = formatTime(slotEnd);
                            
                            // Create a unique key for deduplication based on the actual start time
                            const startTimeKey = slotStart.getTime(); // Use timestamp for uniqueness
                            
                            slots.push({ 
                                time: `${startTimeStr} - ${endTimeStr}`, 
                                raw: rule, 
                                type: 'recurring',
                                start: slotStart.toISOString(),
                                end: slotEnd.toISOString(),
                                _startTimeKey: startTimeKey // Internal key for deduplication
                            });
                        });
                    }
                } catch (e) {
                    console.error('Error processing recurring slot:', e);
                }
            }
        });

        // Sort by start time and remove duplicates based on actual start timestamp
        const uniqueSlots = [];
        const seenStartTimes = new Set();
        
        slots.sort((a, b) => {
            // Sort by actual start time (timestamp)
            const timeA = a._startTimeKey || (a.start ? new Date(a.start).getTime() : 0);
            const timeB = b._startTimeKey || (b.start ? new Date(b.start).getTime() : 0);
            return timeA - timeB;
        }).forEach(slot => {
            // Use the timestamp for deduplication (most reliable)
            const startTimeKey = slot._startTimeKey || (slot.start ? new Date(slot.start).getTime() : null);
            if (startTimeKey !== null && !seenStartTimes.has(startTimeKey)) {
                seenStartTimes.add(startTimeKey);
                // Remove the internal key before returning
                delete slot._startTimeKey;
                uniqueSlots.push(slot);
            }
        });
        
        return uniqueSlots;
    }
    
    // Helper function to generate time slots from an availability window
    function generateTimeSlotsFromWindow(windowStart, windowEnd, slotLengthMinutes) {
        const slots = [];
        const now = new Date();
        
        let currentTime = new Date(windowStart);
        
        while (currentTime < windowEnd) {
            const slotEnd = new Date(currentTime.getTime() + slotLengthMinutes * 60000);
            
            if (slotEnd <= windowEnd && slotEnd > now) {
                // Return the actual Date object for robust formatting later
                slots.push(new Date(currentTime));
            }
            
            currentTime = new Date(currentTime.getTime() + slotLengthMinutes * 60000);
        }
        
        return slots;
    }

    function selectDate(date, dayEl) {
        selectedDate = date;
        selectedSlot = null; // Clear slot selection when date changes
        renderCalendar(); // Refresh calendar to show selected date
        
        // Show Slots
        if (slotsCol) slotsCol.style.display = 'flex';
        const dateOptions = {weekday: 'long', month: 'short', day: 'numeric'};
        const formattedDate = date.toLocaleDateString([], dateOptions);
        if (selectedDateLabel) selectedDateLabel.textContent = formattedDate;
        
        // Update Sidebar Summary
        if (bookingSummary) bookingSummary.style.display = 'block';
        if (summaryDate) summaryDate.textContent = formattedDate;
        if (summaryTimeRow) summaryTimeRow.style.display = 'none'; // Hide time until slot selected
        
        renderSlots(date);
    }

    function renderSlots(date) {
        const slots = getSlotsForDate(date);
        if (slotsList) {
            slotsList.innerHTML = '';
            
            if (slots.length === 0) {
                slotsList.innerHTML = '<div style="color: #94a3b8; font-style: italic;">No available slots.</div>';
                if (slotsFooter) slotsFooter.style.display = 'none';
            } else {
                slots.forEach((slot, index) => {
                    const btn = document.createElement('button');
                    btn.classList.add('time-slot-btn');
                    btn.textContent = slot.time;
                    btn.dataset.slotIndex = index;
                    btn.onclick = () => {
                        // Remove selected class from all buttons
                        slotsList.querySelectorAll('.time-slot-btn').forEach(b => b.classList.remove('selected'));
                        // Add selected class to clicked button
                        btn.classList.add('selected');
                        selectedSlot = slot;
                        
                        // Show book button
                        if (slotsFooter) slotsFooter.style.display = 'block';

                        // Update Sidebar Summary Time
                        if (summaryTimeRow) summaryTimeRow.style.display = 'flex';
                        if (summaryTime) summaryTime.textContent = slot.time;
                    };
                    slotsList.appendChild(btn);
                });
                // Hide footer initially (will show when slot is selected)
                if (slotsFooter) slotsFooter.style.display = 'none';
            }
        }
    }
</script>

