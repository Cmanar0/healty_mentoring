{% load static %}

<!-- Slot Settings Popup -->
<div id="slotSettingsPopup" class="slot-settings-popup" aria-hidden="true">
  <div class="slot-settings-backdrop" data-close-slot-settings></div>
  <div class="slot-settings-content">
    <button class="slot-settings-close" data-close-slot-settings aria-label="Close">Ã—</button>
    
    <!-- Availability Slot Content -->
    <div id="availabilitySlotContent" class="slot-settings-section" style="display: none;">
      <h3 class="slot-settings-title">Availability Slot Settings</h3>
      
      <div class="slot-settings-field">
        <label for="slotStartTime" class="slot-settings-label">Starting Time</label>
        <input type="time" id="slotStartTime" class="slot-settings-input" />
      </div>
      
      <div class="slot-settings-field">
        <label class="slot-settings-label">Session Length</label>
        <div class="session-length-display-group">
          <span id="slotSessionLength" class="session-length-value-text"></span>
          <a href="{% url 'general:dashboard_mentor:profile' %}#session-configuration" class="session-length-change-link" id="changeSessionLengthLink">
            Change
          </a>
        </div>
      </div>
    </div>
    
    <!-- Session Slot Content -->
    <div id="sessionSlotContent" class="slot-settings-section" style="display: none;">
      <h3 class="slot-settings-title">Session</h3>
      <p class="session-slot-text">This is a scheduled session.</p>
    </div>
  </div>
</div>

<style>
/* Slot Settings Popup Styles */
.slot-settings-popup {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 3000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s ease, visibility 0.2s ease;
  pointer-events: none;
}

.slot-settings-popup.is-visible {
  opacity: 1;
  visibility: visible;
  pointer-events: auto;
}

.slot-settings-backdrop {
  position: absolute;
  inset: 0;
  background: rgba(15, 23, 42, 0.3);
  backdrop-filter: blur(2px);
  -webkit-backdrop-filter: blur(2px);
}

.slot-settings-content {
  position: absolute;
  background: #ffffff;
  border-radius: 12px;
  box-shadow: 
    0 20px 25px -5px rgba(0, 0, 0, 0.1),
    0 10px 10px -5px rgba(0, 0, 0, 0.04),
    0 0 0 1px rgba(0, 0, 0, 0.05);
  padding: 24px;
  min-width: 320px;
  max-width: 400px;
  z-index: 3001;
  transform: scale(0.95);
  transition: transform 0.2s ease;
}

.slot-settings-popup.is-visible .slot-settings-content {
  transform: scale(1);
}

.slot-settings-close {
  position: absolute;
  top: 12px;
  right: 12px;
  width: 32px;
  height: 32px;
  border: none;
  background: transparent;
  border-radius: 50%;
  cursor: pointer;
  color: #94a3b8;
  font-size: 1.5rem;
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.slot-settings-close:hover {
  background: #f1f5f9;
  color: #64748b;
}

.slot-settings-title {
  margin: 0 0 20px 0;
  font-size: 1.25rem;
  font-weight: 700;
  color: #0f172a;
  letter-spacing: -0.025em;
}

.slot-settings-section {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.slot-settings-field {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.slot-settings-label {
  font-size: 0.875rem;
  font-weight: 600;
  color: #334155;
}

.slot-settings-input {
  padding: 10px 12px;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  font-size: 0.875rem;
  color: #0f172a;
  background: #ffffff;
  transition: all 0.2s ease;
  font-family: inherit;
}

.slot-settings-input:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.session-length-display-group {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  background: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
}

.session-length-value-text {
  font-size: 0.875rem;
  color: #64748b;
  font-weight: 500;
}

.session-length-change-link {
  font-size: 0.875rem;
  color: #3b82f6;
  text-decoration: none;
  font-weight: 600;
  transition: color 0.2s ease;
}

.session-length-change-link:hover {
  color: #2563eb;
  text-decoration: underline;
}

.session-slot-text {
  margin: 0;
  font-size: 0.875rem;
  color: #64748b;
  line-height: 1.5;
}
</style>

<script>
(function() {
  const popup = document.getElementById('slotSettingsPopup');
  const backdrop = document.querySelector('.slot-settings-backdrop');
  const closeTriggers = document.querySelectorAll('[data-close-slot-settings]');
  const availabilityContent = document.getElementById('availabilitySlotContent');
  const sessionContent = document.getElementById('sessionSlotContent');
  const startTimeInput = document.getElementById('slotStartTime');
  const sessionLengthDisplay = document.getElementById('slotSessionLength');
  const changeLink = document.getElementById('changeSessionLengthLink');
  
  let currentSlotEvent = null;
  let mentorTimezone = 'UTC';
  
  // Get session length from userProfileData
  function getSessionLength() {
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const data = JSON.parse(dataEl.textContent);
        return data.session_length || 60;
      }
    } catch (e) {
      console.warn('Could not get session_length:', e);
    }
    return 60;
  }
  
  // Resolve mentor timezone
  function resolveMentorTimezone() {
    try {
      const el = document.getElementById('userProfileData');
      if (el && el.textContent) {
        const data = JSON.parse(el.textContent);
        if (data.selected_timezone) return data.selected_timezone;
        if (data.detected_timezone) return data.detected_timezone;
      }
    } catch (e) {}
    try { 
      return Intl.DateTimeFormat().resolvedOptions().timeZone; 
    } catch (e) { 
      return 'UTC'; 
    }
  }
  
  // Format time for input (HH:MM)
  function formatTimeForInput(date, timezone) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        timeZone: timezone,
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
      });
      return formatter.format(date).replace(':', '');
    } catch (e) {
      // Fallback: use local time
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      return hours + minutes;
    }
  }
  
  // Position popup relative to slot
  function positionPopup(eventElement, popupElement) {
    if (!eventElement || !popupElement) return;
    
    const rect = eventElement.getBoundingClientRect();
    const popupRect = popupElement.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const padding = 16;
    
    // Calculate available space in each direction
    const spaceAbove = rect.top;
    const spaceBelow = viewportHeight - rect.bottom;
    const spaceLeft = rect.left;
    const spaceRight = viewportWidth - rect.right;
    
    // Determine best position
    let top, left;
    
    // Try right first
    if (spaceRight >= popupRect.width + padding) {
      top = rect.top + (rect.height / 2) - (popupRect.height / 2);
      left = rect.right + padding;
      // Ensure it stays within viewport
      if (top < padding) top = padding;
      if (top + popupRect.height > viewportHeight - padding) {
        top = viewportHeight - popupRect.height - padding;
      }
    }
    // Try left
    else if (spaceLeft >= popupRect.width + padding) {
      top = rect.top + (rect.height / 2) - (popupRect.height / 2);
      left = rect.left - popupRect.width - padding;
      if (top < padding) top = padding;
      if (top + popupRect.height > viewportHeight - padding) {
        top = viewportHeight - popupRect.height - padding;
      }
    }
    // Try below
    else if (spaceBelow >= popupRect.height + padding) {
      top = rect.bottom + padding;
      left = rect.left + (rect.width / 2) - (popupRect.width / 2);
      if (left < padding) left = padding;
      if (left + popupRect.width > viewportWidth - padding) {
        left = viewportWidth - popupRect.width - padding;
      }
    }
    // Try above
    else if (spaceAbove >= popupRect.height + padding) {
      top = rect.top - popupRect.height - padding;
      left = rect.left + (rect.width / 2) - (popupRect.width / 2);
      if (left < padding) left = padding;
      if (left + popupRect.width > viewportWidth - padding) {
        left = viewportWidth - popupRect.width - padding;
      }
    }
    // Fallback: center on screen
    else {
      top = (viewportHeight - popupRect.height) / 2;
      left = (viewportWidth - popupRect.width) / 2;
    }
    
    popupElement.style.top = top + 'px';
    popupElement.style.left = left + 'px';
  }
  
  // Open popup
  function openSlotSettings(event, slotEvent) {
    if (!popup || !slotEvent) return;
    
    currentSlotEvent = slotEvent;
    mentorTimezone = resolveMentorTimezone();
    
    const slotType = slotEvent.extendedProps?.type || 'availability_slot';
    
    // Show appropriate content
    if (slotType === 'availability_slot') {
      availabilityContent.style.display = 'flex';
      sessionContent.style.display = 'none';
      
      // Set start time
      const startDate = new Date(slotEvent.start);
      const timeString = formatTimeForInput(startDate, mentorTimezone);
      if (startTimeInput) {
        startTimeInput.value = timeString.substring(0, 2) + ':' + timeString.substring(2);
      }
      
      // Set session length display
      const sessionLength = getSessionLength();
      if (sessionLengthDisplay) {
        sessionLengthDisplay.textContent = sessionLength + ' minutes';
      }
    } else if (slotType === 'session') {
      availabilityContent.style.display = 'none';
      sessionContent.style.display = 'flex';
    }
    
    // Position popup
    // Try multiple ways to get the event element
    let eventElement = null;
    if (event.el) {
      eventElement = event.el; // FullCalendar provides the DOM element directly
    } else if (event.jsEvent && event.jsEvent.target) {
      eventElement = event.jsEvent.target.closest('.fc-event');
    } else if (event.domEvent && event.domEvent.target) {
      eventElement = event.domEvent.target.closest('.fc-event');
    }
    
    const popupContent = popup.querySelector('.slot-settings-content');
    if (eventElement && popupContent) {
      // Wait a moment for popup to be visible so we can measure it
      setTimeout(() => {
        positionPopup(eventElement, popupContent);
      }, 10);
    } else if (popupContent) {
      // Fallback: center on screen
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const popupRect = popupContent.getBoundingClientRect();
      popupContent.style.top = ((viewportHeight - popupRect.height) / 2) + 'px';
      popupContent.style.left = ((viewportWidth - popupRect.width) / 2) + 'px';
    }
    
    // Show popup
    popup.classList.add('is-visible');
  }
  
  // Close popup
  function closeSlotSettings() {
    if (popup) {
      popup.classList.remove('is-visible');
      currentSlotEvent = null;
    }
  }
  
  // Convert a date/time in mentor's timezone to UTC
  // Uses a simple iterative approach to find the correct UTC time
  function convertMentorTimeToUTC(year, month, day, hours, minutes) {
    // Create a date string in ISO format
    const dateStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:00`;
    
    // Start with a guess: treat the date string as UTC
    let utcDate = new Date(dateStr + 'Z');
    
    // Format in mentor's timezone to see what we get
    const formatter = new Intl.DateTimeFormat('en-US', {
      timeZone: mentorTimezone,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
    
    // Iterate to find the correct UTC time (usually converges in 1-2 iterations)
    for (let i = 0; i < 5; i++) {
      const parts = formatter.formatToParts(utcDate);
      const formattedYear = parseInt(parts.find(p => p.type === 'year').value);
      const formattedMonth = parseInt(parts.find(p => p.type === 'month').value);
      const formattedDay = parseInt(parts.find(p => p.type === 'day').value);
      const formattedHour = parseInt(parts.find(p => p.type === 'hour').value);
      const formattedMinute = parseInt(parts.find(p => p.type === 'minute').value);
      
      // Check if we have the right time
      if (formattedYear === year && formattedMonth === month && formattedDay === day && 
          formattedHour === hours && formattedMinute === minutes) {
        break; // Found it!
      }
      
      // Calculate adjustment needed
      // Create date objects in local time to compare
      const targetLocal = new Date(year, month - 1, day, hours, minutes);
      const formattedLocal = new Date(formattedYear, formattedMonth - 1, formattedDay, formattedHour, formattedMinute);
      const diffMs = targetLocal.getTime() - formattedLocal.getTime();
      
      // Adjust UTC date
      utcDate = new Date(utcDate.getTime() + diffMs);
    }
    
    return utcDate;
  }
  
  // Handle start time change
  if (startTimeInput) {
    startTimeInput.addEventListener('change', function() {
      if (!currentSlotEvent) return;
      
      // Parse the time input
      const [hours, minutes] = this.value.split(':').map(Number);
      
      // Get the current slot date (in UTC)
      const currentStart = new Date(currentSlotEvent.start);
      
      // Convert current UTC date to mentor's timezone to get the date components
      const formatter = new Intl.DateTimeFormat('en-US', {
        timeZone: mentorTimezone,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
      });
      
      const parts = formatter.formatToParts(currentStart);
      const year = parseInt(parts.find(p => p.type === 'year').value);
      const month = parseInt(parts.find(p => p.type === 'month').value);
      const day = parseInt(parts.find(p => p.type === 'day').value);
      
      // Convert the new time from mentor's timezone to UTC
      const utcStart = convertMentorTimeToUTC(year, month, day, hours, minutes);
      const utcEnd = new Date(utcStart.getTime() + (getSessionLength() * 60 * 1000));
      
      // Update the event
      currentSlotEvent.setStart(utcStart.toISOString());
      currentSlotEvent.setEnd(utcEnd.toISOString());
      
      // Update tracking array if it exists
      if (typeof window.updateSlotInTracking === 'function') {
        window.updateSlotInTracking(currentSlotEvent);
      }
    });
  }
  
  // Close handlers
  if (closeTriggers.length > 0) {
    closeTriggers.forEach(trigger => {
      trigger.addEventListener('click', closeSlotSettings);
    });
  }
  
  if (backdrop) {
    backdrop.addEventListener('click', closeSlotSettings);
  }
  
  // Close on Escape key
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && popup && popup.classList.contains('is-visible')) {
      closeSlotSettings();
    }
  });
  
  // Handle change link click - close popup and navigate
  if (changeLink) {
    changeLink.addEventListener('click', function(e) {
      e.preventDefault();
      closeSlotSettings();
      // Close calendar overlay if open
      const calendarOverlay = document.getElementById('availabilityCalendarOverlay');
      if (calendarOverlay) {
        calendarOverlay.classList.remove('is-visible');
      }
      // Navigate to profile page
      window.location.href = this.href;
    });
  }
  
  // Expose function globally for calendar to use
  window.openSlotSettings = openSlotSettings;
  window.closeSlotSettings = closeSlotSettings;
})();
</script>

