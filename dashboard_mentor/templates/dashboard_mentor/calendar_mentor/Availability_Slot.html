{# Template used by the mentor calendar popup for rendering an "Availability" slot #}
<template id="mentorCalendarAvailabilitySlotTemplate">
  <div class="mentor-calendar-slot mentor-calendar-slot--availability" data-slot-root>
    <button type="button" class="mentor-calendar-slot-delete" aria-label="Delete availability slot" data-slot-delete>
      ×
    </button>
    <div class="mentor-calendar-slot-body" data-slot-body>
      <div class="mentor-calendar-slot-title">
        Available
      </div>
      <div class="mentor-calendar-slot-time" data-slot-time></div>
    </div>
    <div class="mentor-calendar-slot-meta" data-slot-meta>
      <div class="mentor-calendar-slot-duration" data-slot-duration>-- min</div>

      <div class="custom-dropdown-container mentor-calendar-recurrence-dropdown" data-recurrence-dropdown>
        <button type="button" class="custom-dropdown-trigger mentor-calendar-recurrence-trigger" aria-label="Recurrence" data-recurrence-trigger>
          <span class="dropdown-selected-text" data-recurrence-selected>No repeat</span>
          <span class="mentor-calendar-recurrence-chevron" aria-hidden="true">▾</span>
        </button>
        <input type="hidden" value="none" data-recurrence-input />
        <div class="custom-dropdown-menu mentor-calendar-recurrence-menu" data-recurrence-menu>
          <button type="button" class="dropdown-item first-item active" data-value="none">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>
            </svg>
            <span>No repeat</span>
          </button>
          <button type="button" class="dropdown-item" data-value="daily">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path>
              <path d="M21 3v5h-5"></path>
              <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path>
              <path d="M8 16H3v5"></path>
            </svg>
            <span>Daily</span>
          </button>
          <button type="button" class="dropdown-item" data-value="weekly">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
              <line x1="16" y1="2" x2="16" y2="6"></line>
              <line x1="8" y1="2" x2="8" y2="6"></line>
              <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>
            <span>Weekly</span>
          </button>
          <button type="button" class="dropdown-item last-item" data-value="monthly">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
              <line x1="16" y1="2" x2="16" y2="6"></line>
              <line x1="8" y1="2" x2="8" y2="6"></line>
              <line x1="3" y1="10" x2="21" y2="10"></line>
              <line x1="8" y1="14" x2="8" y2="14.01"></line>
            </svg>
            <span>Monthly</span>
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<style>
  /* Availability slot styles (kept with the template for separation of concerns) */
  .mentor-calendar-slot {
    position: relative;
    display: flex;
    justify-content: space-between;
    flex-direction: column;
    padding: 0;
    border-radius: var(--mentor-calendar-slot-radius, 10px);
    color: #ffffff;
    overflow: hidden;
    box-sizing: border-box;
  }

  .mentor-calendar-slot-body {
    display: flex;
    flex-direction: column;
    gap: 2px;
    padding: 6px 8px 0px;
  }

  .mentor-calendar-slot-title {
    font-weight: 700;
    font-size: 0.85rem;
    line-height: 1.1;
  }
  .mentor-calendar-slot-time {
    font-weight: 600;
    font-size: 0.8rem;
    opacity: 0.95;
  }

  .mentor-calendar-slot-meta {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 14px; /* extra space between minutes and dropdown */
    padding: 8px 8px 0px;
  }

  .mentor-calendar-slot-duration {
    font-weight: 700;
    font-size: 0.75rem;
    opacity: 0.95;
    white-space: nowrap;
  }

  /* --- Recurrence dropdown (scoped; follows DROPDOWN_MENU_STYLE_GUIDE.md) --- */
  .mentor-calendar-recurrence-dropdown {
    position: relative;
    flex: 0 1 auto;
    width: auto;           /* fixed width so it won't overflow the slot */
    max-width: 100px;         /* but still shrink in narrow slots */
  }

  .mentor-calendar-recurrence-trigger.custom-dropdown-trigger {
    padding: 4px 0px;
    border-radius: 8px;
    border: 0px solid rgba(255, 255, 255, 0.65);
    background: rgba(255, 255, 255, 0) !important;
    color: #ffffff;
    font-size: 0.8rem;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    cursor: pointer;
  }

  .mentor-calendar-recurrence-trigger .dropdown-selected-text {
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  /* Per style guide: no trigger background change on hover */
  .mentor-calendar-recurrence-trigger.custom-dropdown-trigger:hover {
    background: rgba(255, 255, 255, 0) !important;
    border-color: rgba(255, 255, 255, 0);
  }

  .mentor-calendar-recurrence-chevron {
    font-size: 0.75rem;
    opacity: 0.8;
    transition: transform 0.2s ease;
  }

  .mentor-calendar-recurrence-dropdown.active .mentor-calendar-recurrence-chevron {
    transform: rotate(180deg);
  }

  .mentor-calendar-recurrence-menu.custom-dropdown-menu {
    position: absolute;
    right: 0;
    left: auto;
    min-width: 200px;
    background: #ffffff;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    padding: 0; /* critical: no padding on container */
    z-index: 30000; /* above all calendar slots/events */
    opacity: 0;
    visibility: hidden;
    transform: translateY(-10px);
    transition: all 0.2s ease;
  }

  /* In-slot menu is used as a template; actual menu is rendered "floating" above calendar */
  .mentor-calendar-recurrence-menu.custom-dropdown-menu {
    display: none;
  }

  .mentor-calendar-floating-recurrence-menu {
    position: fixed;
    background: #ffffff;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.25);
    padding: 0; /* critical: no padding on container */
    z-index: 50000; /* above all calendar slots/events */
    min-width: 200px;
    max-width: calc(100vw - 16px);
    opacity: 1;
    visibility: visible;
    transform: none;
  }

  .mentor-calendar-recurrence-menu .dropdown-item,
  .mentor-calendar-floating-recurrence-menu .dropdown-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 20px;
    color: #1e293b; /* --dash-text-main */
    text-decoration: none;
    transition: background 0.2s ease;
    border: none;
    background: transparent;
    width: 100%;
    cursor: pointer;
    font-size: 0.95rem;
    font-weight: 400;
    text-align: left;
  }

  .mentor-calendar-recurrence-menu .dropdown-item:hover,
  .mentor-calendar-floating-recurrence-menu .dropdown-item:hover {
    background: rgba(16, 185, 129, 0.1);
    color: #10b981; /* --dash-primary */
  }

  /* Maintain rounded corners on hover (per style guide) */
  .mentor-calendar-recurrence-menu .dropdown-item.first-item,
  .mentor-calendar-floating-recurrence-menu .dropdown-item.first-item {
    border-radius: 12px 12px 0 0;
  }
  .mentor-calendar-recurrence-menu .dropdown-item.last-item,
  .mentor-calendar-floating-recurrence-menu .dropdown-item.last-item {
    border-radius: 0 0 12px 12px;
  }
  .mentor-calendar-recurrence-menu .dropdown-item.first-item:hover,
  .mentor-calendar-floating-recurrence-menu .dropdown-item.first-item:hover {
    border-radius: 12px 12px 0 0;
  }
  .mentor-calendar-recurrence-menu .dropdown-item.last-item:hover,
  .mentor-calendar-floating-recurrence-menu .dropdown-item.last-item:hover {
    border-radius: 0 0 12px 12px;
  }
  .mentor-calendar-slot--availability {
    background: rgba(59, 131, 246, 0); /* blue */
  }

  .mentor-calendar-slot-delete {
    position: absolute;
    top: 4px;
    right: 6px;
    width: 18px;
    height: 18px;
    border: none;
    border-radius: 6px;
    background: rgba(15, 23, 42, 0.18);
    color: rgba(255, 255, 255, 0.95);
    font-size: 16px;
    line-height: 18px;
    padding: 0;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
  .mentor-calendar-slot-delete:hover {
    background: rgba(239, 68, 68, 0.95);
  }
</style>

<script>
// Availability slot "component" (keeps per-slot logic here, not in calendar.html)
window.MentorCalendarSlotComponents = window.MentorCalendarSlotComponents || {};
window.MentorCalendarSlotComponents.AvailabilitySlot = {
  mount(el, props) {
    if (!el) return;
    el.dataset.slotMode = props?.slotMode || 'availability';
    el.dataset.isAvailabilityMode = String(!!props?.isAvailabilityMode);
    el.dataset.timezone = props?.timezone || '';
    el.dataset.eventId = props?.eventId || '';

    // Duration (minutes)
    try {
      const startIso = props?.startIso;
      const endIso = props?.endIso;
      const durationEl = el.querySelector('[data-slot-duration]');
      if (durationEl && startIso && endIso) {
        const startMs = new Date(startIso).getTime();
        const endMs = new Date(endIso).getTime();
        const minutes = Math.max(0, Math.round((endMs - startMs) / 60000));
        durationEl.textContent = `${minutes} min`;
      }
    } catch (e) {
      // Non-fatal (UI will show "-- min")
      console.warn('[AvailabilitySlot] duration compute failed:', e);
    }

    // Recurrence dropdown (client-only; does not persist yet)
    const dropdown = el.querySelector('[data-recurrence-dropdown]');
    if (dropdown) {
      window.MentorCalendarRecurrenceSelections = window.MentorCalendarRecurrenceSelections || {};
      const trigger = dropdown.querySelector('[data-recurrence-trigger]');
      const selectedText = dropdown.querySelector('[data-recurrence-selected]');
      // New: container for the specific icon in the trigger
      let selectedIconContainer = dropdown.querySelector('[data-recurrence-selected-icon]');
      
      // Inject icon container if missing (helper for migration)
      if (!selectedIconContainer && trigger) {
        selectedIconContainer = document.createElement('span');
        selectedIconContainer.setAttribute('data-recurrence-selected-icon', '');
        selectedIconContainer.style.display = 'flex';
        selectedIconContainer.style.alignItems = 'center';
        trigger.insertBefore(selectedIconContainer, trigger.firstChild);
      }

      const input = dropdown.querySelector('[data-recurrence-input]');
      const items = Array.from(dropdown.querySelectorAll('.dropdown-item'));
      const eventId = props?.eventId || '';
      const recurringId = props?.recurringId || '';
      // Source of truth for recurrence selection:
      // - recurring slot: key by recurringId so all instances share one value
      // - one-time slot: key by eventId
      const recurrenceKey = recurringId || eventId;

      const updateTriggerVisuals = (item) => {
        if (!item) return;
        const text = item.querySelector('span')?.textContent?.trim() || '';
        const svg = item.querySelector('svg');

        if (selectedText) selectedText.textContent = text;
        
        if (selectedIconContainer) {
          selectedIconContainer.innerHTML = ''; // prevent accumulation
          if (svg) {
            const cloned = svg.cloneNode(true);
            cloned.setAttribute('width', '14'); // slightly smaller for trigger
            cloned.setAttribute('height', '14');
            selectedIconContainer.appendChild(cloned);
          }
        }
      };

      const fcEventEl = el.closest?.('.fc-event');
      const setDropdownOpen = (isOpen) => {
        if (!fcEventEl) return;
        fcEventEl.classList.toggle('is-dropdown-open', !!isOpen);
      };

      // ---- Floating menu (renders outside FullCalendar stacking contexts) ----
      const globalState = (window.__mentorCalendarRecurrenceFloatingState = window.__mentorCalendarRecurrenceFloatingState || {
        menuEl: null,
        ownerDropdown: null,
        ownerEventId: null,
        onReposition: null
      });

      const closeFloatingMenu = () => {
        if (globalState.menuEl) {
          globalState.menuEl.remove();
          globalState.menuEl = null;
        }
        if (globalState.onReposition) {
          window.removeEventListener('resize', globalState.onReposition);
          window.removeEventListener('scroll', globalState.onReposition, { capture: true });
          globalState.onReposition = null;
        }
        if (globalState.ownerDropdown) {
          globalState.ownerDropdown.classList.remove('active');
          globalState.ownerDropdown = null;
        }
        if (globalState.ownerEventId) {
          document.querySelectorAll('.fc-event.is-dropdown-open').forEach(ev => ev.classList.remove('is-dropdown-open'));
          globalState.ownerEventId = null;
        }
      };

      const positionFloatingMenu = (menuEl) => {
        if (!trigger) return;
        const rect = trigger.getBoundingClientRect();

        // Decide direction based on trigger position (upper half -> down, lower half -> up)
        const midY = rect.top + rect.height / 2;
        const openUp = midY > (window.innerHeight / 2);

        // Measure after it exists in DOM
        const m = menuEl.getBoundingClientRect();
        const margin = 8;

        let top = openUp ? (rect.top - margin - m.height) : (rect.bottom + margin);
        // Clamp vertically into viewport if needed
        top = Math.max(margin, Math.min(top, window.innerHeight - m.height - margin));

        let left = rect.right - m.width;
        left = Math.max(margin, Math.min(left, window.innerWidth - m.width - margin));

        menuEl.style.top = `${Math.round(top)}px`;
        menuEl.style.left = `${Math.round(left)}px`;
      };

      const openFloatingMenu = () => {
        closeFloatingMenu();

        dropdown.classList.add('active');
        setDropdownOpen(true);

        const templateMenu = dropdown.querySelector('[data-recurrence-menu]');
        if (!templateMenu) return;

        const menuEl = templateMenu.cloneNode(true);
        // Remove "custom-dropdown-menu" behavior (which defaults to hidden unless .active container)
        menuEl.classList.remove('custom-dropdown-menu');
        menuEl.classList.remove('mentor-calendar-recurrence-menu');
        menuEl.classList.add('mentor-calendar-floating-recurrence-menu');
        menuEl.style.display = 'block';
        menuEl.style.opacity = '1';
        menuEl.style.visibility = 'visible';
        menuEl.style.transform = 'none';

        // Sync active item inside the floating menu based on current selection
        const currentValue = (recurrenceKey && window.MentorCalendarRecurrenceSelections[recurrenceKey])
          ? window.MentorCalendarRecurrenceSelections[recurrenceKey]
          : (input?.value || 'none');
        const floatingItems = Array.from(menuEl.querySelectorAll('.dropdown-item'));
        floatingItems.forEach(i => i.classList.remove('active'));
        const activeItem = floatingItems.find(i => (i.getAttribute('data-value') || 'none') === currentValue) || floatingItems[0];
        if (activeItem) activeItem.classList.add('active');

        // Prevent drag start + handle selection
        floatingItems.forEach((item) => {
          item.addEventListener('pointerdown', (e) => e.stopPropagation());
          item.addEventListener('mousedown', (e) => e.stopPropagation());
          item.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const value = item.getAttribute('data-value') || 'none';
            
            // Find logic counterpart in "items" to grab text/icon source of truth
            const templateCounterpart = items.find(i => (i.getAttribute('data-value') || 'none') === value);
            updateTriggerVisuals(templateCounterpart || item);

            if (input) input.value = value;
            
            // Keep the in-slot template state in sync too (helps on rerender)
            items.forEach(i => i.classList.remove('active'));
            if (templateCounterpart) templateCounterpart.classList.add('active');

            el.dataset.recurrence = value;
            if (recurrenceKey) window.MentorCalendarRecurrenceSelections[recurrenceKey] = value;

            // Notify calendar logic so it can render/persist recurring rules.
            if (typeof window.MentorCalendarInternal?.setRecurrenceForEvent === 'function') {
              window.MentorCalendarInternal.setRecurrenceForEvent({
                eventId,
                recurringId,
                instanceDate: props?.instanceDate || '',
                value
              });
            }

            closeFloatingMenu();
          });
        });

        // Add to DOM, measure, position
        document.body.appendChild(menuEl);
        positionFloatingMenu(menuEl);

        // Keep positioned while open
        const onReposition = () => positionFloatingMenu(menuEl);
        window.addEventListener('resize', onReposition, { passive: true });
        window.addEventListener('scroll', onReposition, { passive: true, capture: true });

        globalState.menuEl = menuEl;
        globalState.ownerDropdown = dropdown;
        globalState.ownerEventId = eventId || 'unknown';
        globalState.onReposition = onReposition;
      };

      const toggleFloatingMenu = () => {
        if (globalState.ownerDropdown === dropdown && dropdown.classList.contains('active')) {
          closeFloatingMenu();
        } else {
          openFloatingMenu();
        }
      };

      if (trigger) {
        // Prevent drag start when interacting with the dropdown trigger
        trigger.addEventListener('pointerdown', (e) => e.stopPropagation());
        trigger.addEventListener('mousedown', (e) => e.stopPropagation());
        trigger.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleFloatingMenu();
        });
      }

      // Restore previously selected value (keeps selection visible across rerenders)
      const restoredValue = (recurrenceKey && window.MentorCalendarRecurrenceSelections[recurrenceKey])
        ? window.MentorCalendarRecurrenceSelections[recurrenceKey]
        : (input?.value || 'none');
      const restoredItem = items.find(i => (i.getAttribute('data-value') || 'none') === restoredValue) || items[0];
      if (restoredItem) {
        updateTriggerVisuals(restoredItem);
        if (input) input.value = restoredValue;
        items.forEach(i => i.classList.remove('active'));
        restoredItem.classList.add('active');
        el.dataset.recurrence = restoredValue;
      }

      // One global outside-click handler (close on outside click)
      if (!window.__mentorCalendarRecurrenceDropdownBound) {
        window.__mentorCalendarRecurrenceDropdownBound = true;
        document.addEventListener('click', (e) => {
          const target = e.target;
          if (!(target instanceof Element)) return;
          if (target.closest('.mentor-calendar-recurrence-dropdown')) return;
          if (target.closest('.mentor-calendar-floating-recurrence-menu')) return;
          closeFloatingMenu();
        });
      }
    }

    const deleteBtn = el.querySelector('[data-slot-delete]');
    if (deleteBtn) {
      // Prevent drag start when interacting with the button
      deleteBtn.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
      });
      deleteBtn.addEventListener('mousedown', (e) => {
        e.stopPropagation();
      });
      deleteBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const eventId = props?.eventId;
        if (!eventId) return;
        window.MentorCalendarInternal?.removeEventById?.(eventId);
      });
    }
  }
};
</script>


