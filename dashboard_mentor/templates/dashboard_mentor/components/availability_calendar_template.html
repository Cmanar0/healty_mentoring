{% load static %}

<!-- ===================== AVAILABILITY CALENDAR MODAL ===================== -->
<div id="availabilityCalendarOverlay" class="availability-calendar-overlay" aria-hidden="true">
  <div class="availability-calendar-backdrop" data-close-availability-calendar></div>

  <div class="availability-calendar-modal">
    <header class="availability-calendar-header">
      <div class="availability-calendar-title-group">
        <h2>Manage Sessions & Availability</h2>
        <p class="availability-calendar-subtitle">
          <span class="timezone-label">Your Timezone</span>
          <span class="timezone-value" id="timezoneDisplayValue">UTC+01</span>
          <span class="timezone-time" id="timezoneTimeDisplay">--:--:--</span>
          <a href="{% url 'general:dashboard_mentor:profile' %}#timezone-section" class="timezone-change-link">Change</a>
        </p>
      </div>

      <div class="availability-calendar-toggle-group">
        <button class="availability-calendar-toggle-btn" id="availabilityCalendarToggle" aria-label="Toggle view">
          <span class="toggle-label">Sessions</span>
          <span class="toggle-switch">
            <span class="toggle-slider"></span>
          </span>
          <span class="toggle-label">Availability</span>
        </button>
      </div>

      <div class="availability-calendar-nav">
        <button class="calendar-nav-btn" data-calendar-nav="prev" aria-label="Previous">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <div class="calendar-date-display" id="calendarDateDisplay">Loading...</div>
        <button class="calendar-nav-btn" data-calendar-nav="next" aria-label="Next">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>

      <div class="availability-calendar-header-actions">
        <button class="calendar-nav-btn" data-calendar-nav="today" aria-label="Today">Today</button>
        <div class="availability-calendar-view-toggle">
          <button class="view-toggle-btn" data-calendar-view="timeGridDay">Day</button>
          <button class="view-toggle-btn is-active" data-calendar-view="timeGridWeek">Week</button>
          <button class="view-toggle-btn" data-calendar-view="dayGridMonth">Month</button>
        </div>
        <button class="availability-calendar-save-btn" id="availabilityCalendarSaveBtn" disabled>Save</button>
        <button class="availability-calendar-close-btn" data-close-availability-calendar>âœ•</button>
      </div>
    </header>

    <section class="availability-calendar-body">
      <div id="mentorAvailabilityCalendar" class="availability-calendar-root"></div>
    </section>
  </div>
</div>


<!-- ===================== FullCalendar v6 CSS ===================== -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.css">

<!-- ===================== FullCalendar v6 JS (core + plugins) ===================== -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/locales-all.global.min.js"></script>

<!-- ===================== CSS ===================== -->
<style>
/* Overlay */
.availability-calendar-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(15, 23, 42, 0.6);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  z-index: 2000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}
.availability-calendar-overlay.is-visible { 
  opacity: 1;
  visibility: visible;
}

/* Modal */
.availability-calendar-modal {
  background: #ffffff;
  width: 95%;
  max-width: 1400px;
  height: 90vh;
  border-radius: 24px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 
    0 25px 50px -12px rgba(0, 0, 0, 0.25),
    0 0 0 1px rgba(0, 0, 0, 0.05); /* Subtle border ring */
  transform: translateY(20px);
  transition: transform 0.3s ease, opacity 0.3s ease;
  opacity: 0;
}

.availability-calendar-overlay.is-visible .availability-calendar-modal {
  transform: translateY(0);
  opacity: 1;
}

/* Header */
.availability-calendar-header {
  padding: 20px 32px;
  background: #ffffff;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 24px;
}

.availability-calendar-title-group {
  flex: 1;
  min-width: 0;
}

.availability-calendar-title-group h2 {
  margin: 0;
  font-size: 1.5rem;
  font-weight: 700;
  color: #0f172a;
  letter-spacing: -0.025em;
  line-height: 1.2;
}

.availability-calendar-title-group .availability-calendar-subtitle {
  margin: 4px 0 0 0;
  font-size: 0.875rem;
  color: #64748b;
  font-weight: 400;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.availability-calendar-subtitle .timezone-label {
  font-weight: 500;
}

.availability-calendar-subtitle .timezone-value {
  font-weight: 500;
}

.availability-calendar-subtitle .timezone-time {
  font-weight: 600;
  font-variant-numeric: tabular-nums;
  color: #334155;
  font-family: 'Courier New', monospace;
}

.availability-calendar-subtitle .timezone-change-link {
  color: var(--dash-primary, #3b82f6);
  text-decoration: none;
  font-weight: 500;
  margin-left: 4px;
  transition: color 0.2s ease;
}

.availability-calendar-subtitle .timezone-change-link:hover {
  color: #2563eb;
  text-decoration: underline;
}

/* Toggle Group */
.availability-calendar-toggle-group {
  display: flex;
  align-items: center;
}

.availability-calendar-toggle-btn {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 16px;
  background: #f0fdf4;
  border: 1px solid #10b981;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 0.875rem;
  font-weight: 500;
  color: #64748b;
}

.availability-calendar-toggle-btn:hover {
  background: #dcfce7;
  border-color: #059669;
}

.availability-calendar-toggle-btn .toggle-label {
  transition: color 0.2s ease;
  white-space: nowrap;
  font-weight: 600; /* Always bold */
}

.availability-calendar-toggle-btn .toggle-switch {
  position: relative;
  width: 44px;
  height: 24px;
  background: #10b981;
  border-radius: 12px;
  transition: background 0.2s ease;
}

.availability-calendar-toggle-btn.active .toggle-switch {
  background:  #3b82f6;
}

.availability-calendar-toggle-btn.active {
  background: #eff6ff; /* Light blue background */
  border-color: #3b82f6;
}

.availability-calendar-toggle-btn .toggle-slider {
  position: absolute;
  top: 2px;
  left: 2px;
  width: 20px;
  height: 20px;
  background: white;
  border-radius: 50%;
  transition: transform 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.availability-calendar-toggle-btn .toggle-slider::before {
  content: none;
}

.availability-calendar-toggle-btn.active .toggle-slider {
  transform: translateX(20px);
}

/* Sessions mode (not active) - Green */
.availability-calendar-toggle-btn:not(.active) .toggle-label:first-child {
  color: #10b981;
  font-weight: 600; /* Always bold */
}

.availability-calendar-toggle-btn:not(.active) .toggle-label:last-child {
  color: #64748b;
  font-weight: 600; /* Always bold */
}

/* Availability mode (active) - Blue */
.availability-calendar-toggle-btn.active .toggle-label:first-child {
  color: #64748b; /* Gray for Sessions label */
  font-weight: 600; /* Always bold */
}

.availability-calendar-toggle-btn.active .toggle-label:last-child {
  color: #3b82f6; /* Blue text for Availability label */
  font-weight: 600; /* Always bold */
}

/* Navigation Group */
.availability-calendar-nav {
  display: flex;
  min-width: 280px;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  background: #f8fafc;
  padding: 4px;
  border-radius: 12px;
  border: 1px solid #e2e8f0;
}

.calendar-nav-btn {
  border: none;
  background: transparent;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  cursor: pointer;
  color: #64748b;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.calendar-nav-btn:hover {
  background: #ffffff;
  color: #0f172a;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.calendar-date-display {
  padding: 0 16px;
  font-size: 0.925rem;
  font-weight: 600;
  color: #334155;
  white-space: nowrap;
  min-width: 140px;
  text-align: center;
  font-variant-numeric: tabular-nums;
}

/* Header Actions */
.availability-calendar-header-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}

/* Today Button */
.calendar-nav-btn[data-calendar-nav="today"] {
  width: auto;
  padding: 8px 20px;
  background: #f1f5f9;
  color: #475569;
  font-weight: 600;
  font-size: 0.875rem;
  height: 36px;
  border-radius: 10px;
}

/* View Toggle (Segmented Control) */
.availability-calendar-view-toggle {
  min-width: 240px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: #f1f5f9;
  border-radius: 10px;
  padding: 4px;
  gap: 0;
  border: 1px solid #e2e8f0;
}

.view-toggle-btn {
  padding: 6px 16px;
  border: none;
  cursor: pointer;
  border-radius: 8px;
  background: transparent;
  color: #64748b;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.2s ease;
  position: relative;
}

.view-toggle-btn:hover:not(.is-active) {
  color: #334155;
}

.view-toggle-btn.is-active {
  background: #3b82f6;
  color: #ffffff;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  font-weight: 600;
}

/* Save Button */
.availability-calendar-save-btn {
  border: none;
  background: #cbd5e1;
  color: #64748b;
  padding: 8px 20px;
  border-radius: 10px;
  cursor: not-allowed;
  font-size: 0.875rem;
  font-weight: 600;
  transition: all 0.2s ease;
  margin-left: 8px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Close Button */
.availability-calendar-close-btn {
  border: none;
  background: transparent;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  color: #94a3b8;
  font-size: 1.25rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  margin-left: 8px;
}

/* Body */
.availability-calendar-body {
  flex: 1;
  min-height: 0;
  display: flex;
  padding: 0; /* Remove padding for flush look */
  background: #f8fafc; /* Slight contrast for calendar area */
  position: relative;
}

.availability-calendar-root {
  flex: 1;
  min-height: 420px;
  border: none;
  background: #ffffff;
}

/* --- FullCalendar Overrides --- */

/* General Text */
.availability-calendar-root {
  font-family: inherit;
  --fc-border-color: #cbd5e1; /* Stronger, balanced border color */
  --fc-page-bg-color: #ffffff;
  --fc-neutral-bg-color: #f8fafc;
  --fc-today-bg-color: #f0fdf4;
  --fc-now-indicator-color: #ef4444;
}

/* Column layout for collisions (50/50) */
.availability-calendar-root.has-collisions .fc-timegrid-col-events {
  position: relative;
}

/* Force harness width to 50% for two-column layout */
.availability-calendar-root.has-collisions .fc-timegrid-event-harness {
  width: 50% !important;
}

/* Left column (original) */
.availability-calendar-root.has-collisions .fc-event.slot-original {
  left: 0 !important;
  width: calc(50% - 2px) !important;
  margin-right: 2px;
  background-color: #d1fae5 !important;
  border-left: 3px solid #10b981 !important;
  color: #065f46 !important;
  z-index: 2;
}

/* Right column (colliding) */
.availability-calendar-root.has-collisions .fc-event.slot-colliding {
  left: 50% !important;
  width: calc(50% - 2px) !important;
  margin-left: 2px;
  background-color: #fee2e2 !important;
  border-left: 3px solid #dc2626 !important;
  color: #7f1d1d !important;
  z-index: 3;
}

/* Visual separator between columns */
.availability-calendar-root.has-collisions .fc-timegrid-col-frame::after {
  content: '';
  position: absolute;
  left: 50%;
  top: 0;
  bottom: 0;
  width: 1px;
  background: #e2e8f0;
  z-index: 1;
  pointer-events: none;
}

/* Ensure events keep readable text */
.fc-event-main-frame, .fc-event-main {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Now Indicator */
.fc-timegrid-now-indicator-line {
  border-color: #ef4444;
  border-width: 2px;
}
.fc-timegrid-now-indicator-arrow {
  border-color: #ef4444;
  border-width: 6px;
}

/* Scrollbar */
.fc-scroller::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
.fc-scroller::-webkit-scrollbar-track {
  background: transparent;
}
.fc-scroller::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 4px;
}
</style>

<!-- ===================== JS ===================== -->
<script>
(function() {
  const overlay = document.getElementById("availabilityCalendarOverlay");
  const calendarRoot = document.getElementById("mentorAvailabilityCalendar");
  const openTriggers = document.querySelectorAll("[data-open-availability-calendar]");
  const closeTriggers = document.querySelectorAll("[data-close-availability-calendar]");
  const viewBtnEls = document.querySelectorAll("[data-calendar-view]");
  const subtitleEl = document.querySelector(".availability-calendar-subtitle");
  const timezoneValueEl = document.getElementById("timezoneDisplayValue");
  const timezoneTimeEl = document.getElementById("timezoneTimeDisplay");
  const dateDisplayEl = document.getElementById("calendarDateDisplay");

  // Utility: simple overlap check
  function rangesOverlap(aStart, aEnd, bStart, bEnd) {
    return new Date(aStart).getTime() < new Date(bEnd).getTime() &&
           new Date(bStart).getTime() < new Date(aEnd).getTime();
  }

  // Resolve timezone (simple fallback)
  function resolveMentorTimezone() {
    try {
      const el = document.getElementById('userProfileData');
      if (el && el.textContent) {
        const data = JSON.parse(el.textContent);
        if (data.selected_timezone) return data.selected_timezone;
        if (data.detected_timezone) return data.detected_timezone;
      }
    } catch (e) {}
    try { return Intl.DateTimeFormat().resolvedOptions().timeZone; } catch (e) { return 'UTC'; }
  }

  let calendar = null;
  let mentorTimezone = resolveMentorTimezone();
  let sessionLength = 60;
  let createdAvailabilitySlots = []; // {id, start, end, length, createdAt}
  const saveBtn = document.getElementById("availabilityCalendarSaveBtn");

  // Create an availability slot event object (with createdAt)
  function createAvailabilitySlotEvent(startDate, lengthMinutes) {
    const endDate = new Date(startDate.getTime() + lengthMinutes * 60 * 1000);
    const slotId = 'avail_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    const createdAt = Date.now();
    // Track our created slot record
    createdAvailabilitySlots.push({ id: slotId, start: startDate.toISOString(), end: endDate.toISOString(), length: lengthMinutes, createdAt });
    return {
      id: slotId,
      title: 'Available',
      start: startDate.toISOString(),
      end: endDate.toISOString(),
      classNames: ['availability-slot', 'slot-original'],
      extendedProps: {
        isAvailability: true,
        slotId: slotId,
        moved: false,      // manual move flag
        autoMoved: false,  // auto moved on creation because of collision
        createdAt: createdAt,
        length: lengthMinutes
      }
    };
  }

  // Check if event collides with any "original" events (events that are not moved/autoMoved yet)
  function collidesWithOriginals(event, originals) {
    for (const o of originals) {
      if (o.id === event.id) continue;
      if (rangesOverlap(event.start, event.end, o.start, o.end)) return true;
    }
    return false;
  }

  // Core: compute lanes for all availability events according to rules:
  // - Iterate events by createdAt ascending
  // - Keep a list of originals (left column)
  // - If event has moved===true, treat specially: it will be colliding if it overlaps any original; otherwise it becomes original again (dynamic reassignment)
  // - If event is not moved, and overlaps any existing original, mark autoMoved true (goes right); otherwise push to originals
  function computeAndApplyLanes() {
    if (!calendar) return;
    const all = calendar.getEvents().filter(e => e.extendedProps && e.extendedProps.isAvailability);
    // Map id -> plain object for easier sort/filter (we'll keep references to FullCalendar Event objects in a map)
    const events = all.map(e => ({ e, id: e.id, start: e.start, end: e.end, createdAt: e.extendedProps.createdAt || 0, moved: !!e.extendedProps.moved, autoMoved: !!e.extendedProps.autoMoved }));
    // sort by createdAt ascending
    events.sort((a,b) => (a.createdAt || 0) - (b.createdAt || 0));

    const originals = []; // store events considered original (left column)

    // First pass: consider non-moved events and moved events dynamic reassignment
    for (const ev of events) {
      const fcEvent = ev.e;
      // If it's marked as moved (manual), evaluate collision against originals
      if (ev.moved) {
        // If it collides with any original -> keep as moved/colliding
        const collides = collidesWithOriginals(ev, originals);
        if (collides) {
          // ensure extendedProps reflect moved=true, autoMoved=false
          fcEvent.setExtendedProp('moved', true);
          fcEvent.setExtendedProp('autoMoved', false);
        } else {
          // dynamic reassignment: it no longer collides with originals -> becomes original
          fcEvent.setExtendedProp('moved', false);
          fcEvent.setExtendedProp('autoMoved', false);
          originals.push({ id: fcEvent.id, start: fcEvent.start, end: fcEvent.end });
        }
      } else {
        // Not manually moved: check overlap with existing originals
        const collides = collidesWithOriginals(ev, originals);
        if (collides) {
          // This event should be autoMoved (right column)
          fcEvent.setExtendedProp('autoMoved', true);
          fcEvent.setExtendedProp('moved', false);
        } else {
          // No collision => original
          fcEvent.setExtendedProp('autoMoved', false);
          fcEvent.setExtendedProp('moved', false);
          originals.push({ id: fcEvent.id, start: fcEvent.start, end: fcEvent.end });
        }
      }
    }

    // After props updated, force rerender of event elements (so eventDidMount is called for each)
    calendar.batchRendering(() => {
      for (const ev of events) {
        // nothing to do here, just trigger render - FullCalendar will call eventDidMount for visible events
      }
    });
    // Slight delay then update CSS class via rerender
    setTimeout(() => {
      calendar.render();
      calendar.updateSize && calendar.updateSize();
      // toggle root class
      const anyColliding = events.some(x => x.e.extendedProps.autoMoved || x.e.extendedProps.moved);
      if (anyColliding) calendarRoot.classList.add('has-collisions'); else calendarRoot.classList.remove('has-collisions');
    }, 20);
  }

  // Check collisions for a single event against existing originals (used on creation immediate check)
  function checkCollisionForNewEvent(fcEvent) {
    // Get all events and compute originals based on createdAt order excluding this new one temporarily
    const all = calendar.getEvents().filter(e => e.extendedProps && e.extendedProps.isAvailability && e.id !== fcEvent.id);
    // Build originals by createdAt of others
    const others = all.map(e => ({ e, id: e.id, start: e.start, end: e.end, createdAt: e.extendedProps.createdAt || 0, moved: !!e.extendedProps.moved }));
    others.sort((a,b) => (a.createdAt || 0) - (b.createdAt || 0));
    const originals = [];
    for (const o of others) {
      if (o.e.extendedProps.moved) {
        // moved ones only collide against originals; for building originals list treat moved as not originals (they live in right column)
        continue;
      }
      // if this other overlaps any existing original, it would have been autoMoved; otherwise add to originals
      const overlaps = originals.some(orig => rangesOverlap(o.start, o.end, orig.start, orig.end));
      if (!overlaps) originals.push({ id: o.id, start: o.start, end: o.end });
    }
    // Now check if the new event overlaps any original
    return originals.some(orig => rangesOverlap(fcEvent.start, fcEvent.end, orig.start, orig.end));
  }

  // Add classes when event elements are mounted
  function eventDidMountHandler(info) {
    // Clear previous lane classes
    info.el.classList.remove('slot-original', 'slot-colliding');
    try {
      const moved = !!info.event.extendedProps.moved;
      const autoMoved = !!info.event.extendedProps.autoMoved;
      if (moved || autoMoved) {
        info.el.classList.add('slot-colliding');
      } else {
        info.el.classList.add('slot-original');
      }
    } catch (e) {
      // fallback
      info.el.classList.add('slot-original');
    }
  }

  // Selection handler - create a slot and auto-check collisions after a small delay
  function handleSlotClick(selectInfo) {
    if (!calendar) return;
    // create a slot at selectInfo.start with fixed sessionLength
    const startDate = selectInfo.start;
    const lengthMinutes = sessionLength || 60;
    const slotEvent = createAvailabilitySlotEvent(startDate, lengthMinutes);
    calendar.addEvent(slotEvent);

    // After a short delay, check whether it collides with any original; if so mark autoMoved=true
    setTimeout(() => {
      const fcEvent = calendar.getEventById(slotEvent.id);
      if (!fcEvent) return;
      const collides = checkCollisionForNewEvent(fcEvent);
      if (collides) {
        fcEvent.setExtendedProp('autoMoved', true);
      } else {
        fcEvent.setExtendedProp('autoMoved', false);
      }
      // recompute lanes to ensure consistent result (this will also account for createdAt ordering)
      computeAndApplyLanes();
      // enable save button
      saveBtn && (saveBtn.disabled = createdAvailabilitySlots.length === 0);
    }, 30);

    calendar.unselect();
  }

  // Drag stop handler - called when an event is dropped
  function handleEventDrop(dropInfo) {
    if (!calendar) return;
    const event = dropInfo.event;
    if (!event.extendedProps || !event.extendedProps.isAvailability) return;
    // mark as moved (user manually moved it) then compute lanes
    event.setExtendedProp('moved', true);
    event.setExtendedProp('autoMoved', false);
    // After a tiny delay compute lanes (dynamic reassignment will revert moved if no collision with originals)
    setTimeout(() => {
      computeAndApplyLanes();
      saveBtn && (saveBtn.disabled = createdAvailabilitySlots.length === 0);
    }, 30);
  }

  // Resize handler - similar to drop
  function handleEventResize(resizeInfo) {
    if (!calendar) return;
    const event = resizeInfo.event;
    if (!event.extendedProps || !event.extendedProps.isAvailability) return;
    // mark moved (resizing counts as modifying)
    event.setExtendedProp('moved', true);
    event.setExtendedProp('autoMoved', false);
    setTimeout(() => {
      computeAndApplyLanes();
      saveBtn && (saveBtn.disabled = createdAvailabilitySlots.length === 0);
    }, 30);
  }

  // Initialize calendar
  function initCalendar() {
    calendar = new FullCalendar.Calendar(calendarRoot, {
      timeZone: mentorTimezone,
      initialView: "timeGridWeek",
      height: "100%",
      nowIndicator: true,
      slotMinTime: "00:00:00",
      slotMaxTime: "24:00:00",
      slotDuration: "00:05:00",
      slotLabelInterval: "01:00:00",
      headerToolbar: false,
      selectable: true,
      selectMirror: true,
      selectOverlap: true,
      editable: true,
      eventStartEditable: true,
      eventDurationEditable: true,
      firstDay: 1,
      allDaySlot: false,
      events: [],
      eventDidMount: eventDidMountHandler,
      select: handleSlotClick,
      eventDrop: handleEventDrop,
      eventResize: handleEventResize,
      views: {
        timeGridWeek: { allDaySlot: false },
        timeGridDay: { allDaySlot: false, scrollTime: "09:00:00" }
      },
      datesSet: function() {
        // whenever dates change, re-evaluate lanes after visible render
        setTimeout(() => computeAndApplyLanes(), 40);
      }
    });

    calendar.render();

    // ensure initial sizing and marking
    setTimeout(() => {
      calendar.updateSize && calendar.updateSize();
      computeAndApplyLanes();
    }, 80);
  }

  // UI open/close and controls
  function openOverlay() {
    overlay.classList.add("is-visible");
    if (!calendar) initCalendar();
    else {
      calendar.setOption('timeZone', mentorTimezone);
      calendar.render();
      setTimeout(() => { calendar.updateSize && calendar.updateSize(); computeAndApplyLanes(); }, 60);
    }
    // scroll to 9am to make it friendlier
    setTimeout(() => {
      if (calendar && (calendar.view.type === 'timeGridWeek' || calendar.view.type === 'timeGridDay')) {
        try { calendar.scrollToTime({ hours: 9, minutes: 0 }); } catch (e) {}
      }
    }, 150);
  }

  function closeOverlay() {
    overlay.classList.remove("is-visible");
  }

  // nav buttons
  const navBtns = document.querySelectorAll("[data-calendar-nav]");
  navBtns.forEach(btn => btn.addEventListener("click", function() {
    if (!calendar) return;
    const action = this.dataset.calendarNav;
    if (action === "prev") calendar.prev();
    if (action === "next") calendar.next();
    if (action === "today") calendar.today();
    setTimeout(() => { calendar.updateSize && calendar.updateSize(); computeAndApplyLanes(); }, 50);
  }));

  // view toggle buttons
  viewBtnEls.forEach(btn => {
    btn.addEventListener('click', function() {
      viewBtnEls.forEach(b => b.classList.toggle('is-active', b === this));
      const v = this.dataset.calendarView;
      if (calendar) {
        calendar.changeView(v); 
        setTimeout(() => { calendar.updateSize && calendar.updateSize(); computeAndApplyLanes(); }, 40);
      }
    });
  });

  // overlay open triggers
  openTriggers.forEach(btn => btn.addEventListener("click", function(e) { e.preventDefault(); openOverlay(); }));
  closeTriggers.forEach(btn => btn.addEventListener("click", function(e) { e.preventDefault(); closeOverlay(); }));

  // backdrop click closes
  overlay.addEventListener('click', function(e) {
    if (e.target === overlay || e.target.classList.contains('availability-calendar-backdrop')) closeOverlay();
  });
  // prevent modal clicks from closing
  const modal = overlay.querySelector('.availability-calendar-modal');
  if (modal) modal.addEventListener('click', e => e.stopPropagation());

  // ESC to close
  document.addEventListener('keydown', e => { if (e.key === 'Escape') closeOverlay(); });

  // Expose some debug helpers (optional)
  window.__availabilityCalendar = {
    computeAndApplyLanes: function() { computeAndApplyLanes(); },
    getCalendarEvents: function() { return calendar ? calendar.getEvents().map(e=>({id:e.id, start:e.start, end:e.end, props:e.extendedProps})) : []; }
  };

})();
</script>

<!-- ===================== Small helper open button for testing (remove in production) ===================== -->
<button data-open-availability-calendar class="manage-availability-btn" style="position:fixed;right:18px;bottom:18px;z-index:3000;">Open Availability Calendar (test)</button>
