{% extends "dashboard_admin/base.html" %}
{% load static %}

{% block page_title %}{{ action }} Blog Post{% endblock %}

{% block extra_css %}
{{ block.super }}
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
{% endblock %}

{% block dashboard_content %}
<div class="dashboard-content-container">
  <div class="blog-form-page">
    <div class="blog-form-header">
      <h1>{{ action }} Blog Post</h1>
      <a href="{% url 'general:dashboard_admin:blog' %}" class="btn-back">
        <i class="fas fa-arrow-left"></i> Back to Posts
      </a>
    </div>

    <form method="post" enctype="multipart/form-data" class="blog-form" id="blogPostForm">
      {% csrf_token %}
      
      <div class="form-section">
        <label for="{{ form.title.id_for_label }}" class="form-label">
          Title <span class="required">*</span>
        </label>
        {{ form.title }}
        {% if form.title.errors %}
          <div class="form-error">{{ form.title.errors }}</div>
        {% endif %}
      </div>

      <div class="form-section">
        <label for="{{ form.cover_image.id_for_label }}" class="form-label">
          Cover Image
        </label>
        <div class="file-input-wrapper" id="cover-image-wrapper">
          {{ form.cover_image }}
          <div class="file-input-label">
            <i class="fas fa-cloud-upload-alt"></i>
            <span class="file-input-text">Click to select or drag and drop an image</span>
            <span class="file-input-hint">JPG, PNG or WEBP (max 5MB)</span>
          </div>
        </div>
        {% if post and post.cover_image %}
          <div class="current-cover-image" id="current-cover-container">
            <button type="button" class="remove-cover-btn" onclick="removeCoverImage()" title="Remove cover image">
              <i class="fas fa-times"></i>
            </button>
            <img src="{{ post.cover_image.url }}" alt="Current cover">
            <small>Current cover image</small>
          </div>
          <input type="hidden" name="remove_cover_image" id="remove-cover-input" value="0">
        {% endif %}
        <small class="form-help">Upload a cover image (max 5MB, JPG/PNG/WEBP)</small>
        {% if form.cover_image.errors %}
          <div class="form-error">{{ form.cover_image.errors }}</div>
        {% endif %}
      </div>

      <div class="form-section">
        <label for="{{ form.excerpt.id_for_label }}" class="form-label">
          Excerpt (Optional)
        </label>
        {{ form.excerpt }}
        <small class="form-help">A short preview text for your blog post (max 500 characters)</small>
        {% if form.excerpt.errors %}
          <div class="form-error">{{ form.excerpt.errors }}</div>
        {% endif %}
      </div>

      <div class="form-section">
        <label for="{{ form.content.id_for_label }}" class="form-label">
          Content <span class="required">*</span>
        </label>
        <div id="contentEditor" class="quill-editor-wrapper"></div>
        <div style="display: none;">
          {{ form.content }}
        </div>
        <small class="form-help">Write your blog post content using the rich text editor above</small>
        {% if form.content.errors %}
          <div class="form-error">{{ form.content.errors }}</div>
        {% endif %}
      </div>

      <div class="form-section">
        <label class="form-label">Categories</label>
        <div class="categories-grid">
          {% for choice in form.categories %}
            <label class="category-checkbox">
              {{ choice.tag }}
              <span>{{ choice.choice_label }}</span>
            </label>
          {% endfor %}
        </div>
        {% if form.categories.errors %}
          <div class="form-error">{{ form.categories.errors }}</div>
        {% endif %}
      </div>

      <div class="form-section">
        <label class="form-label">
          SEO Tags
        </label>
        <div class="seo-tags-container">
          <div class="seo-tags-input-wrapper">
            <input 
              type="text" 
              id="seo-tags-input" 
              class="form-control seo-tags-input" 
              placeholder="Type a tag and press Enter"
              autocomplete="off"
            >
            <button type="button" id="seo-tags-add-btn" class="btn-add-tag">
              Add Tag
            </button>
          </div>
          <input type="hidden" name="seo_tags" id="seo-tags-hidden" value="{% if post and post.seo_tags %}{{ post.seo_tags|safe }}{% elif form.seo_tags.value %}{{ form.seo_tags.value }}{% else %}[]{% endif %}">
          <div class="seo-tags-display" id="seo-tags-display">
            {% if post and post.seo_tags %}
              {% for tag in post.seo_tags %}
                <span class="seo-tag-item">
                  <span>{{ tag }}</span>
                  <button type="button" class="seo-tag-remove" data-tag="{{ tag }}">
                    <i class="fas fa-times"></i>
                  </button>
                </span>
              {% endfor %}
            {% endif %}
          </div>
        </div>
        <small class="form-help">Add SEO tags/keywords for better search engine visibility</small>
        {% if form.seo_tags.errors %}
          <div class="form-error">{{ form.seo_tags.errors }}</div>
        {% endif %}
      </div>

      <div class="form-section">
        <label for="{{ form.status.id_for_label }}" class="form-label">
          Status
        </label>
        <div class="status-radio-group">
          <label class="status-radio-option {% if form.status.value == 'draft' or not form.status.value %}active{% endif %}">
            <input type="radio" name="status" value="draft" {% if form.status.value == 'draft' or not form.status.value %}checked{% endif %}>
            <span class="status-radio-label">Draft</span>
          </label>
          <label class="status-radio-option {% if form.status.value == 'published' %}active{% endif %}">
            <input type="radio" name="status" value="published" {% if form.status.value == 'published' %}checked{% endif %}>
            <span class="status-radio-label">Published</span>
          </label>
        </div>
        <small class="form-help">Draft posts are only visible in your management page, not in public blog</small>
        {% if form.status.errors %}
          <div class="form-error">{{ form.status.errors }}</div>
        {% endif %}
      </div>

      <div class="form-actions">
        <a href="{% url 'general:dashboard_admin:blog' %}" class="btn-cancel">Cancel</a>
        <button type="submit" class="btn-submit">
          <i class="fas fa-save"></i> Save Post
        </button>
      </div>
    </form>
  </div>
</div>

{% block scripts %}
{{ block.super }}
<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
<script>
// Prevent double initialization
if (typeof window.blogQuillInitialized === 'undefined') {
  window.blogQuillInitialized = false;
}

// Wait for both DOM and Quill to be ready
(function() {
  function initQuillEditor() {
    // Prevent double initialization
    if (window.blogQuillInitialized) {
      return;
    }
    
    // Check if Quill is loaded
    if (typeof Quill === 'undefined') {
      setTimeout(initQuillEditor, 100);
      return;
    }
    
    // Get the textarea - try multiple possible IDs
    const contentTextarea = document.getElementById('id_content') || 
                            document.querySelector('textarea[name="content"]');
    const editorContainer = document.getElementById('contentEditor');
    
    if (!contentTextarea || !editorContainer) {
      console.error('Could not find content textarea or editor container');
      return;
    }
    
    // Check if Quill is already initialized on this container
    if (editorContainer.classList.contains('ql-container')) {
      console.warn('Quill editor already initialized on this container');
      return;
    }
    
    // Hide the textarea completely
    contentTextarea.style.display = 'none';
    contentTextarea.style.visibility = 'hidden';
    contentTextarea.style.position = 'absolute';
    contentTextarea.style.left = '-9999px';
    
    // Set initial content if editing
    const initialContent = contentTextarea.value || '';
    
      // Initialize Quill only once
      try {
        // Custom video handler for YouTube URLs
        const Video = Quill.import('formats/video');
        
        class CustomVideo extends Video {
          static create(value) {
            let node = super.create(value);
            
            // Check if it's a YouTube URL
            const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
            const match = value.match(youtubeRegex);
            
            if (match) {
              const videoId = match[1];
              const embedUrl = `https://www.youtube.com/embed/${videoId}`;
              node.setAttribute('src', embedUrl);
              node.setAttribute('frameborder', '0');
              node.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
              node.setAttribute('allowfullscreen', 'true');
            } else {
              // Regular video URL
              node.setAttribute('src', value);
            }
            
            return node;
          }
          
          static value(node) {
            return node.getAttribute('src');
          }
        }
        
        Quill.register(CustomVideo, true);
        
        const quill = new Quill('#contentEditor', {
          theme: 'snow',
          modules: {
            toolbar: {
              container: [
                [{ 'header': [1, 2, 3, false] }],
                ['bold', 'italic', 'underline', 'strike'],
                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                [{ 'script': 'sub'}, { 'script': 'super' }],
                [{ 'indent': '-1'}, { 'indent': '+1' }],
                [{ 'direction': 'rtl' }],
                [{ 'color': [] }, { 'background': [] }],
                [{ 'font': [] }],
                [{ 'align': [] }],
                ['link', 'image', 'video'],
                ['clean']
              ],
              handlers: {
                'video': function() {
                  const url = prompt('Enter video URL (YouTube supported):');
                  if (url) {
                    // Extract YouTube video ID if it's a YouTube URL
                    const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
                    const match = url.match(youtubeRegex);
                    
                    if (match) {
                      const videoId = match[1];
                      const embedUrl = `https://www.youtube.com/embed/${videoId}`;
                      const range = quill.getSelection(true);
                      quill.insertEmbed(range.index, 'video', embedUrl, 'user');
                    } else {
                      // Regular video URL
                      const range = quill.getSelection(true);
                      quill.insertEmbed(range.index, 'video', url, 'user');
                    }
                  }
                }
              }
            }
          },
          placeholder: 'Write your blog post content here...'
        });
        
        // Mark as initialized
        window.blogQuillInitialized = true;
        
        // Process existing video embeds when loading content
        function processVideoEmbeds() {
          // Process all iframes (not just YouTube ones)
          const allIframes = quill.root.querySelectorAll('iframe');
          allIframes.forEach(iframe => {
            const src = iframe.getAttribute('src');
            if (!src) return;
            
            // Check if it's a YouTube URL (any format)
            const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
            const match = src.match(youtubeRegex);
            
            if (match) {
              const videoId = match[1];
              const embedUrl = `https://www.youtube.com/embed/${videoId}`;
              
              // Always update to proper embed URL
              iframe.setAttribute('src', embedUrl);
              iframe.setAttribute('frameborder', '0');
              iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
              iframe.setAttribute('allowfullscreen', 'true');
              iframe.style.width = '100%';
              iframe.style.maxWidth = '100%';
              iframe.style.aspectRatio = '16 / 9';
              iframe.style.height = 'auto';
              iframe.style.minHeight = '300px';
            }
          });
          
          // Also check for video tags that might need conversion
          const videoTags = quill.root.querySelectorAll('video');
          videoTags.forEach(video => {
            const src = video.getAttribute('src');
            if (!src) return;
            
            const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
            const match = src.match(youtubeRegex);
            
            if (match) {
              const videoId = match[1];
              const embedUrl = `https://www.youtube.com/embed/${videoId}`;
              
              // Replace video tag with iframe
              const iframe = document.createElement('iframe');
              iframe.setAttribute('src', embedUrl);
              iframe.setAttribute('frameborder', '0');
              iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
              iframe.setAttribute('allowfullscreen', 'true');
              iframe.style.width = '100%';
              iframe.style.maxWidth = '100%';
              iframe.style.aspectRatio = '16 / 9';
              iframe.style.height = 'auto';
              iframe.style.minHeight = '300px';
              
              video.parentNode.replaceChild(iframe, video);
            }
          });
          
          // Update textarea after processing
          contentTextarea.value = quill.root.innerHTML;
        }
        
        // Make the editor container clickable to focus
        editorContainer.addEventListener('click', function(e) {
          // Only focus if clicking on the container itself, not on toolbar or editor content
          if (e.target === editorContainer || e.target.closest('.ql-container')) {
            quill.focus();
          }
        });
        
        // Set initial content and process videos
        if (initialContent) {
          quill.root.innerHTML = initialContent;
          // Process any existing video embeds - try multiple times to catch all cases
          setTimeout(processVideoEmbeds, 100);
          setTimeout(processVideoEmbeds, 500);
          setTimeout(processVideoEmbeds, 1000);
        }
        
        // Process videos after content changes
        quill.on('text-change', function() {
          contentTextarea.value = quill.root.innerHTML;
          // Process any new video embeds
          setTimeout(processVideoEmbeds, 100);
        });
        
        // Also process on editor ready
        setTimeout(processVideoEmbeds, 200);
        
        // Update textarea before form submission (as backup)
        const form = document.getElementById('blogPostForm');
        if (form) {
          form.addEventListener('submit', function(e) {
            processVideoEmbeds();
            contentTextarea.value = quill.root.innerHTML;
          });
        }
    } catch (error) {
      console.error('Error initializing Quill editor:', error);
    }
    
    // Remove cover image function
    window.removeCoverImage = function() {
      const container = document.getElementById('current-cover-container');
      const removeInput = document.getElementById('remove-cover-input');
      const coverImageInput = document.getElementById('cover-image-input');
      
      // Remove the old image container entirely
      if (container) {
        container.remove();
      }
      
      // Set remove flag
      if (removeInput) {
        removeInput.value = '1';
      }
      
      // Clear file input
      if (coverImageInput) {
        coverImageInput.value = '';
      }
      
      // Remove any existing new preview if it exists
      const newPreview = document.getElementById('new-cover-preview');
      if (newPreview) {
        newPreview.remove();
      }
      
      // Show notification
      if (typeof showNotification === 'function') {
        showNotification('Cover image will be removed when you save the post.', 'warning');
      }
    };
    
  }
  
  // Preview newly uploaded image and handle drag & drop
  document.addEventListener('DOMContentLoaded', function() {
    const coverImageInput = document.getElementById('cover-image-input');
    const coverImageWrapper = document.getElementById('cover-image-wrapper');
    
    // Function to handle file selection
    function handleFile(file) {
      if (!file) return;
      
      // Validate file type
      const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
      if (!validTypes.includes(file.type)) {
        if (typeof showNotification === 'function') {
          showNotification('Please select a valid image file (JPG, PNG, or WEBP)', 'error');
        } else {
          alert('Please select a valid image file (JPG, PNG, or WEBP)');
        }
        if (coverImageInput) coverImageInput.value = '';
        return;
      }
      
      // Validate file size (5MB)
      const maxSize = 5 * 1024 * 1024; // 5MB in bytes
      if (file.size > maxSize) {
        if (typeof showNotification === 'function') {
          showNotification('Image size must be less than 5MB', 'error');
        } else {
          alert('Image size must be less than 5MB');
        }
        if (coverImageInput) coverImageInput.value = '';
        return;
      }
      
      // Create a FileList-like object and set it to the input
      const dataTransfer = new DataTransfer();
      dataTransfer.items.add(file);
      coverImageInput.files = dataTransfer.files;
      
      // Trigger change event
      const event = new Event('change', { bubbles: true });
      coverImageInput.dispatchEvent(event);
    }
    
    // Drag and drop functionality
    if (coverImageWrapper) {
      // Prevent default drag behaviors only on the file input wrapper
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        coverImageWrapper.addEventListener(eventName, preventDefaults, false);
      });
      
      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }
      
      // Highlight drop area when item is dragged over it
      ['dragenter', 'dragover'].forEach(eventName => {
        coverImageWrapper.addEventListener(eventName, function() {
          coverImageWrapper.classList.add('drag-over');
        }, false);
      });
      
      ['dragleave', 'drop'].forEach(eventName => {
        coverImageWrapper.addEventListener(eventName, function() {
          coverImageWrapper.classList.remove('drag-over');
        }, false);
      });
      
      // Handle dropped files
      coverImageWrapper.addEventListener('drop', function(e) {
        const dt = e.dataTransfer;
        const files = dt.files;
        
        if (files.length > 0) {
          handleFile(files[0]);
        }
      }, false);
    }
    
    // Cropper logic - triggered after file is selected (via click or drag & drop)
    if (coverImageInput) {
      coverImageInput.addEventListener('change', function(e) {
        // Don't trigger cropper if we're setting the file programmatically
        if (isSettingFileProgrammatically) {
          console.log('Skipping cropper - file set programmatically');
          return;
        }
        
        const file = e.target.files[0];
        if (file) {
          // Get the actual file input element (not just the variable)
          const fileInputElement = document.getElementById('cover-image-input');
          if (fileInputElement) {
            showImagePreview(file, fileInputElement);
          } else {
            console.error('Cover image input element not found');
          }
        }
      });
    }
  });
  
  // SEO Tags functionality
  document.addEventListener('DOMContentLoaded', function() {
    const seoTagsInput = document.getElementById('seo-tags-input');
    const seoTagsHidden = document.getElementById('seo-tags-hidden');
    const seoTagsDisplay = document.getElementById('seo-tags-display');
    const seoTagsAddBtn = document.getElementById('seo-tags-add-btn');
    
    function updateSeoTagsHidden() {
      const tags = Array.from(seoTagsDisplay.querySelectorAll('.seo-tag-item')).map(item => {
        return item.querySelector('span:not(.seo-tag-remove)')?.textContent.trim() || 
               item.textContent.replace(/×/g, '').trim();
      }).filter(tag => tag);
      seoTagsHidden.value = JSON.stringify(tags);
    }
    
    function addSeoTag(tagText) {
      if (!tagText || !tagText.trim()) return;
      
      const tag = tagText.trim();
      const existingTags = Array.from(seoTagsDisplay.querySelectorAll('.seo-tag-item')).map(item => {
        return item.querySelector('span:not(.seo-tag-remove)')?.textContent.trim() || 
               item.textContent.replace(/×/g, '').trim();
      });
      
      if (existingTags.includes(tag)) return; // Don't add duplicates
      
      const tagElement = document.createElement('span');
      tagElement.className = 'seo-tag-item';
      tagElement.innerHTML = `
        <span>${tag}</span>
        <button type="button" class="seo-tag-remove" data-tag="${tag}">
          <i class="fas fa-times"></i>
        </button>
      `;
      
      seoTagsDisplay.appendChild(tagElement);
      updateSeoTagsHidden();
      
      // Add remove functionality
      tagElement.querySelector('.seo-tag-remove').addEventListener('click', function() {
        tagElement.remove();
        updateSeoTagsHidden();
      });
    }
    
    function handleAddTag() {
      if (seoTagsInput) {
        const value = seoTagsInput.value.trim();
        if (value) {
          // Split by comma and add each tag
          value.split(',').forEach(tag => {
            if (tag.trim()) {
              addSeoTag(tag.trim());
            }
          });
          seoTagsInput.value = '';
        }
      }
    }
    
    if (seoTagsInput && seoTagsDisplay) {
      // Load existing tags
      if (seoTagsHidden.value) {
        try {
          const existingTags = JSON.parse(seoTagsHidden.value);
          existingTags.forEach(tag => addSeoTag(tag));
        } catch (e) {
          console.error('Error parsing SEO tags:', e);
        }
      }
      
      // Handle Enter key
      seoTagsInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleAddTag();
        }
      });
      
      // Handle Add Tag button click
      if (seoTagsAddBtn) {
        seoTagsAddBtn.addEventListener('click', function(e) {
          e.preventDefault();
          handleAddTag();
        });
      }
      
      // Handle comma separation on blur
      seoTagsInput.addEventListener('blur', function() {
        handleAddTag();
      });
      
      // Initialize remove buttons for existing tags
      seoTagsDisplay.querySelectorAll('.seo-tag-remove').forEach(btn => {
        btn.addEventListener('click', function() {
          this.closest('.seo-tag-item').remove();
          updateSeoTagsHidden();
        });
      });
    }
    
    // Status radio buttons - update active state on change
    document.querySelectorAll('input[name="status"]').forEach(radio => {
      radio.addEventListener('change', function() {
        document.querySelectorAll('.status-radio-option').forEach(option => {
          option.classList.remove('active');
        });
        this.closest('.status-radio-option').classList.add('active');
      });
    });
  });
  
  // Start initialization when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initQuillEditor);
  } else {
    initQuillEditor();
  }
  
  // Ensure navbar dropdowns work - reinitialize if needed
  setTimeout(function() {
    // User Profile Dropdown
    const userProfileTrigger = document.getElementById('userProfileTrigger');
    const userDropdownMenu = document.getElementById('userDropdownMenu');
    const userProfileDropdown = document.querySelector('.user-profile-dropdown');
    
    if (userProfileTrigger && userDropdownMenu && userProfileDropdown) {
      // Remove inline display:none if still present
      if (userDropdownMenu.style.display === 'none') {
        userDropdownMenu.style.display = '';
      }
      if (userProfileTrigger.style.display === 'none') {
        userProfileTrigger.style.display = '';
      }
      
      // Re-attach click handler if not already attached
      const existingHandler = userProfileTrigger.getAttribute('data-dropdown-initialized');
      if (!existingHandler) {
        userProfileTrigger.setAttribute('data-dropdown-initialized', 'true');
        userProfileTrigger.addEventListener('click', function(e) {
          e.stopPropagation();
          userProfileDropdown.classList.toggle('active');
          // Close notification dropdown if open
          const notificationDropdown = document.querySelector('.notification-dropdown');
          if (notificationDropdown) {
            notificationDropdown.classList.remove('active');
          }
        });
      }
    }
    
    // Notification Dropdown
    const notificationBell = document.getElementById('notificationBell');
    const notificationMenu = document.getElementById('notificationMenu');
    const notificationDropdown = document.querySelector('.notification-dropdown');
    const dashboardTopActionsGroup = document.querySelector('.dashboard-top-actions-group');
    
    if (dashboardTopActionsGroup && dashboardTopActionsGroup.style.display === 'none') {
      dashboardTopActionsGroup.style.display = '';
    }
    
    if (notificationBell && notificationMenu && notificationDropdown) {
      // Remove inline display:none if still present
      if (notificationMenu.style.display === 'none') {
        notificationMenu.style.display = '';
      }
      
      // Re-attach click handler if not already attached
      const existingNotificationHandler = notificationBell.getAttribute('data-dropdown-initialized');
      if (!existingNotificationHandler) {
        notificationBell.setAttribute('data-dropdown-initialized', 'true');
        notificationBell.addEventListener('click', function(e) {
          e.stopPropagation();
          notificationDropdown.classList.toggle('active');
          // Close user profile dropdown if open
          if (userProfileDropdown) {
            userProfileDropdown.classList.remove('active');
          }
        });
      }
    }
    
    // Ensure click-outside handler works for both dropdowns
    document.addEventListener('click', function(event) {
      if (userProfileDropdown && !userProfileDropdown.contains(event.target)) {
        userProfileDropdown.classList.remove('active');
      }
      if (notificationDropdown && !notificationDropdown.contains(event.target)) {
        notificationDropdown.classList.remove('active');
      }
    });
  }, 100);
})();
</script>
{% endblock %}

<style>
.blog-form-page {
  padding: 40px;
  max-width: 1000px;
  margin: 0 auto;
}

.blog-form-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 30px;
}

.blog-form-header h1 {
  font-size: 2rem;
  font-weight: 700;
  color: var(--text-dark);
  margin: 0;
}

.btn-back {
  padding: 10px 20px;
  background: #f3f4f6;
  color: var(--text-dark);
  border-radius: 8px;
  text-decoration: none;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  transition: background 0.2s;
}

.btn-back:hover {
  background: #e5e7eb;
}

.blog-form {
  background: white;
  padding: 40px;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.form-section {
  margin-bottom: 30px;
}

.form-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 24px;
}

.form-label {
  display: block;
  font-weight: 600;
  color: var(--text-dark);
  margin-bottom: 8px;
  font-size: 0.95rem;
}

.required {
  color: #ef4444;
}

.form-control {
  width: 100%;
  padding: 12px 16px;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  font-size: 0.95rem;
  font-family: inherit;
  transition: border-color 0.2s;
}

.form-control:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
}

/* File input styling */
.file-input-wrapper {
  position: relative;
  min-height: 120px;
  border: 2px dashed #cbd5e1;
  border-radius: 8px;
  background: white;
  transition: all 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}

.file-input-wrapper:hover {
  border-color: #3b82f6;
  background: #eff6ff;
}

.file-input-wrapper.drag-over {
  border-color: #3b82f6;
  border-style: solid;
  background: #eff6ff;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

#cover-image-input {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0;
  cursor: pointer;
  z-index: 2;
}

.file-input-label {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 20px;
  text-align: center;
  pointer-events: none;
  z-index: 1;
}

.file-input-label i {
  font-size: 2rem;
  color: #3b82f6;
  margin-bottom: 4px;
}

.file-input-text {
  font-size: 1rem;
  font-weight: 600;
  color: #0f172a;
}

.file-input-hint {
  font-size: 0.85rem;
  color: #64748b;
}

#cover-image-input:focus + .file-input-label,
.file-input-wrapper:has(#cover-image-input:focus) {
  border-color: #3b82f6;
}

.form-help {
  display: block;
  margin-top: 6px;
  font-size: 0.85rem;
  color: var(--text-light);
}

.form-error {
  margin-top: 6px;
  color: #ef4444;
  font-size: 0.85rem;
}

.quill-editor-wrapper {
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  min-height: 400px;
  display: flex;
  flex-direction: column;
  cursor: text;
}

.quill-editor-wrapper .ql-toolbar {
  border-top-left-radius: 8px;
  border-top-right-radius: 8px;
  border-bottom: 1px solid #e5e7eb;
  flex-shrink: 0;
}

.quill-editor-wrapper .ql-container {
  flex: 1;
  font-size: 0.95rem;
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
  border: none;
  display: flex;
  flex-direction: column;
}

.quill-editor-wrapper .ql-editor {
  flex: 1;
  min-height: 400px;
  padding: 16px;
}

.quill-editor-wrapper .ql-editor.ql-blank::before {
  font-style: normal;
  color: #9ca3af;
}

.quill-editor-wrapper .ql-editor iframe,
.quill-editor-wrapper .ql-editor video {
  width: 100%;
  max-width: 100%;
  height: auto;
  min-height: 300px;
  border-radius: 8px;
  margin: 16px 0;
  border: none;
}

.quill-editor-wrapper .ql-editor iframe[src*="youtube.com"],
.quill-editor-wrapper .ql-editor iframe[src*="youtu.be"] {
  aspect-ratio: 16 / 9;
  min-height: 0;
}

.current-cover-image {
  margin-top: 12px;
  padding: 12px;
  background: #f9fafb;
  border-radius: 8px;
  text-align: center;
  position: relative;
}

.current-cover-image img {
  max-width: 100%;
  max-height: 200px;
  border-radius: 8px;
  margin-bottom: 8px;
}

.current-cover-image small {
  display: block;
  color: var(--text-light);
  font-size: 0.85rem;
}

.remove-cover-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: rgba(239, 68, 68, 0.9);
  color: white;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  z-index: 10;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.remove-cover-btn:hover {
  background: #ef4444;
  transform: scale(1.1);
  box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
}

.remove-cover-btn i {
  font-size: 0.9rem;
}


.categories-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 12px;
  padding: 16px;
  background: #f9fafb;
  border-radius: 8px;
  border: 1px solid #e5e7eb;
  max-height: 300px;
  overflow-y: auto;
}

.category-checkbox {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.2s;
}

.category-checkbox:hover {
  background: white;
}

.category-checkbox input[type="checkbox"] {
  width: 18px;
  height: 18px;
  cursor: pointer;
}

.category-checkbox span {
  font-size: 0.9rem;
  color: var(--text-dark);
}

.form-actions {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 16px;
  padding-top: 30px;
  border-top: 1px solid #e5e7eb;
  margin-top: 30px;
}

.btn-cancel {
  padding: 16px 24px;
  background: #f3f4f6;
  color: var(--text-dark);
  border-radius: 8px;
  text-decoration: none;
  font-weight: 700;
  font-size: 0.95rem;
  transition: background 0.2s;
  flex: 1;
  width: 100%;
  text-align: center;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.btn-cancel:hover {
  background: #e5e7eb;
}

.btn-submit {
  padding: 16px 24px;
  background: var(--primary);
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: 700;
  font-size: 0.95rem;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  transition: background 0.2s;
  flex: 1;
  width: 100%;
}

.btn-submit:hover {
  background: #059669;
}

/* SEO Tags */
.seo-tags-container {
  margin-bottom: 8px;
}

.seo-tags-input-wrapper {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
}

.seo-tags-input {
  flex: 1;
  margin-bottom: 0;
}

.btn-add-tag {
  padding: 8px 16px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 0.85rem;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.2s;
  white-space: nowrap;
  max-width: 120px;
  flex-shrink: 0;
}

.btn-add-tag:hover {
  background: #2563eb;
}

.btn-add-tag:active {
  background: #1d4ed8;
}

.seo-tags-display {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  min-height: 32px;
}

.seo-tag-item {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: #f0fdf4;
  border: 1px solid #10b981;
  border-radius: 20px;
  font-size: 0.85rem;
  color: #059669;
  font-weight: 500;
}

.seo-tag-remove {
  background: none;
  border: none;
  color: #059669;
  cursor: pointer;
  padding: 0;
  width: 16px;
  height: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: background 0.2s;
  font-size: 0.75rem;
}

.seo-tag-remove:hover {
  background: rgba(5, 150, 105, 0.2);
}

/* Status Radio Buttons */
.status-radio-group {
  display: flex;
  gap: 12px;
}

.status-radio-option {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px 24px;
  background: white;
  border: 2px solid #e5e7eb;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}

.status-radio-option input[type="radio"] {
  position: absolute;
  opacity: 0;
  pointer-events: none;
}

.status-radio-label {
  font-size: 0.95rem;
  font-weight: 500;
  color: #64748b;
  transition: color 0.2s;
}

.status-radio-option:hover {
  border-color: #3b82f6;
  background: #eff6ff;
}

.status-radio-option.active {
  background: #3b82f6;
  border-color: #3b82f6;
}

.status-radio-option.active .status-radio-label {
  color: white;
  font-weight: 600;
}

/* Ensure navbar dropdown is not affected by blog form styles - use higher specificity */
header nav .user-profile-dropdown {
  position: relative !important;
  z-index: 1000 !important;
}

header nav .user-dropdown-menu {
  position: absolute !important;
  top: calc(100% + 8px) !important;
  right: 0 !important;
  background: white !important;
  border-radius: 12px !important;
  box-shadow: 0 4px 20px rgba(0,0,0,0.15) !important;
  min-width: 200px !important;
  padding: 0 !important;
  opacity: 0 !important;
  visibility: hidden !important;
  transform: translateY(-10px) !important;
  transition: all 0.2s ease !important;
  z-index: 1001 !important;
  display: block !important;
  pointer-events: none !important;
}

header nav .user-profile-dropdown.active .user-dropdown-menu {
  opacity: 1 !important;
  visibility: visible !important;
  transform: translateY(0) !important;
  pointer-events: auto !important;
}

/* Ensure notification dropdown is not affected by blog form styles */
header nav .notification-dropdown {
  position: relative !important;
  z-index: 1000 !important;
}

header nav .notification-menu {
  position: absolute !important;
  top: calc(100% + 8px) !important;
  right: 0 !important;
  background: white !important;
  border-radius: 12px !important;
  box-shadow: 0 4px 20px rgba(0,0,0,0.15) !important;
  width: 380px !important;
  max-width: 90vw !important;
  opacity: 0 !important;
  visibility: hidden !important;
  transform: translateY(-10px) !important;
  transition: all 0.2s ease !important;
  z-index: 1001 !important;
  display: flex !important;
  flex-direction: column !important;
  height: 500px !important;
  pointer-events: none !important;
}

header nav .notification-dropdown.active .notification-menu {
  opacity: 1 !important;
  visibility: visible !important;
  transform: translateY(0) !important;
  pointer-events: auto !important;
}

@media (max-width: 768px) {
  .form-row {
    grid-template-columns: 1fr;
  }
  
  .categories-grid {
    grid-template-columns: 1fr;
  }
}

/* Cropper Modal Styles - already in dashboard.css, but ensuring they work here */
.cropper-modal-backdrop {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(15, 23, 42, 0.75);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  z-index: 10000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}

.cropper-modal-backdrop.active {
  opacity: 1;
  visibility: visible;
}
</style>

<!-- Image Cropper Modal -->
<div id="imagePreviewModal" class="cropper-modal-backdrop">
  <div class="cropper-modal-card">
    <div class="cropper-header">
      <h3 id="previewTitle"><i class="fas fa-crop-alt"></i> Crop Cover Image</h3>
      <button type="button" class="cropper-close-btn" onclick="closeImagePreview()">
        <i class="fas fa-times"></i>
      </button>
    </div>
    
    <div class="cropper-body">
      <img id="previewImage" src="" alt="Preview">
    </div>
    
    <div class="cropper-footer">
      <div class="cropper-toolbar">
        <button type="button" class="cropper-tool-btn" onclick="zoomOut()" title="Zoom Out">
          <i class="fas fa-search-minus"></i>
        </button>
        <button type="button" class="cropper-tool-btn" onclick="zoomIn()" title="Zoom In">
          <i class="fas fa-search-plus"></i>
        </button>
        <button type="button" class="cropper-tool-btn" onclick="resetZoom()" title="Reset View">
          <i class="fas fa-undo"></i>
        </button>
      </div>
      
      <div class="cropper-actions">
        <button type="button" class="btn-cropper-cancel" onclick="closeImagePreview()">Cancel</button>
        <button type="button" class="btn-cropper-save" onclick="saveCroppedImage()">
          <i class="fas fa-check"></i> Crop & Save
        </button>
      </div>
    </div>
  </div>
</div>

<script>
// CropperJS instance
let cropper = null;
let currentFileInput = null;
let isSettingFileProgrammatically = false; // Flag to prevent cropper from triggering when we set file programmatically

// Show image with CropperJS
function showImagePreview(file, fileInput) {
  if (!file) return;
  
  // Check if CropperJS is loaded
  if (typeof Cropper === 'undefined') {
    alert('Image cropper library not loaded. Please refresh the page.');
    return;
  }
  
  currentFileInput = fileInput;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const modal = document.getElementById('imagePreviewModal');
    const img = document.getElementById('previewImage');
    const title = document.getElementById('previewTitle');
    
    if (modal && img && title) {
      // Set image source
      img.src = e.target.result;
      title.innerHTML = '<i class="fas fa-crop-alt"></i> Crop Cover Image';
      
      // Show modal with flex and fade-in
      modal.style.display = 'flex';
      // Small delay to allow display:flex to apply before adding active class for transition
      setTimeout(() => {
        modal.classList.add('active');
      }, 10);
      
      // Remove circular class for blog cover (should be rectangular)
      const modalCard = document.querySelector('.cropper-modal-card');
      if (modalCard) {
        modalCard.classList.remove('cropper-circle-view');
      }
      
      // Wait for image to load, then initialize CropperJS
      img.onload = function() {
        // Destroy previous cropper if exists
        if (cropper) {
          cropper.destroy();
          cropper = null;
        }
        
        // Initialize CropperJS with 16:9 aspect ratio for blog covers
        const aspectRatio = 16/9;
        cropper = new Cropper(img, {
          aspectRatio: aspectRatio,
          viewMode: 1, // Restrict crop box within canvas
          autoCropArea: 1,
          responsive: true,
          restore: false,
          guides: true,
          center: true,
          highlight: false,
          cropBoxMovable: true,
          cropBoxResizable: false, // Lock aspect ratio
          toggleDragModeOnDblclick: false,
          dragMode: 'move', // Allow dragging the image when zoomed
          zoomable: true, // Enable zoom
          scalable: false, // Disable scaling (we only want zoom)
          rotatable: false, // Disable rotation
        });
      };
      
      // If image already loaded
      if (img.complete) {
        img.onload();
      }
    }
  };
  reader.readAsDataURL(file);
}

function closeImagePreview(skipFileReset = false) {
  const modal = document.getElementById('imagePreviewModal');
  if (modal) {
    modal.classList.remove('active');
    // Wait for transition to finish before hiding
    setTimeout(() => {
      modal.style.display = 'none';
    }, 300);
  }
  
  // Destroy cropper
  if (cropper) {
    cropper.destroy();
    cropper = null;
  }
  
  // Reset file input so the same file can be selected again
  // BUT NOT if we just saved a cropped image (skipFileReset = true)
  if (currentFileInput && !skipFileReset) {
    currentFileInput.value = '';
  }
  
  // Reset variable only if we're not keeping the file
  if (!skipFileReset) {
    currentFileInput = null;
  }
}

// Zoom functions
function zoomIn() {
  if (cropper) {
    cropper.zoom(0.1); // Zoom in by 10%
  }
}

function zoomOut() {
  if (cropper) {
    cropper.zoom(-0.1); // Zoom out by 10%
  }
}

function resetZoom() {
  if (cropper) {
    cropper.reset(); // Reset zoom and position
  }
}

// Save cropped image
function saveCroppedImage() {
  if (!cropper || !currentFileInput) {
    alert('Error: Missing cropper or file input');
    return;
  }
  
  // Get cropped canvas with proper dimensions (16:9 ratio)
  // Common blog cover dimensions: 1920x1080 (Full HD)
  const canvas = cropper.getCroppedCanvas({
    width: 1920,
    height: 1080,
    imageSmoothingEnabled: true,
    imageSmoothingQuality: 'high',
  });
  
  // Convert to blob
  canvas.toBlob(function(blob) {
    if (!blob) {
      alert('Error creating cropped image');
      return;
    }
    
    // Create a new File object from the blob
    const fileName = currentFileInput.files[0] ? currentFileInput.files[0].name : 'cover-image.jpg';
    const croppedFile = new File([blob], fileName, { type: 'image/jpeg' });
    
    // Update the file input with the cropped file
    try {
      // Set flag to prevent cropper from triggering
      isSettingFileProgrammatically = true;
      
      // Use DataTransfer API to set the file directly on the existing input
      // This is more reliable than replacing the element
      const dataTransfer = new DataTransfer();
      dataTransfer.items.add(croppedFile);
      
      // Set files using standard assignment (DataTransfer API)
      currentFileInput.files = dataTransfer.files;
      
      // Verify the file was set
      if (!currentFileInput.files || currentFileInput.files.length === 0) {
        console.error('Failed to set file in input');
        isSettingFileProgrammatically = false;
        alert('Error: Failed to save cropped image. Please try again.');
        return;
      }
      
      console.log('File set successfully:', currentFileInput.files[0].name, currentFileInput.files[0].size, 'bytes');
      console.log('File input name:', currentFileInput.name, 'id:', currentFileInput.id);
      console.log('File input form:', currentFileInput.form ? 'connected' : 'NOT CONNECTED');
      
      // Ensure the input is connected to the form
      const form = document.getElementById('blogPostForm');
      if (form && !currentFileInput.form) {
        console.warn('File input not connected to form, attempting to reconnect...');
        form.appendChild(currentFileInput);
      }
      
      // Trigger change event so the form recognizes the new file (but cropper won't trigger due to flag)
      const changeEvent = new Event('change', { bubbles: true, cancelable: true });
      currentFileInput.dispatchEvent(changeEvent);
      
      // Also trigger input event for better browser compatibility
      const inputEvent = new Event('input', { bubbles: true, cancelable: true });
      currentFileInput.dispatchEvent(inputEvent);
      
      // Reset flag after a short delay to allow events to process
      setTimeout(() => {
        isSettingFileProgrammatically = false;
        if (currentFileInput && currentFileInput.files && currentFileInput.files.length > 0) {
          console.log('File still present after events:', currentFileInput.files[0].name);
        } else {
          console.error('File disappeared after events!');
        }
      }, 200);
    } catch (error) {
      console.error('Error setting file:', error);
      alert('Error: Failed to save cropped image. Please try again.');
      return;
    }
    
    // Remove old preview if exists
    const oldPreview = document.getElementById('new-cover-preview');
    if (oldPreview) {
      oldPreview.remove();
    }
    
    // Remove old image container if it exists
    const currentContainer = document.getElementById('current-cover-container');
    if (currentContainer) {
      currentContainer.remove();
    }
    
    // Reset remove flag since we're uploading a new image
    const removeInput = document.getElementById('remove-cover-input');
    if (removeInput) {
      removeInput.value = '0';
    }
    
    // Create new preview container
    const previewContainer = document.createElement('div');
    previewContainer.id = 'new-cover-preview';
    previewContainer.className = 'current-cover-image';
    previewContainer.style.cssText = 'margin-top: 12px; padding: 12px; background: #f0fdf4; border: 2px solid #10b981; border-radius: 8px; text-align: center; position: relative;';
    
    const previewImg = document.createElement('img');
    previewImg.src = canvas.toDataURL('image/jpeg', 0.9);
    previewImg.style.cssText = 'max-width: 100%; max-height: 200px; border-radius: 8px; margin-bottom: 8px;';
    previewImg.alt = 'New cover image preview';
    
    const previewLabel = document.createElement('small');
    previewLabel.style.cssText = 'display: block; color: #059669; font-size: 0.85rem; font-weight: 600;';
    previewLabel.textContent = 'New cover image (will be saved when you submit)';
    
    previewContainer.appendChild(previewImg);
    previewContainer.appendChild(previewLabel);
    
    // Insert after the file input wrapper
    const formSection = currentFileInput.closest('.form-section');
    if (formSection) {
      const helpText = formSection.querySelector('.form-help');
      if (helpText) {
        formSection.insertBefore(previewContainer, helpText);
      } else {
        formSection.appendChild(previewContainer);
      }
    }
    
    // Close modal WITHOUT clearing the file input (we just set it!)
    closeImagePreview(true);
  }, 'image/jpeg', 0.9);
}

// Close modal when clicking outside or pressing Escape
document.addEventListener('DOMContentLoaded', function() {
  const modal = document.getElementById('imagePreviewModal');
  if (modal) {
    // Close on outside click
    modal.addEventListener('click', function(e) {
      if (e.target === modal) {
        closeImagePreview();
      }
    });
    
    // Close on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && modal.classList.contains('active')) {
        closeImagePreview();
      }
    });
  }
  
  // Debug: Log form data on submission to verify file is included
  const blogForm = document.getElementById('blogPostForm');
  if (blogForm) {
    blogForm.addEventListener('submit', function(e) {
      const coverInput = document.getElementById('cover-image-input');
      console.log('Form submit - checking cover input:', coverInput);
      if (coverInput) {
        console.log('Cover input found:', {
          name: coverInput.name,
          id: coverInput.id,
          form: coverInput.form ? 'connected' : 'NOT CONNECTED',
          files: coverInput.files ? coverInput.files.length + ' file(s)' : 'no files property'
        });
        if (coverInput.files && coverInput.files.length > 0) {
          console.log('Form submitting with cover image:', coverInput.files[0].name, coverInput.files[0].size, 'bytes');
        } else {
          console.warn('Form submitting WITHOUT cover image');
          // Try to find the file input in the form
          const formInputs = blogForm.querySelectorAll('input[type="file"]');
          console.log('All file inputs in form:', formInputs.length);
          formInputs.forEach((input, index) => {
            console.log(`File input ${index}:`, {
              name: input.name,
              id: input.id,
              files: input.files ? input.files.length : 'no files'
            });
          });
        }
      } else {
        console.error('Cover input element not found!');
      }
    });
  }
});
</script>
{% endblock %}
