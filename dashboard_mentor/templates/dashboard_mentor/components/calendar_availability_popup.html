{% load static %}

<!-- ===================== AVAILABILITY CALENDAR MODAL ===================== -->
<div id="availabilityCalendarOverlay" class="availability-calendar-overlay" aria-hidden="true">
  <div class="availability-calendar-backdrop" data-close-availability-calendar></div>

  <div class="availability-calendar-modal">
    <header class="availability-calendar-header">
      <div class="availability-calendar-title-group">
        <h2>Manage Sessions & Availability</h2>
      </div>

      <div class="availability-calendar-toggle-group">
        <button class="availability-calendar-toggle-btn" id="availabilityCalendarToggle" aria-label="Toggle view">
          <span class="toggle-label">Sessions</span>
          <span class="toggle-switch">
            <span class="toggle-slider"></span>
          </span>
          <span class="toggle-label">Availability</span>
        </button>
      </div>

      <div class="availability-calendar-nav">
        <button class="calendar-nav-btn" data-calendar-nav="prev" aria-label="Previous">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <div class="calendar-date-display" id="calendarDateDisplay">Loading...</div>
        <button class="calendar-nav-btn" data-calendar-nav="next" aria-label="Next">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>

      <div class="availability-calendar-header-actions">
        <button class="calendar-nav-btn" data-calendar-nav="today" aria-label="Today">Today</button>
        <div class="availability-calendar-view-toggle">
          <button class="view-toggle-btn" data-calendar-view="timeGridDay">Day</button>
          <button class="view-toggle-btn is-active" data-calendar-view="timeGridWeek">Week</button>
          <button class="view-toggle-btn" data-calendar-view="dayGridMonth">Month</button>
        </div>
        <button class="availability-calendar-save-btn" id="availabilityCalendarSaveBtn" disabled>Save</button>
        <button class="availability-calendar-close-btn" data-close-availability-calendar>‚úï</button>
      </div>
    </header>

    <section class="availability-calendar-body">
      <div id="mentorAvailabilityCalendar" class="availability-calendar-root"></div>
    </section>
  </div>
</div>

<!-- Collision Warning Modal -->
<div id="collisionWarningModal" class="collision-warning-overlay" aria-hidden="true">
  <div class="collision-warning-backdrop" data-close-collision-warning></div>
  <div class="collision-warning-modal">
    <div class="collision-warning-header">
      <h3>‚ö†Ô∏è Collision Detected</h3>
      <button class="collision-warning-close" data-close-collision-warning>‚úï</button>
    </div>
    <div class="collision-warning-body">
      <p>You have overlapping availability slots. Please resolve the conflicts before saving.</p>
      <div id="collisionList" class="collision-list">
        <!-- Collisions will be listed here -->
      </div>
    </div>
    <div class="collision-warning-footer">
      <button class="collision-warning-btn-ok" data-close-collision-warning>OK</button>
    </div>
  </div>
</div>

<!-- Include Slot Settings Popup -->
{% include 'dashboard_mentor/components/slot_settings_popup.html' %}

<!-- Include Collision Resolution Popup -->
{% include 'dashboard_mentor/components/collision_resolution_popup.html' %}

<!-- Switch to Availability Mode Popup -->
<div id="switchToAvailabilityModePopup" class="switch-mode-overlay" aria-hidden="true">
  <div class="switch-mode-backdrop" data-close-switch-mode></div>
  <div class="switch-mode-modal">
    <div class="switch-mode-header">
      <h3>Switch to Availability Mode</h3>
      <button class="switch-mode-close" data-close-switch-mode aria-label="Close">‚úï</button>
    </div>
    <div class="switch-mode-body">
      <div class="switch-mode-icon">üìÖ</div>
      <p class="switch-mode-message">
        To modify availability slots, you need to switch to <strong>Availability</strong> mode.
      </p>
      <p class="switch-mode-submessage">
        In <strong>Sessions</strong> mode, availability slots are view-only and cannot be moved or resized.
      </p>
    </div>
    <div class="switch-mode-footer">
      <button class="switch-mode-btn-cancel" data-close-switch-mode>Cancel</button>
      <button class="switch-mode-btn-switch" id="switchToAvailabilityModeBtn">
        <span>Switch to Availability Mode</span>
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
    </div>
  </div>
</div>

<!-- Schedule Session Popup -->
<div id="scheduleSessionPopup" class="schedule-session-overlay" aria-hidden="true">
  <div class="schedule-session-backdrop" data-close-schedule-session></div>
  <div class="schedule-session-modal">
    <div class="schedule-session-header">
      <h3>Schedule a Session</h3>
      <button class="schedule-session-close" data-close-schedule-session aria-label="Close">‚úï</button>
    </div>
    <div class="schedule-session-body">
      <div class="schedule-session-slot-info" id="scheduleSessionSlotInfo">
        <!-- Slot time information will be displayed here -->
      </div>
      <div class="schedule-session-form">
        <label for="scheduleSessionEmail" class="schedule-session-label">Client Email</label>
        <input 
          type="email" 
          id="scheduleSessionEmail" 
          class="schedule-session-input" 
          placeholder="Enter client email address"
          required
        />
      </div>
    </div>
    <div class="schedule-session-footer">
      <button class="schedule-session-btn-cancel" data-close-schedule-session>Cancel</button>
      <button class="schedule-session-btn-submit" id="scheduleSessionSubmitBtn">Schedule a session</button>
    </div>
  </div>
</div>


<!-- ===================== FullCalendar v6 CSS ===================== -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.css">

<!-- ===================== FullCalendar v6 JS (core + plugins) ===================== -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/locales-all.global.min.js"></script>

<!-- ===================== CSS ===================== -->
<style>
/* Overlay */
.availability-calendar-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(15, 23, 42, 0.6);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  z-index: 2000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}
.availability-calendar-overlay.is-visible { 
  opacity: 1;
  visibility: visible;
}

/* Modal */
.availability-calendar-modal {
  background: #ffffff;
  width: 95%;
  max-width: 1400px;
  height: 90vh;
  border-radius: 24px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 
    0 25px 50px -12px rgba(0, 0, 0, 0.25),
    0 0 0 1px rgba(0, 0, 0, 0.05); /* Subtle border ring */
  transform: translateY(20px);
  transition: transform 0.3s ease, opacity 0.3s ease;
  opacity: 0;
}

.availability-calendar-overlay.is-visible .availability-calendar-modal {
  transform: translateY(0);
  opacity: 1;
}

/* Header */
.availability-calendar-header {
  padding: 20px 32px;
  background: #ffffff;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 24px;
}

.availability-calendar-title-group {
  flex: 1;
  min-width: 0;
}

.availability-calendar-title-group h2 {
  margin: 0;
  font-size: 1.5rem;
  font-weight: 700;
  color: #0f172a;
  letter-spacing: -0.025em;
  line-height: 1.2;
}


/* Toggle Group */
.availability-calendar-toggle-group {
  display: flex;
  align-items: center;
}

.availability-calendar-toggle-btn {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 16px;
  background: #f0fdf4;
  border: 1px solid #10b981;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 0.875rem;
  font-weight: 500;
  color: #64748b;
}

.availability-calendar-toggle-btn:hover {
  background: #dcfce7;
  border-color: #059669;
}

.availability-calendar-toggle-btn .toggle-label {
  transition: color 0.2s ease;
  white-space: nowrap;
  font-weight: 600; /* Always bold */
}

.availability-calendar-toggle-btn .toggle-switch {
  position: relative;
  width: 44px;
  height: 24px;
  background: #10b981;
  border-radius: 12px;
  transition: background 0.2s ease;
}

.availability-calendar-toggle-btn.active .toggle-switch {
  background:  #3b82f6;
}

.availability-calendar-toggle-btn.active {
  background: #eff6ff; /* Light blue background */
  border-color: #3b82f6;
}

.availability-calendar-toggle-btn .toggle-slider {
  position: absolute;
  top: 2px;
  left: 2px;
  width: 20px;
  height: 20px;
  background: white;
  border-radius: 50%;
  transition: transform 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.availability-calendar-toggle-btn .toggle-slider::before {
  content: none;
}

.availability-calendar-toggle-btn.active .toggle-slider {
  transform: translateX(20px);
}

/* Sessions mode (not active) - Green */
.availability-calendar-toggle-btn:not(.active) .toggle-label:first-child {
  color: #10b981;
  font-weight: 600; /* Always bold */
}

.availability-calendar-toggle-btn:not(.active) .toggle-label:last-child {
  color: #64748b;
  font-weight: 600; /* Always bold */
}

/* Availability mode (active) - Blue */
.availability-calendar-toggle-btn.active .toggle-label:first-child {
  color: #64748b; /* Gray for Sessions label */
  font-weight: 600; /* Always bold */
}

.availability-calendar-toggle-btn.active .toggle-label:last-child {
  color: #3b82f6; /* Blue text for Availability label */
  font-weight: 600; /* Always bold */
}

/* Navigation Group */
.availability-calendar-nav {
  display: flex;
  min-width: 280px;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  background: #f8fafc;
  padding: 4px;
  border-radius: 12px;
  border: 1px solid #e2e8f0;
}

.calendar-nav-btn {
  border: none;
  background: transparent;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  cursor: pointer;
  color: #64748b;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.calendar-nav-btn:hover {
  background: #ffffff;
  color: #0f172a;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.calendar-date-display {
  padding: 0 16px;
  font-size: 0.925rem;
  font-weight: 600;
  color: #334155;
  white-space: nowrap;
  min-width: 140px;
  text-align: center;
  font-variant-numeric: tabular-nums;
}

/* Header Actions */
.availability-calendar-header-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}

/* Today Button */
.calendar-nav-btn[data-calendar-nav="today"] {
  width: auto;
  padding: 8px 20px;
  background: #f1f5f9;
  color: #475569;
  font-weight: 600;
  font-size: 0.875rem;
  height: 36px;
  border-radius: 10px;
}

.calendar-nav-btn[data-calendar-nav="today"]:hover {
  background: #e2e8f0;
  color: #1e293b;
}

/* View Toggle (Segmented Control) */
.availability-calendar-view-toggle {
  min-width: 240px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: #f1f5f9;
  border-radius: 10px;
  padding: 4px;
  gap: 0;
  border: 1px solid #e2e8f0;
}

.view-toggle-btn {
  padding: 6px 16px;
  border: none;
  cursor: pointer;
  border-radius: 8px;
  background: transparent;
  color: #64748b;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.2s ease;
  position: relative;
}

.view-toggle-btn:hover:not(.is-active) {
  color: #334155;
}

.view-toggle-btn.is-active {
  background: #3b82f6;
  color: #ffffff;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  font-weight: 600;
}

/* Save Button */
.availability-calendar-save-btn {
  border: none;
  background: #cbd5e1;
  color: #64748b;
  padding: 8px 20px;
  border-radius: 10px;
  cursor: not-allowed;
  font-size: 0.875rem;
  font-weight: 600;
  transition: all 0.2s ease;
  margin-left: 8px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Disabled state - just grey, no hover effects */
.availability-calendar-save-btn:disabled {
  background: #cbd5e1 !important;
  color: #64748b !important;
  cursor: not-allowed !important;
}

.availability-calendar-save-btn:disabled:hover {
  background: #cbd5e1 !important; /* Stay grey on hover when disabled */
  color: #64748b !important;
}

/* Enabled state - green with darker green hover and white text */
.availability-calendar-save-btn:not(:disabled) {
  background: #10b981 !important; /* Green background when enabled */
  color: #ffffff !important;
  cursor: pointer !important;
}

.availability-calendar-save-btn:not(:disabled):hover {
  background: #059669 !important; /* Darker green on hover */
  color: #ffffff !important;
}

/* Close Button */
.availability-calendar-close-btn {
  border: none;
  background: transparent;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  color: #94a3b8;
  font-size: 1.25rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  margin-left: 8px;
}

.availability-calendar-close-btn:hover {
  background: #fee2e2;
  color: #ef4444;
  transform: rotate(90deg);
}

/* Body */
.availability-calendar-body {
  flex: 1;
  min-height: 0;
  display: flex;
  padding: 0; /* Remove padding for flush look */
  background: #f8fafc; /* Slight contrast for calendar area */
  position: relative;
}

.availability-calendar-root {
  flex: 1;
  min-height: 420px;
  border: none;
  background: #ffffff;
}

/* --- FullCalendar Overrides --- */

/* General Text */
.availability-calendar-root {
  font-family: inherit;
  --fc-border-color: #cbd5e1; /* Stronger, balanced border color */
  --fc-page-bg-color: #ffffff;
  --fc-neutral-bg-color: #f8fafc;
  --fc-today-bg-color: #f0fdf4;
  --fc-now-indicator-color: #ef4444;
}

/* Headers */
.fc-theme-standard th {
  border: 1px solid var(--fc-border-color); /* Restore native borders */
  background: #f8fafc;
}

.fc-col-header-cell-cushion {
  color: #64748b;
  font-weight: 600;
  font-size: 0.875rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 8px 0;
}

/* Hover styles for clickable day headers in week view */
#mentorAvailabilityCalendar.fc .fc-timeGridWeek-view .fc-col-header-cell,
#mentorAvailabilityCalendar.fc .fc-timeGridWeek-view .fc-scrollgrid-sync-inner,
#mentorAvailabilityCalendar.fc .fc-timeGridWeek-view .fc-col-header-cell-cushion {
  cursor: pointer !important;
  transition: background-color 0.2s ease;
}

#mentorAvailabilityCalendar.fc .fc-timeGridWeek-view .fc-col-header-cell:hover,
#mentorAvailabilityCalendar.fc .fc-timeGridWeek-view .fc-col-header-cell:hover .fc-scrollgrid-sync-inner {
  background-color: #e2e8f0 !important;
  cursor: pointer !important;
}

#mentorAvailabilityCalendar.fc .fc-timeGridWeek-view .fc-col-header-cell:hover .fc-col-header-cell-cushion {
  color: #334155;
  cursor: pointer !important;
}

/* Ensure pointer cursor on all clickable header elements */
#mentorAvailabilityCalendar.fc .fc-timeGridWeek-view .fc-col-header-cell * {
  cursor: pointer !important;
}

/* Time Labels */
.fc-timegrid-axis-cushion,
.fc-timegrid-slot-label-cushion {
  color: #64748b; /* Slightly darker for readability */
  font-size: 0.75rem;
  font-weight: 500;
}

/* Slots */
.availability-calendar-root .fc-timegrid-slot {
  height: 20px; 
}

/* Ensure Month View borders are visible and match */
.fc-theme-standard td, 
.fc-theme-standard .fc-scrollgrid {
  border-color: var(--fc-border-color);
}

/* Hour slots styling (targeted by JS adding .fc-hour-slot) */
.availability-calendar-root .fc-hour-slot {
  border-top-color: var(--fc-border-color) !important;
}

/* Events */
/* Availability slot content wrapper */
.availability-slot-content-wrapper {
  position: relative;
  width: 100%;
  height: 100%;
  padding: 2px 4px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  min-height: 100%;
}

.availability-slot-content {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  width: 100%;
  height: 100%;
  padding: 8px 3px; /* Space for delete button */
  font-size: 0.7rem;
  line-height: 1.2;
}

.availability-slot-time {
  font-weight: 600;
  color: #ffffff;
  margin-bottom: 2px;
  white-space: nowrap;
}

.availability-slot-duration {
  font-weight: 400;
  color: rgba(255, 255, 255, 0.85);
  font-size: 0.65rem;
  white-space: nowrap;
}

/* Delete button for availability slots - positioned top right */
.availability-slot-delete-btn {
  position: absolute;
  top: 2px;
  right: 2px;
  background: rgba(255, 255, 255, 0.9);
  border: none;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  min-width: 18px;
  min-height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #ef4444;
  font-size: 16px;
  font-weight: bold;
  line-height: 1;
  padding: 0;
  transition: all 0.2s ease;
  z-index: 10;
}

.availability-slot-delete-btn:hover {
  background: #ef4444;
  color: white;
  transform: scale(1.1);
}

.availability-slot-delete-btn:active {
  transform: scale(0.95);
}

/* Transparent availability slots in Sessions mode */
.fc-event.availability-slot-readonly {
  opacity: 0.35;
  cursor: pointer !important; /* Show pointer cursor to indicate clickable */
  user-select: none !important; /* Prevent text selection */
  transition: opacity 0.2s ease; /* Smooth opacity transition */
  /* Prevent dragging by disabling pointer events on drag handles */
  touch-action: none !important; /* Prevent touch gestures */
}

.fc-event.availability-slot-readonly:hover {
  opacity: 0.7 !important; /* Less transparent on hover - but still transparent */
  cursor: pointer !important; /* Show pointer cursor on hover */
}

/* Prevent dragging handles from appearing on readonly slots */
.fc-event.availability-slot-readonly .fc-event-resizer {
  display: none !important;
  pointer-events: none !important;
}

.fc-event.availability-slot-readonly .fc-event-resizer-start,
.fc-event.availability-slot-readonly .fc-event-resizer-end {
  display: none !important;
  pointer-events: none !important;
}

.fc-event.availability-slot-readonly .availability-slot-time,
.fc-event.availability-slot-readonly .availability-slot-duration {
  color: #64748b !important;
}

/* Schedule Session Popup Styles */
.schedule-session-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 10000;
  align-items: center;
  justify-content: center;
}

.schedule-session-overlay[aria-hidden="false"] {
  display: flex;
}

.schedule-session-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(2px);
}

.schedule-session-modal {
  position: relative;
  background: white;
  border-radius: 12px;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  width: 90%;
  max-width: 500px;
  max-height: 90vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  z-index: 10001;
}

.schedule-session-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  border-bottom: 1px solid #e5e7eb;
}

.schedule-session-header h3 {
  margin: 0;
  font-size: 1.25rem;
  font-weight: 600;
  color: #1f2937;
}

.schedule-session-close {
  background: none;
  border: none;
  font-size: 1.5rem;
  color: #6b7280;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  transition: all 0.2s ease;
}

.schedule-session-close:hover {
  background: #f3f4f6;
  color: #1f2937;
}

.schedule-session-body {
  padding: 24px;
  flex: 1;
  overflow-y: auto;
}

.schedule-session-slot-info {
  background: #f9fafb;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 20px;
}

.schedule-session-date {
  font-size: 1rem;
  font-weight: 600;
  color: #1f2937;
  margin-bottom: 8px;
}

.schedule-session-time {
  font-size: 0.95rem;
  color: #4b5563;
  margin-bottom: 4px;
}

.schedule-session-duration {
  font-size: 0.875rem;
  color: #6b7280;
}

.schedule-session-form {
  margin-bottom: 0;
}

.schedule-session-label {
  display: block;
  font-size: 0.875rem;
  font-weight: 500;
  color: #374151;
  margin-bottom: 8px;
}

.schedule-session-input {
  width: 100%;
  padding: 12px 16px;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  font-size: 1rem;
  color: #1f2937;
  transition: all 0.2s ease;
  box-sizing: border-box;
}

.schedule-session-input:focus {
  outline: none;
  border-color: #10b981;
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
}

.schedule-session-footer {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 12px;
  padding: 20px 24px;
  border-top: 1px solid #e5e7eb;
}

.schedule-session-btn-cancel,
.schedule-session-btn-submit {
  padding: 10px 20px;
  border-radius: 8px;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  border: none;
}

.schedule-session-btn-cancel {
  background: #f3f4f6;
  color: #374151;
}

.schedule-session-btn-cancel:hover {
  background: #e5e7eb;
}

.schedule-session-btn-submit {
  background: #10b981;
  color: white;
}

.schedule-session-btn-submit:hover {
  background: #059669;
}

.schedule-session-btn-submit:active {
  transform: scale(0.98);
}

/* Switch to Availability Mode Popup Styles */
.switch-mode-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 10002;
  align-items: center;
  justify-content: center;
}

.switch-mode-overlay[aria-hidden="false"] {
  display: flex;
}

.switch-mode-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(2px);
}

.switch-mode-modal {
  position: relative;
  background: white;
  border-radius: 12px;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  width: 90%;
  max-width: 450px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  z-index: 10003;
}

.switch-mode-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  border-bottom: 1px solid #e5e7eb;
}

.switch-mode-header h3 {
  margin: 0;
  font-size: 1.25rem;
  font-weight: 600;
  color: #1f2937;
}

.switch-mode-close {
  background: none;
  border: none;
  font-size: 1.5rem;
  color: #6b7280;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  transition: all 0.2s ease;
}

.switch-mode-close:hover {
  background: #f3f4f6;
  color: #1f2937;
}

.switch-mode-body {
  padding: 32px 24px;
  text-align: center;
}

.switch-mode-icon {
  font-size: 3rem;
  margin-bottom: 16px;
}

.switch-mode-message {
  font-size: 1rem;
  color: #374151;
  margin-bottom: 12px;
  line-height: 1.5;
}

.switch-mode-message strong {
  color: #1f2937;
  font-weight: 600;
}

.switch-mode-submessage {
  font-size: 0.875rem;
  color: #6b7280;
  line-height: 1.5;
}

.switch-mode-submessage strong {
  color: #4b5563;
  font-weight: 500;
}

.switch-mode-footer {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 12px;
  padding: 20px 24px;
  border-top: 1px solid #e5e7eb;
}

.switch-mode-btn-cancel,
.switch-mode-btn-switch {
  padding: 10px 20px;
  border-radius: 8px;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  border: none;
  display: flex;
  align-items: center;
  gap: 8px;
}

.switch-mode-btn-cancel {
  background: #f3f4f6;
  color: #374151;
}

.switch-mode-btn-cancel:hover {
  background: #e5e7eb;
}

.switch-mode-btn-switch {
  background: #10b981;
  color: white;
}

.switch-mode-btn-switch:hover {
  background: #059669;
}

.switch-mode-btn-switch:active {
  transform: scale(0.98);
}

.fc-event {
  border: none;
  border-radius: 4px;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  font-size: 0.8rem;
  font-weight: 500;
  padding: 2px;
}

.fc-v-event {
  background-color: #d1fae5;
  border-left: 3px solid #10b981;
  color: #065f46;
}

.fc-event-main {
  color: inherit;
  padding: 2px 4px;
}

/* Now Indicator */
.fc-timegrid-now-indicator-line {
  border-color: #ef4444;
  border-width: 2px;
}
.fc-timegrid-now-indicator-arrow {
  border-color: #ef4444;
  border-width: 6px;
}

/* Scrollbar */
.fc-scroller::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
.fc-scroller::-webkit-scrollbar-track {
  background: transparent;
}
.fc-scroller::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 4px;
}
.fc-scroller::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Header */
.availability-calendar-header {
  padding: 12px 18px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 16px;
}

.availability-calendar-title-group {
  flex: 1;
  min-width: 0;
}

.availability-calendar-title-group h2 {
  margin: 0;
  font-size: 1.125rem;
  font-weight: 600;
  color: #1e293b;
  line-height: 1.3;
}


.availability-calendar-nav {
  display: flex;
  align-items: center;
  gap: 4px;
}

.calendar-nav-btn {
  border: none;
  background: #f1f5f9;
  padding: 6px 10px;
  border-radius: 6px;
  cursor: pointer;
  color: #64748b;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 32px;
  height: 32px;
}

.calendar-nav-btn:hover {
  background: #e2e8f0;
  color: #1e293b;
}

.calendar-nav-btn svg {
  display: block;
}

.calendar-date-display {
  padding: 6px 16px;
  font-size: 0.875rem;
  font-weight: 600;
  color: #1e293b;
  white-space: nowrap;
  min-width: 120px;
  text-align: center;
}

.availability-calendar-header-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

.availability-calendar-body {
  flex: 1;
  min-height: 0;
  display: flex;
  padding: 10px;
}

.availability-calendar-root {
  flex: 1;
  min-height: 420px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid #e5e7eb;
}

/* View Toggle Buttons - grouped in a row */
.availability-calendar-view-toggle {
  display: inline-flex;
  align-items: center;
  background: #f1f5f9;
  border-radius: 8px;
  padding: 2px;
  gap: 0;
  border: 1px solid #e2e8f0;
}

.view-toggle-btn {
  padding: 6px 12px;
  border: none;
  cursor: pointer;
  border-radius: 6px;
  background: transparent;
  color: #64748b;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.15s ease;
}

.view-toggle-btn:hover:not(.is-active) {
  background: #e2e8f0;
  color: #1e293b;
}

.view-toggle-btn.is-active {
  background: #3b82f6;
  color: #fff;
}

/* Save Button - mobile */
.availability-calendar-save-btn {
  border: none;
  background: #cbd5e1;
  color: #64748b;
  padding: 8px 20px;
  border-radius: 10px;
  cursor: not-allowed;
  font-size: 0.875rem;
  font-weight: 600;
  transition: all 0.2s ease;
  margin-left: 8px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Disabled state - just grey, no hover effects */
.availability-calendar-save-btn:disabled {
  background: #cbd5e1 !important;
  color: #64748b !important;
  cursor: not-allowed !important;
}

.availability-calendar-save-btn:disabled:hover {
  background: #cbd5e1 !important; /* Stay grey on hover when disabled */
  color: #64748b !important;
}

/* Enabled state - green with darker green hover and white text */
.availability-calendar-save-btn:not(:disabled) {
  background: #10b981 !important; /* Green background when enabled */
  color: #ffffff !important;
  cursor: pointer !important;
}

.availability-calendar-save-btn:not(:disabled):hover {
  background: #059669 !important; /* Darker green on hover */
  color: #ffffff !important;
}

/* Close Button - separate */
.availability-calendar-close-btn {
  border: none;
  background: #f1f5f9;
  padding: 8px 12px;
  border-radius: 8px;
  cursor: pointer;
  color: #64748b;
  font-size: 1.125rem;
  line-height: 1;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
}

.availability-calendar-close-btn:hover {
  background: #e2e8f0;
  color: #ef4444;
}

/* Make time slot rows thinner - target all possible elements */
.availability-calendar-root .fc-timegrid-slot,
.availability-calendar-root .fc-timegrid-slot table,
.availability-calendar-root .fc-timegrid-slot tr,
.availability-calendar-root .fc-timegrid-slot td,
.availability-calendar-root .fc-timegrid-slot-lane,
.availability-calendar-root .fc-timegrid-slot-lane table,
.availability-calendar-root .fc-timegrid-slot-lane tr,
.availability-calendar-root .fc-timegrid-slot-lane td {
  height: 3px !important;
  min-height: 3px !important;
  max-height: 3px !important;
  line-height: 3px !important;
}

/* Target the table rows directly */
.availability-calendar-root table.fc-timegrid-slots tr {
  height: 3px !important;
  min-height: 3px !important;
  max-height: 3px !important;
}

.availability-calendar-root table.fc-timegrid-slots tr td {
  height: 3px !important;
  min-height: 3px !important;
  max-height: 3px !important;
  padding: 0 !important;
  line-height: 3px !important;
}

/* Hide horizontal borders for 5-min slots, but PRESERVE vertical borders */
.availability-calendar-root .fc-timegrid-slot {
  border-top: none !important;
  border-bottom: none !important;
}

/* Only show borders on hour slots (slot 0 and every 12th slot) */
.availability-calendar-root .fc-hour-slot {
  border-top: 1px solid var(--fc-border-color) !important;
}

/* Ensure Month View borders are strong */
.availability-calendar-root .fc-daygrid-day-frame {
  border: 0px solid var(--fc-border-color);
}

/* Style hour labels */
.availability-calendar-root .fc-timegrid-slot-label {
  font-size: 0.75rem;
  padding: 2px 8px;
}

/* Make slot labels show hour ranges */
.availability-calendar-root .fc-timegrid-slot-label-cushion {
  font-weight: 500;
}

/* Collision Warning Modal */
.collision-warning-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(15, 23, 42, 0.6);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
  z-index: 3000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s ease, visibility 0.2s ease;
}

.collision-warning-overlay.is-visible {
  opacity: 1;
  visibility: visible;
}

.collision-warning-backdrop {
  position: absolute;
  inset: 0;
}

.collision-warning-modal {
  position: relative;
  background: #ffffff;
  width: 90%;
  max-width: 500px;
  border-radius: 16px;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  transform: translateY(10px);
  transition: transform 0.2s ease, opacity 0.2s ease;
  opacity: 0;
}

.collision-warning-overlay.is-visible .collision-warning-modal {
  transform: translateY(0);
  opacity: 1;
}

.collision-warning-header {
  padding: 20px 24px;
  border-bottom: 1px solid #e5e7eb;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.collision-warning-header h3 {
  margin: 0;
  font-size: 1.25rem;
  font-weight: 700;
  color: #dc2626;
}

.collision-warning-close {
  border: none;
  background: transparent;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  cursor: pointer;
  color: #94a3b8;
  font-size: 1.125rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.collision-warning-close:hover {
  background: #fee2e2;
  color: #dc2626;
}

.collision-warning-body {
  padding: 24px;
}

.collision-warning-body > p {
  margin: 0 0 16px 0;
  color: #64748b;
  font-size: 0.95rem;
  line-height: 1.5;
}

.collision-list {
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 12px;
  background: #f8fafc;
}

.collision-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 0;
  border-bottom: 1px solid #e5e7eb;
}

.collision-item:last-child {
  border-bottom: none;
}

.collision-number {
  font-weight: 600;
  color: #64748b;
  min-width: 24px;
}

.collision-slots {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
}

.collision-slot {
  padding: 4px 12px;
  background: #fee2e2;
  border: 1px solid #fecaca;
  border-radius: 6px;
  color: #991b1b;
  font-weight: 500;
  font-size: 0.875rem;
  font-family: 'Courier New', monospace;
}

.collision-vs {
  color: #64748b;
  font-weight: 600;
  font-size: 0.875rem;
}

.collision-warning-footer {
  padding: 16px 24px;
  border-top: 1px solid #e5e7eb;
  display: flex;
  justify-content: flex-end;
}

.collision-warning-btn-ok {
  padding: 8px 20px;
  background: #3b82f6;
  color: #ffffff;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.875rem;
  transition: background 0.2s ease;
}

.collision-warning-btn-ok:hover {
  background: #2563eb;
}
.fc-direction-ltr .fc-timegrid-col-events {
margin: 0}

</style>

<!-- ===================== JS ===================== -->
<script>
(function() {
  const overlay = document.getElementById("availabilityCalendarOverlay");
  const calendarRoot = document.getElementById("mentorAvailabilityCalendar");
  const openTriggers = document.querySelectorAll("[data-open-availability-calendar]");
  const closeTriggers = document.querySelectorAll("[data-close-availability-calendar]");
  const viewBtnEls = document.querySelectorAll("[data-calendar-view]");
  const dateDisplayEl = document.getElementById("calendarDateDisplay");

  // Format date display based on current view type
  function updateDateDisplay() {
    if (!calendar || !dateDisplayEl) return;
    
    const view = calendar.view;
    const start = view.activeStart;
    const end = view.activeEnd;
    
    let displayText = '';
    
    if (view.type === 'timeGridDay') {
      // Day view: show specific date (e.g., "January 15, 2024")
      const dateFormatter = new Intl.DateTimeFormat('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      displayText = dateFormatter.format(start);
    } else if (view.type === 'timeGridWeek') {
      // Week view: show date range (e.g., "Jan 15 - Jan 21, 2024")
      const startFormatter = new Intl.DateTimeFormat('en-US', {
        month: 'short',
        day: 'numeric'
      });
      const endFormatter = new Intl.DateTimeFormat('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
      const startStr = startFormatter.format(start);
      const endStr = endFormatter.format(new Date(end.getTime() - 1)); // Subtract 1ms to get last day
      displayText = startStr + ' - ' + endStr;
    } else if (view.type === 'dayGridMonth') {
      // Month view: show month name and year (e.g., "January 2024")
      // Calculate the month from the middle of the view range to avoid boundary issues
      // This handles cases where activeStart might be at the end of previous month
      const midDate = new Date((start.getTime() + end.getTime()) / 2);
      // Get the first day of the month that midDate falls into
      const monthStart = new Date(midDate.getFullYear(), midDate.getMonth(), 1);
      const monthFormatter = new Intl.DateTimeFormat('en-US', {
        year: 'numeric',
        month: 'long'
      });
      displayText = monthFormatter.format(monthStart);
    }
    
    dateDisplayEl.textContent = displayText;
  }

  // Get current UTC offset for a timezone (handles DST automatically)
  // Uses JavaScript's native timezone support - IANA timezones already handle DST
  function getCurrentTimezoneOffset(ianaId) {
    try {
      const now = new Date();
      
      // Use Intl.DateTimeFormat to get the timezone offset
      // This automatically handles DST based on the current date
      const formatter = new Intl.DateTimeFormat('en', {
        timeZone: ianaId,
        timeZoneName: 'longOffset'
      });
      
      const parts = formatter.formatToParts(now);
      const offsetPart = parts.find(p => p.type === 'timeZoneName');
      
      if (offsetPart && offsetPart.value) {
        // offsetPart.value will be like "GMT+1", "GMT+02:00", "GMT+1:00", etc.
        // Extract the offset part
        const offsetMatch = offsetPart.value.match(/GMT([+-])(\d{1,2})(:?(\d{2}))?/);
        if (offsetMatch) {
          const sign = offsetMatch[1];
          const hours = parseInt(offsetMatch[2]) || 0;
          const minutes = offsetMatch[4] ? parseInt(offsetMatch[4]) : 0;
          
          if (minutes === 0) {
            return 'UTC' + sign + String(hours).padStart(2, '0');
          } else {
            return 'UTC' + sign + String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0');
          }
        }
      }
      
      // Fallback: Calculate offset by comparing what time it is in UTC vs the timezone
      // Format the same moment in both timezones and compare
      const utcTimeStr = now.toLocaleString('sv-SE', { timeZone: 'UTC' }); // ISO-like format
      const tzTimeStr = now.toLocaleString('sv-SE', { timeZone: ianaId });
      
      // Parse both (format: "YYYY-MM-DD HH:mm:ss")
      const utcDate = new Date(utcTimeStr.replace(' ', 'T') + 'Z');
      const tzDate = new Date(tzTimeStr.replace(' ', 'T') + 'Z');
      
      // The difference tells us the offset
      const diffMs = tzDate.getTime() - utcDate.getTime();
      const diffHours = diffMs / (1000 * 60 * 60);
      
      const sign = diffHours >= 0 ? '+' : '-';
      const absHours = Math.abs(diffHours);
      const hours = Math.floor(absHours);
      const minutes = Math.round((absHours - hours) * 60);
      
      if (minutes === 0) {
        return 'UTC' + sign + String(hours).padStart(2, '0');
      } else {
        return 'UTC' + sign + String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0');
      }
    } catch (e) {
      console.warn('Could not get timezone offset for', ianaId, ':', e);
      return 'UTC+0';
    }
  }

  // Get timezone display name from IANA ID using COMMON_TIMEZONES, with dynamic offset
  function getTimezoneDisplayName(ianaId) {
    try {
      const timezonesDataEl = document.getElementById('timezonesData');
      if (timezonesDataEl && timezonesDataEl.textContent) {
        const timezones = JSON.parse(timezonesDataEl.textContent);
        const tz = timezones.find(t => t.id === ianaId);
        if (tz) {
          // Get current offset dynamically (handles DST)
          const currentOffset = getCurrentTimezoneOffset(ianaId);
          // Return format: "Prague (UTC+1)" or "Prague (UTC+2)" depending on season
          return tz.name + ' (' + currentOffset + ')';
        }
      }
    } catch (e) {
      console.warn('Could not get timezone display name:', e);
    }
    // Fallback: return IANA ID with dynamic offset
    const currentOffset = getCurrentTimezoneOffset(ianaId);
    return ianaId + ' (' + currentOffset + ')';
  }

  // Helper: Find IANA ID from display name or IANA ID in COMMON_TIMEZONES
  function findIanaIdFromTimezone(timezoneValue) {
    if (!timezoneValue || !timezoneValue.trim()) return null;
    
    const trimmed = timezoneValue.trim();
    
    try {
      const timezonesDataEl = document.getElementById('timezonesData');
      if (timezonesDataEl && timezonesDataEl.textContent) {
        const timezones = JSON.parse(timezonesDataEl.textContent);
        
        // First, try exact IANA ID match
        const exactMatch = timezones.find(t => t.id === trimmed);
        if (exactMatch) {
          return exactMatch.id;
        }
        
        // Then, try matching by display name (e.g., "Prague (UTC+1)")
        const nameMatch = timezones.find(t => {
          // Match exact name
          if (t.name === trimmed) return true;
          // Match name with offset (e.g., "Prague (UTC+1)")
          const nameWithOffset = t.name + ' (' + t.offset + ')';
          if (nameWithOffset === trimmed) return true;
          // Match partial name (e.g., "Prague" matches "Prague (UTC+1)")
          if (trimmed.startsWith(t.name + ' (')) return true;
          return false;
        });
        
        if (nameMatch) {
          return nameMatch.id;
        }
      }
    } catch (e) {
      console.warn('Error looking up timezone in COMMON_TIMEZONES:', e);
    }
    
    // If it looks like an IANA ID (contains '/'), return as-is
    if (trimmed.includes('/')) {
      return trimmed;
    }
    
    return null;
  }

  // Resolve mentor timezone from global userProfileData JSON (provided by dashboard_mentor/base.html)
  function resolveMentorTimezone() {
    let tz = null;
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const rawText = dataEl.textContent.trim();
        console.log('[Calendar] userProfileData raw text:', rawText);
        
        if (rawText) {
          const data = JSON.parse(rawText);
          console.log('[Calendar] userProfileData parsed:', data);
          
          let rawTimezone = null;
          
          // Priority 1: selected_timezone
          if (data.selected_timezone && data.selected_timezone.trim() !== '') {
            rawTimezone = data.selected_timezone.trim();
            console.log('[Calendar] Using selected_timezone:', rawTimezone);
          } 
          // Priority 2: detected_timezone
          else if (data.detected_timezone && data.detected_timezone.trim() !== '') {
            rawTimezone = data.detected_timezone.trim();
            console.log('[Calendar] Using detected_timezone:', rawTimezone);
          } else {
            console.warn('[Calendar] Both selected_timezone and detected_timezone are empty');
            console.warn('[Calendar] selected_timezone:', data.selected_timezone);
            console.warn('[Calendar] detected_timezone:', data.detected_timezone);
            // Fallback: try browser-detected timezone
            try {
              const browserTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
              if (browserTz) {
                rawTimezone = browserTz;
                console.log('[Calendar] Fallback: Using browser-detected timezone:', browserTz);
              }
            } catch (e) {
              console.warn('[Calendar] Could not detect browser timezone:', e);
            }
          }
          
          // Convert to IANA ID if we have a timezone value
          if (rawTimezone) {
            const ianaId = findIanaIdFromTimezone(rawTimezone);
            if (ianaId) {
              tz = ianaId;
              console.log('[Calendar] Resolved timezone:', rawTimezone, '->', ianaId);
            } else {
              // If lookup failed but it looks like an IANA ID, use it
              if (rawTimezone.includes('/')) {
                tz = rawTimezone;
                console.log('[Calendar] Using raw timezone as IANA ID:', tz);
              } else {
                console.warn('[Calendar] Could not resolve timezone:', rawTimezone);
              }
            }
          }
        } else {
          console.warn('[Calendar] userProfileData element has empty textContent');
        }
      } else {
        console.error('[Calendar] userProfileData element not found!');
      }
    } catch (e) {
      console.error('[Calendar] Could not resolve mentor timezone:', e);
    }
    
    // Final fallback: browser timezone or UTC
    if (!tz) {
      try {
        tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
        console.log('[Calendar] Final fallback: Using browser timezone:', tz);
      } catch (e) {
        tz = 'UTC';
        console.warn('[Calendar] Final fallback: Using UTC');
      }
    }
    
    console.log('[Calendar] Final resolved timezone:', tz);
    return tz || 'UTC';
  }

  let calendar = null;
  let mentorTimezone = resolveMentorTimezone();
  let mentorTimezoneDisplay = getTimezoneDisplayName(mentorTimezone);
  let isAvailabilityMode = false; // Track toggle state
  let sessionLength = 60; // Default session length in minutes
  let createdAvailabilitySlots = []; // Track created availability slots
  let originalSavedSlots = []; // Track original saved state for change detection
  let originalDatesWithSlots = new Set(); // Track dates that originally had slots
  const saveBtn = document.getElementById("availabilityCalendarSaveBtn");
  let lastClickEventId = null;
  let lastClickTime = 0;
  let openedFromSessionLengthChange = false; // Track if opened due to session length change
  
  // Get session_length from userProfileData
  function getSessionLength() {
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const data = JSON.parse(dataEl.textContent);
        return data.session_length || 60;
      }
    } catch (e) {
      console.warn('Could not get session_length:', e);
    }
    return 60; // Default fallback
  }
  
  // Function to update timezone (call this when popup opens to get latest values)
  function updateTimezoneFromProfile() {
    mentorTimezone = resolveMentorTimezone();
    mentorTimezoneDisplay = getTimezoneDisplayName(mentorTimezone);
    sessionLength = getSessionLength();
    
    // Update calendar timezone if it exists
    if (calendar) {
      calendar.setOption('timeZone', mentorTimezone);
      calendar.render();
    }
  }
  
  // Compare current slots with original saved state to detect changes
  function hasUnsavedChanges() {
    // If we had slots originally but now have none, that's a change (deletion)
    if (originalSavedSlots.length > 0 && createdAvailabilitySlots.length === 0) {
      return true;
    }
    
    // If we have different number of slots, that's a change
    if (createdAvailabilitySlots.length !== originalSavedSlots.length) {
      return true;
    }
    
    // Create a map of original slots by ID for quick lookup
    const originalMap = new Map();
    originalSavedSlots.forEach(slot => {
      const key = `${slot.id}_${slot.start}_${slot.end}_${slot.length}_${slot.type || 'availability_slot'}`;
      originalMap.set(key, true);
    });
    
    // Check if all current slots exist in original state
    for (const slot of createdAvailabilitySlots) {
      const key = `${slot.id}_${slot.start}_${slot.end}_${slot.length}_${slot.type || 'availability_slot'}`;
      if (!originalMap.has(key)) {
        return true; // Found a slot that doesn't match original
      }
    }
    
    return false; // No changes detected
  }
  
  // Enable/disable Save button based on changes
  function updateSaveButton() {
    if (saveBtn) {
      const hasChanges = hasUnsavedChanges();
      // Enable button if there are changes (including deletions)
      // Don't disable just because slots.length === 0 - deletions are valid changes
      saveBtn.disabled = !hasChanges;
      // Reset button text if it was in "Saving..." state and we're not currently saving
      if (saveBtn.textContent === 'Saving...' && !saveBtn.disabled) {
        saveBtn.textContent = 'Save';
      }
    }
  }
  
  // Extract UTC offset from timezone display name (e.g., "Prague (UTC+1)" -> "UTC+1")
  function extractUTCOffset(displayName) {
    // Extract offset from format like "Prague (UTC+1)" or "UTC+1"
    const match = displayName.match(/UTC[+-]\d{1,2}(:\d{2})?/);
    if (match) {
      return match[0];
    }
    // Fallback: get current offset dynamically
    return getCurrentTimezoneOffset(mentorTimezone);
  }
  
  // Initialize session length
  sessionLength = getSessionLength();
  
  // Clock interval variable (kept for closeOverlay cleanup)
  let clockInterval = null;
  
  // Collision warning modal handlers
  const collisionModal = document.getElementById("collisionWarningModal");
  const collisionCloseTriggers = document.querySelectorAll("[data-close-collision-warning]");
  
  function openCollisionWarning() {
    if (!collisionModal) return;
    
    // Get all collisions
    const collisions = getAllCollisions();
    const collisionListEl = document.getElementById("collisionList");
    
    if (collisionListEl) {
      if (collisions.length === 0) {
        collisionListEl.innerHTML = '<p style="color: #64748b; margin: 0;">No collisions found.</p>';
      } else {
        collisionListEl.innerHTML = collisions.map((pair, index) => `
          <div class="collision-item">
            <span class="collision-number">${index + 1}.</span>
            <div class="collision-slots">
              <span class="collision-slot">${pair.slot1.time}</span>
              <span class="collision-vs">vs</span>
              <span class="collision-slot">${pair.slot2.time}</span>
            </div>
          </div>
        `).join('');
      }
    }
    
    collisionModal.classList.add("is-visible");
  }
  
  function closeCollisionWarning() {
    if (collisionModal) {
      collisionModal.classList.remove("is-visible");
    }
  }
  
  if (collisionCloseTriggers.length > 0) {
    collisionCloseTriggers.forEach(btn => {
      btn.addEventListener("click", closeCollisionWarning);
    });
  }
  
  // Close collision modal when clicking backdrop
  if (collisionModal) {
    collisionModal.addEventListener("click", function(e) {
      if (e.target === collisionModal || e.target.classList.contains("collision-warning-backdrop")) {
        closeCollisionWarning();
      }
    });
  }
  
  // Save button click handler
  if (saveBtn) {
    saveBtn.addEventListener('click', function() {
      if (saveBtn.disabled) return;
      
      // Allow saving even if no slots (deletion is a valid change)
      // Only check for collisions if there are slots
      if (createdAvailabilitySlots.length > 0 && hasAnyCollisions()) {
        // Show collision resolution popup instead of warning modal
        if (typeof window.openCollisionResolutionPopup === 'function') {
          window.openCollisionResolutionPopup(false); // false = not from session length change
        }
        return; // Prevent saving
      }
      
      // Prepare data for backend
      // Group slots by date and format them
      const slotsByDate = {};
      
      // Send UTC ISO strings directly - FullCalendar handles all timezone conversion
      // No need for selected_timezone - just use native calendar timezones
      createdAvailabilitySlots.forEach(slot => {
        // slot.start and slot.end are UTC ISO strings from FullCalendar
        // Extract date for grouping (YYYY-MM-DD)
        const dateStr = slot.start.split('T')[0];
        
        if (!slotsByDate[dateStr]) {
          slotsByDate[dateStr] = [];
        }
        
        // Get type from the calendar event if available
        const calendarEvent = calendar ? calendar.getEventById(slot.id) : null;
        const slotType = calendarEvent?.extendedProps?.type || slot.type || 'availability_slot';
        
        // Send UTC ISO strings directly - backend will parse and store as UTC
        slotsByDate[dateStr].push({
          date: dateStr,
          start_iso: slot.start, // UTC ISO string (e.g., "2024-12-12T05:00:00.000Z")
          end_iso: slot.end,     // UTC ISO string
          length: slot.length,
          id: slot.id,
          type: slotType
        });
      });
      
      // Include all dates that originally had slots (even if they're now empty after deletion)
      // This ensures deletions are properly handled by the backend
      originalDatesWithSlots.forEach(dateStr => {
        if (!slotsByDate[dateStr]) {
          slotsByDate[dateStr] = []; // Empty array for dates where all slots were deleted
        }
      });
      
      // Collect all slots from all dates into a single array
      const allAvailabilityData = [];
      const dates = Object.keys(slotsByDate);
      
      if (dates.length === 0) {
        if (typeof showNotification !== 'undefined') {
          showNotification('No valid date found.', 'error');
        }
        return;
      }
      
      // Flatten all slots from all dates into a single array
      dates.forEach(dateStr => {
        allAvailabilityData.push(...slotsByDate[dateStr]);
      });
      
      // Use the first date as the selected_date for backward compatibility
      // (backend will process all slots but use this date for filtering)
      const firstDate = dates[0];
      
      // Get CSRF token
      const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
      if (!csrfToken) {
        if (typeof showNotification !== 'undefined') {
          showNotification('CSRF token not found. Please refresh the page.', 'error');
        }
        return;
      }
      
      // Disable save button during request
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
      
      // Send to backend - send all slots, backend will handle them by date
      fetch('{% url "general:dashboard_mentor:save_availability" %}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({
          availability: allAvailabilityData,
          selected_date: firstDate,
          edited_dates: Array.from(originalDatesWithSlots) // Send all dates that originally had slots
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Reset button text
          saveBtn.textContent = 'Save';
          
          // Reload saved slots from backend to reflect the saved state
          loadSavedAvailabilitySlots().then(() => {
            // Show success notification (non-blocking)
            if (typeof showNotification !== 'undefined') {
              showNotification(data.message || 'Availability slots saved successfully!', 'success');
            }
          }).catch(error => {
            console.error('Error reloading slots after save:', error);
            // Show success notification even if reload fails
            if (typeof showNotification !== 'undefined') {
              showNotification(data.message || 'Availability slots saved successfully!', 'success');
            }
          });
        } else {
          // Show error notification
          if (typeof showNotification !== 'undefined') {
            showNotification(data.error || 'Failed to save availability slots.', 'error');
          }
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save';
        }
      })
      .catch(error => {
        console.error('Error saving availability:', error);
        // Show error notification
        if (typeof showNotification !== 'undefined') {
          showNotification('An error occurred while saving. Please try again.', 'error');
        }
        saveBtn.disabled = false;
        saveBtn.textContent = 'Save';
      });
    });
  }

  // Store availability slots as events
  let availabilityEvents = [];
  
  // Check if two time ranges overlap
  function slotsOverlap(start1, end1, start2, end2) {
    // Convert to timestamps for comparison
    const s1 = new Date(start1).getTime();
    const e1 = new Date(end1).getTime();
    const s2 = new Date(start2).getTime();
    const e2 = new Date(end2).getTime();
    
    // Two ranges overlap if: start1 < end2 AND start2 < end1
    return s1 < e2 && s2 < e1;
  }
  
  // Check if a slot collides with any existing slots
  function checkSlotCollisions(startDate, endDate, excludeSlotId = null) {
    const collisions = [];
    
    // Check against all existing availability events
    if (calendar) {
      const allEvents = calendar.getEvents();
      allEvents.forEach(event => {
        // Skip if it's not an availability slot or if it's the slot we're checking
        if (!event.extendedProps || !event.extendedProps.isAvailability) {
          return;
        }
        
        if (excludeSlotId && event.extendedProps.slotId === excludeSlotId) {
          return;
        }
        
        // Check for overlap
        if (slotsOverlap(startDate, endDate, event.start, event.end)) {
          collisions.push(event);
        }
      });
    }
    
    return collisions;
  }
  
  // Check if there are any collisions in all availability slots
  function hasAnyCollisions() {
    if (!calendar) return false;
    
    const allEvents = calendar.getEvents().filter(e => 
      e.extendedProps && e.extendedProps.isAvailability
    );
    
    // Check each slot for collisions
    for (let i = 0; i < allEvents.length; i++) {
      const event = allEvents[i];
      const collisions = checkSlotCollisions(event.start, event.end, event.extendedProps.slotId);
      if (collisions.length > 0) {
        return true;
      }
    }
    
    return false;
  }
  
  // Get all collision pairs for display (used by collision resolution popup)
  function getAllCollisionsForResolution() {
    if (!calendar) return [];
    
    const allEvents = calendar.getEvents().filter(e => 
      e.extendedProps && e.extendedProps.isAvailability
    );
    
    const collisionPairs = [];
    const processedPairs = new Set();
    
    for (let i = 0; i < allEvents.length; i++) {
      const event = allEvents[i];
      const collisions = checkSlotCollisions(event.start, event.end, event.extendedProps.slotId);
      
      collisions.forEach(collidingEvent => {
        // Create a unique pair ID to avoid duplicates
        const pairId1 = event.id + '_' + collidingEvent.id;
        const pairId2 = collidingEvent.id + '_' + event.id;
        
        if (!processedPairs.has(pairId1) && !processedPairs.has(pairId2)) {
          processedPairs.add(pairId1);
          processedPairs.add(pairId2);
          
          collisionPairs.push({
            slot1: { 
              id: event.extendedProps.slotId || event.id,
              start: event.start,
              end: event.end
            },
            slot2: { 
              id: collidingEvent.extendedProps.slotId || collidingEvent.id,
              start: collidingEvent.start,
              end: collidingEvent.end
            }
          });
        }
      });
    }
    
    return collisionPairs;
  }
  
  // Get all collision pairs for display (legacy function for old collision warning)
  function getAllCollisions() {
    if (!calendar) return [];
    
    const allEvents = calendar.getEvents().filter(e => 
      e.extendedProps && e.extendedProps.isAvailability
    );
    
    const collisionPairs = [];
    const processedPairs = new Set();
    
    for (let i = 0; i < allEvents.length; i++) {
      const event = allEvents[i];
      const collisions = checkSlotCollisions(event.start, event.end, event.extendedProps.slotId);
      
      collisions.forEach(collidingEvent => {
        // Create a unique pair ID to avoid duplicates
        const pairId1 = event.id + '_' + collidingEvent.id;
        const pairId2 = collidingEvent.id + '_' + event.id;
        
        if (!processedPairs.has(pairId1) && !processedPairs.has(pairId2)) {
          processedPairs.add(pairId1);
          processedPairs.add(pairId2);
          
          // Format times for display
          const start1 = formatEventTime(event.start);
          const end1 = formatEventTime(event.end);
          const start2 = formatEventTime(collidingEvent.start);
          const end2 = formatEventTime(collidingEvent.end);
          
          collisionPairs.push({
            slot1: { time: `${start1} - ${end1}` },
            slot2: { time: `${start2} - ${end2}` }
          });
        }
      });
    }
    
    return collisionPairs;
  }
  
  // Format event time for display
  function formatEventTime(dateStr) {
    const date = new Date(dateStr);
    const formatter = new Intl.DateTimeFormat('en-US', {
      timeZone: mentorTimezone,
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
    return formatter.format(date);
  }
  
  // Update slot colors based on collisions
  function updateSlotColors() {
    if (!calendar) return;
    
    const allEvents = calendar.getEvents();
    
    // Reset all availability slots to blue
    allEvents.forEach(event => {
      if (event.extendedProps && event.extendedProps.isAvailability) {
        event.setProp('backgroundColor', '#3b82f6');
        event.setProp('borderColor', '#2563eb');
      }
    });
    
    // Check each slot for collisions
    allEvents.forEach(event => {
      if (event.extendedProps && event.extendedProps.isAvailability) {
        const collisions = checkSlotCollisions(event.start, event.end, event.extendedProps.slotId);
        
        if (collisions.length > 0) {
          // This slot has collisions - make it red
          event.setProp('backgroundColor', '#ef4444');
          event.setProp('borderColor', '#dc2626');
          
          // Also make colliding slots red
          collisions.forEach(collidingEvent => {
            collidingEvent.setProp('backgroundColor', '#ef4444');
            collidingEvent.setProp('borderColor', '#dc2626');
          });
        }
      }
    });
  }
  
  // Create an availability slot event from a date/time
  function createAvailabilitySlotEvent(startDate, lengthMinutes) {
    const endDate = new Date(startDate.getTime() + lengthMinutes * 60 * 1000);
    
    // Generate unique ID for this slot
    const slotId = 'avail_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    
    // Check for collisions
    const collisions = checkSlotCollisions(startDate.toISOString(), endDate.toISOString());
    const hasCollision = collisions.length > 0;
    
    return {
      id: slotId,
      title: 'Available',
      start: startDate.toISOString(),
      end: endDate.toISOString(),
      backgroundColor: hasCollision ? '#ef4444' : '#3b82f6', // Red if collision, blue otherwise
      borderColor: hasCollision ? '#dc2626' : '#2563eb',
      classNames: ['availability-slot'],
      extendedProps: {
        isAvailability: true,
        length: lengthMinutes,
        slotId: slotId,
        type: 'availability_slot', // Mark as availability slot (fixed length)
        originalStart: startDate.toISOString(), // Store original start time to prevent movement
        originalEnd: endDate.toISOString() // Store original end time to prevent resizing
      }
    };
  }
  
  // Handle date/time slot click in availability mode
  function handleSlotClick(selectInfo) {
    if (!isAvailabilityMode) return;
    
    // Only allow in day and week views
    const currentView = calendar.view;
    if (currentView.type !== 'timeGridDay' && currentView.type !== 'timeGridWeek') {
      return;
    }
    
    const startDate = selectInfo.start;
    
    // Use fixed session_length from mentor profile (ignore selection duration)
    const lengthMinutes = sessionLength;
    
    // Create the slot event with fixed length
    const slotEvent = createAvailabilitySlotEvent(startDate, lengthMinutes);
    
    // Add to availability events
    availabilityEvents.push(slotEvent);
    
    // Add to created slots tracking (for saving)
    createdAvailabilitySlots.push({
      id: slotEvent.extendedProps.slotId,
      start: slotEvent.start,
      end: slotEvent.end,
      length: lengthMinutes,
      type: 'availability_slot' // Include type
    });
    
    // Add event to calendar
    calendar.addEvent(slotEvent);
    
    // Update colors to check for collisions
    updateSlotColors();
    
    // Enable Save button
    updateSaveButton();
    
    // Unselect the time slot
    calendar.unselect();
  }
  
  // Handle event drop (when dragging availability slots)
  function handleEventDrop(dropInfo) {
    // Show popup when dropping availability slots in Sessions mode
    if (!isAvailabilityMode) {
      const event = dropInfo.event;
      const isAvailabilitySlot = event.extendedProps?.isAvailability || event.extendedProps?.type === 'availability_slot';
      
      if (isAvailabilitySlot) {
        // Restore original position
        if (event.extendedProps?.originalStart && event.extendedProps?.originalEnd) {
          const originalStart = new Date(event.extendedProps.originalStart);
          const originalEnd = new Date(event.extendedProps.originalEnd);
          event.setStart(originalStart);
          event.setEnd(originalEnd);
        }
        dropInfo.revert(); // Revert the drop
        
        // Show popup explaining they need to switch to Availability mode
        openSwitchToAvailabilityModePopup();
        return;
      }
    }
    
    const event = dropInfo.event;
    
    // Only handle availability slots
    if (!event.extendedProps || !event.extendedProps.isAvailability) {
      return;
    }
    
    // Update the slot in our tracking array
    const slotId = event.extendedProps.slotId;
    const slotIndex = createdAvailabilitySlots.findIndex(s => s.id === slotId);
    
    if (slotIndex !== -1) {
      // Convert Date objects to ISO strings properly
      const newStart = event.start instanceof Date ? event.start.toISOString() : event.start;
      const newEnd = event.end instanceof Date ? event.end.toISOString() : event.end;
      
      // Update the slot with new start/end times
      createdAvailabilitySlots[slotIndex].start = newStart;
      createdAvailabilitySlots[slotIndex].end = newEnd;
      
      // Preserve type if it exists
      if (!createdAvailabilitySlots[slotIndex].type) {
        createdAvailabilitySlots[slotIndex].type = event.extendedProps?.type || 'availability_slot';
      }
      
      // Check for collisions and update colors
      updateSlotColors();
      
      // Enable Save button since we have changes
      updateSaveButton();
    } else {
      // Slot not found in tracking array - this shouldn't happen, but if it does,
      // we should still enable the save button as a safety measure
      console.warn('Slot moved but not found in tracking array:', slotId);
      updateSaveButton();
    }
  }
  
  // Handle event resize (when resizing availability slots)
  function handleEventResize(resizeInfo) {
    // Show popup when trying to resize in Sessions mode
    if (!isAvailabilityMode) {
      // Restore original size
      const event = resizeInfo.event;
      if (event.extendedProps?.originalStart && event.extendedProps?.originalEnd) {
        const originalStart = new Date(event.extendedProps.originalStart);
        const originalEnd = new Date(event.extendedProps.originalEnd);
        event.setStart(originalStart);
        event.setEnd(originalEnd);
      }
      resizeInfo.revert(); // Revert the resize
      openSwitchToAvailabilityModePopup(); // Show popup
      return;
    }
    
    const event = resizeInfo.event;
    
    // Only handle availability slots
    if (!event.extendedProps || !event.extendedProps.isAvailability) {
      return;
    }
    
    // Prevent resizing if this is an availability_slot (fixed length)
    const slotType = event.extendedProps.type || 'availability_slot';
    if (slotType === 'availability_slot') {
      // Get original start and end times from extendedProps (stored when event was created)
      // If not stored, initialize them from current event times (shouldn't happen, but safety check)
      if (!event.extendedProps.originalStart) {
        event.extendedProps.originalStart = event.start instanceof Date 
          ? event.start.toISOString() 
          : event.start;
      }
      if (!event.extendedProps.originalEnd) {
        event.extendedProps.originalEnd = event.end instanceof Date 
          ? event.end.toISOString() 
          : event.end;
      }
      
      const originalStart = event.extendedProps.originalStart;
      const originalEnd = event.extendedProps.originalEnd;
      
      // If original times are stored as ISO strings, parse them
      const originalStartDate = typeof originalStart === 'string' 
        ? new Date(originalStart) 
        : new Date(originalStart);
      const originalEndDate = typeof originalEnd === 'string' 
        ? new Date(originalEnd) 
        : new Date(originalEnd);
      
      // Restore both start and end times to prevent any movement or resizing
      // This prevents the slot from moving when resizing from the top edge
      event.setStart(originalStartDate);
      event.setEnd(originalEndDate);
      
      // Show a message to the user
      console.log('Availability slots have fixed length and cannot be resized or moved.');
      return;
    }
    
    // Allow resizing for session slots (type !== 'availability_slot')
    const slotId = event.extendedProps.slotId;
    const slotIndex = createdAvailabilitySlots.findIndex(s => s.id === slotId);
    
    if (slotIndex !== -1) {
      // Calculate new length
      const startDate = new Date(event.start);
      const endDate = new Date(event.end);
      const diffMs = endDate.getTime() - startDate.getTime();
      const lengthMinutes = Math.round(diffMs / (1000 * 60));
      
      createdAvailabilitySlots[slotIndex].start = event.start.toISOString();
      createdAvailabilitySlots[slotIndex].end = event.end.toISOString();
      createdAvailabilitySlots[slotIndex].length = lengthMinutes;
      
      // Update extended props
      event.setExtendedProp('length', lengthMinutes);
      
      // Check for collisions and update colors
      updateSlotColors();
      
      // Enable Save button since we have changes
      updateSaveButton();
    }
  }
  
  // Handle event removal (when deleting availability slots)
  function handleEventRemove(removeInfo) {
    if (!isAvailabilityMode) return;
    
    const event = removeInfo.event;
    
    // Only handle availability slots
    if (!event.extendedProps || !event.extendedProps.isAvailability) {
      return;
    }
    
    // Remove from tracking arrays
    const slotId = event.extendedProps.slotId;
    const slotIndex = createdAvailabilitySlots.findIndex(s => s.id === slotId);
    
    if (slotIndex !== -1) {
      createdAvailabilitySlots.splice(slotIndex, 1);
      
      // Also remove from availabilityEvents if it exists there
      const eventIndex = availabilityEvents.findIndex(e => e.id === event.id);
      if (eventIndex !== -1) {
        availabilityEvents.splice(eventIndex, 1);
      }
      
      // Update colors and save button
      updateSlotColors();
      updateSaveButton();
    }
  }

  // Handle delete slot button click (client-side only, deletion applied on save)
  function handleDeleteSlot(event) {
    if (!isAvailabilityMode) return;
    
    const slotId = event.extendedProps?.slotId || event.id;
    
    // Remove from calendar
    event.remove();
    
    // Remove from tracking arrays
    const slotIndex = createdAvailabilitySlots.findIndex(s => s.id === slotId);
    if (slotIndex !== -1) {
      createdAvailabilitySlots.splice(slotIndex, 1);
    }
    
    const eventIndex = availabilityEvents.findIndex(e => e.id === event.id);
    if (eventIndex !== -1) {
      availabilityEvents.splice(eventIndex, 1);
    }
    
    // Show notification reminder to save changes
    if (typeof showNotification !== 'undefined') {
      showNotification('Don\'t forget to save changes', 'note');
    }
    
    // Update colors and save button (this will enable save button if changes detected)
    updateSlotColors();
    updateSaveButton();
  }
  
  // Update slot in tracking array (called from slot settings popup)
  function updateSlotInTracking(fcEvent) {
    if (!fcEvent || !fcEvent.extendedProps) return;
    
    const slotId = fcEvent.extendedProps.slotId;
    const slotIndex = createdAvailabilitySlots.findIndex(s => s.id === slotId);
    
    if (slotIndex !== -1) {
      // Convert Date objects to ISO strings properly
      const newStart = fcEvent.start instanceof Date ? fcEvent.start.toISOString() : fcEvent.start;
      const newEnd = fcEvent.end instanceof Date ? fcEvent.end.toISOString() : fcEvent.end;
      
      // Update the slot with new start/end times
      createdAvailabilitySlots[slotIndex].start = newStart;
      createdAvailabilitySlots[slotIndex].end = newEnd;
      
      // Preserve type if it exists
      if (!createdAvailabilitySlots[slotIndex].type) {
        createdAvailabilitySlots[slotIndex].type = fcEvent.extendedProps?.type || 'availability_slot';
      }
      
      // Update length if needed
      const lengthMinutes = fcEvent.extendedProps?.length || 
        Math.round((new Date(newEnd).getTime() - new Date(newStart).getTime()) / (1000 * 60));
      createdAvailabilitySlots[slotIndex].length = lengthMinutes;
      
      // Check for collisions and update colors
      updateSlotColors();
      
      // Enable Save button since we have changes
      updateSaveButton();
    }
  }
  
  // Expose function globally for slot settings popup
  window.updateSlotInTracking = updateSlotInTracking;

  function scrollToAppropriateTime() {
    if (!calendar) return;
    
    const currentView = calendar.view;
    // Apply scrolling to both day and week views
    if (currentView.type !== 'timeGridDay' && currentView.type !== 'timeGridWeek') return;
    
    // Always scroll to 9am
    calendar.scrollToTime({ hours: 9, minutes: 0 });
    
    // Then adjust to center it in the viewport
    setTimeout(() => {
      const scrollContainer = calendarRoot.querySelector('.fc-scroller');
      if (!scrollContainer) return;
      
      // Find the time slot element for 9am
      const timeSlots = scrollContainer.querySelectorAll('.fc-timegrid-slot');
      if (timeSlots.length === 0) return;
      
      // 9am = 9 * 12 = slot 108 (each slot is 5 minutes, so 12 slots per hour)
      const slotIndex = 9 * 12;
      const targetSlot = timeSlots[slotIndex];
      
      if (targetSlot) {
        const containerRect = scrollContainer.getBoundingClientRect();
        const slotRect = targetSlot.getBoundingClientRect();
        const scrollTop = scrollContainer.scrollTop;
        
        // Calculate position relative to scroll container
        const slotTop = slotRect.top - containerRect.top + scrollTop;
        const viewportHeight = containerRect.height;
        
        // Center the slot in the viewport
        const targetScrollTop = slotTop - (viewportHeight / 2);
        
        scrollContainer.scrollTo({
          top: Math.max(0, targetScrollTop),
          behavior: 'smooth'
        });
      }
    }, 100);
  }

  function initCalendar() {
    // Debug: log the timezone being used
    console.log('Calendar timezone:', mentorTimezone);
    console.log('Current UTC time:', new Date().toISOString());
    
    // For nowIndicator to work correctly with timeZone, we need to provide
    // a function that returns the current time, and FullCalendar will interpret it
    // in the context of the specified timeZone
    // Using a function ensures it updates dynamically
    calendar = new FullCalendar.Calendar(calendarRoot, {
      timeZone: mentorTimezone,
      initialView: "timeGridWeek",
      height: "100%",
      nowIndicator: true,
      // Don't set 'now' explicitly - let FullCalendar use current time
      // It should automatically respect the timeZone setting
      slotMinTime: "00:00:00", // Start at midnight
      slotMaxTime: "24:00:00", // End at midnight (24 hours)
      slotDuration: "00:05:00", // 5-minute intervals for thin rows
      slotLabelInterval: "01:00:00", // Show labels every hour
      slotLabelContent: function(arg) {
        // Return hour number (0-23) - this matches the timezone correctly
        const hour = arg.date.getHours();
        const minutes = arg.date.getMinutes();
        // Only show if exactly on the hour
        if (minutes === 0 && hour >= 0 && hour <= 23) {
          return hour.toString();
        }
        return '';
      },
      headerToolbar: false,
      selectable: isAvailabilityMode, // Only allow selection in availability mode
      selectMirror: true,
      selectOverlap: false, // Prevent overlapping selections
      editable: function(info) {
        // Availability slots are NEVER editable in Sessions mode - they must be fixed like a rock
        const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
        if (isAvailabilitySlot && !isAvailabilityMode) {
          return false; // Completely prevent editing availability slots in Sessions mode
        }
        // Only allow editing if in availability mode
        if (!isAvailabilityMode) return false;
        // In availability mode, allow editing
        return true;
      },
      eventStartEditable: function(info) {
        // Allow dragging to start even in Sessions mode - we'll handle it on drop
        // This allows the user to attempt dragging, then we show popup and revert on drop
        const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
        if (isAvailabilitySlot) {
          return true; // Allow dragging to start - handle on drop
        }
        // Only allow dragging if in availability mode for non-availability slots
        if (!isAvailabilityMode) return false;
        return true;
      },
      eventDurationEditable: function(info) {
        // Availability slots are NEVER resizable in Sessions mode - they must be fixed like a rock
        const slotType = info.event.extendedProps?.type || 'availability_slot';
        const isAvailabilitySlot = info.event.extendedProps?.isAvailability || slotType === 'availability_slot';
        if (isAvailabilitySlot && !isAvailabilityMode) {
          return false; // Completely prevent resizing availability slots in Sessions mode
        }
        // Only allow resizing if it's not an availability_slot (fixed length) and in availability mode
        if (!isAvailabilityMode) return false;
        return slotType !== 'availability_slot'; // Allow resize only for non-availability slots
      },
      eventResizableFromStart: function(info) {
        // Availability slots are NEVER resizable from start in Sessions mode - they must be fixed like a rock
        const slotType = info.event.extendedProps?.type || 'availability_slot';
        const isAvailabilitySlot = info.event.extendedProps?.isAvailability || slotType === 'availability_slot';
        if (isAvailabilitySlot && !isAvailabilityMode) {
          return false; // Completely prevent resizing from start for availability slots in Sessions mode
        }
        // Only allow resizing from start if it's not an availability_slot (fixed length) and in availability mode
        if (!isAvailabilityMode) return false;
        return slotType !== 'availability_slot'; // Prevent resizing from start for availability slots
      },
      firstDay: 1, // Start week with Monday
      allDaySlot: false, // Remove all-day row from week and day views
      events: availabilityEvents,
      select: handleSlotClick, // Handle slot selection
      eventDragStart: function(dragInfo) {
        // Allow drag to start even in Sessions mode - we'll handle it on drop
        // This allows the user to attempt dragging, then we show popup on drop
      },
      eventDrop: handleEventDrop, // Handle event drag
      eventResize: handleEventResize, // Handle event resize
      eventRemove: handleEventRemove, // Handle event removal
      eventClick: function(clickInfo) {
        // Handle double-click on events using a timer-based approach for better compatibility
        if (!clickInfo.event.extendedProps?.isAvailability) return;
        
        // In Sessions mode, clicking availability slots opens scheduling popup
        if (!isAvailabilityMode) {
          openScheduleSessionPopup(clickInfo.event);
          return;
        }
        
        // In Availability mode, handle double-click for slot settings
        // Check if this is a double-click
        const now = Date.now();
        const eventId = clickInfo.event.id;
        const timeSinceLastClick = now - lastClickTime;
        
        if (lastClickEventId === eventId && timeSinceLastClick < 300 && timeSinceLastClick > 0) {
          // Double-click detected (same event, within 300ms)
          if (typeof window.openSlotSettings === 'function') {
            window.openSlotSettings(clickInfo, clickInfo.event);
          }
          // Reset the timer
          lastClickEventId = null;
          lastClickTime = 0;
        } else {
          // Single click - set timer for potential double-click
          lastClickEventId = eventId;
          lastClickTime = now;
        }
      },
      eventContent: function(arg) {
        // Custom content for availability slots
        if (arg.event.extendedProps?.isAvailability) {
          // Format start and end times with AM/PM in mentor's timezone
          const timeFormatter = new Intl.DateTimeFormat('en-US', {
            timeZone: mentorTimezone,
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
          });
          
          const startDate = new Date(arg.event.start);
          const endDate = new Date(arg.event.end);
          
          // Format times with AM/PM
          const startTime = timeFormatter.format(startDate);
          const endTime = timeFormatter.format(endDate);
          
          // Get duration from extendedProps or calculate from event times
          const lengthMinutes = arg.event.extendedProps?.length || 
            Math.round((arg.event.end - arg.event.start) / (1000 * 60));
          
          // Create wrapper container
          const wrapper = document.createElement('div');
          wrapper.className = 'availability-slot-content-wrapper';
          
          // Create delete button (top right corner) - only show in availability mode
          let deleteBtn = null;
          if (isAvailabilityMode) {
            deleteBtn = document.createElement('button');
            deleteBtn.className = 'availability-slot-delete-btn';
            deleteBtn.innerHTML = '√ó';
            deleteBtn.setAttribute('aria-label', 'Delete availability slot');
            deleteBtn.onclick = function(e) {
              e.stopPropagation();
              e.preventDefault();
              handleDeleteSlot(arg.event);
              return false;
            };
          }
          
          // Create content container
          const content = document.createElement('div');
          content.className = 'availability-slot-content';
          
          // Create time display
          const timeDisplay = document.createElement('div');
          timeDisplay.className = 'availability-slot-time';
          if (startTime && endTime) {
            timeDisplay.textContent = `${startTime} - ${endTime}`;
          } else if (startTime) {
            timeDisplay.textContent = startTime;
          } else {
            timeDisplay.textContent = 'Available';
          }
          
          // Create duration display
          const durationDisplay = document.createElement('div');
          durationDisplay.className = 'availability-slot-duration';
          durationDisplay.textContent = `${lengthMinutes} min`;
          
          // Assemble content
          content.appendChild(timeDisplay);
          content.appendChild(durationDisplay);
          
          // Assemble wrapper (delete button positioned absolutely in CSS, only if exists)
          if (deleteBtn) {
            wrapper.appendChild(deleteBtn);
          }
          wrapper.appendChild(content);
          
          return { domNodes: [wrapper] };
        }
        return { html: arg.event.title || '' };
      },
      dayHeaderDidMount: function(arg) {
        // Style day headers in week view to be clickable
        if (calendar.view.type === 'timeGridWeek') {
          arg.el.style.cursor = 'pointer';
          arg.el.setAttribute('title', 'Click to view this day');
          // Store the date as a data attribute for event delegation
          const dateStr = arg.date.toISOString();
          arg.el.setAttribute('data-header-date', dateStr);
          // Also set it on child elements that might be clicked
          const syncInner = arg.el.querySelector('.fc-scrollgrid-sync-inner');
          if (syncInner) {
            syncInner.setAttribute('data-header-date', dateStr);
            syncInner.style.cursor = 'pointer';
          }
          // Also set it on the cushion element (the text)
          const cushion = arg.el.querySelector('.fc-col-header-cell-cushion');
          if (cushion) {
            cushion.setAttribute('data-header-date', dateStr);
            cushion.style.cursor = 'pointer';
          }
        }
      },
      dayHeaderClick: function(arg) {
        console.log('dayHeaderClick called!', arg);
        console.log('Current view type:', calendar.view.type);
        console.log('Clicked date:', arg.date);
        console.log('Full arg object:', JSON.stringify({
          date: arg.date ? arg.date.toISOString() : null,
          view: arg.view ? arg.view.type : null,
          jsEvent: arg.jsEvent ? 'present' : null
        }, null, 2));
        
        // Native FullCalendar callback for day header clicks
        // Only handle clicks in week view
        if (calendar.view.type !== 'timeGridWeek') {
          console.log('Not in week view, returning');
          return;
        }
        
        // Don't handle clicks on interactive elements inside the header
        if (arg.jsEvent && arg.jsEvent.target.closest('button, a, input, select')) {
          console.log('Click was on interactive element, returning');
          return;
        }
        
        // Get the date from the clicked header
        const clickedDate = arg.date;
        console.log('Processing click for date:', clickedDate);
        
        // Switch to day view and navigate to that date
        calendar.changeView('timeGridDay');
        calendar.gotoDate(clickedDate);
        
        // Update the active view button
        const viewToggleButtons = document.querySelectorAll('.view-toggle-btn');
        viewToggleButtons.forEach(btn => {
          if (btn.dataset.calendarView === 'timeGridDay') {
            btn.classList.add('is-active');
          } else {
            btn.classList.remove('is-active');
          }
        });
        
        // Update date display and calendar size
        setTimeout(() => {
          calendar.updateSize();
          updateDateDisplay();
          markHourSlots();
        }, 100);
      },
      // Remove all-day slot from specific views
      views: {
        timeGridWeek: {
          allDaySlot: false,
          slotMinTime: "00:00:00",
          slotMaxTime: "24:00:00",
          slotDuration: "00:05:00",
          slotLabelInterval: "01:00:00",
          slotLabelContent: function(arg) {
            // Return hour number (0-23) - this matches the timezone correctly
            const hour = arg.date.getHours();
            const minutes = arg.date.getMinutes();
            // Only show if exactly on the hour
            if (minutes === 0 && hour >= 0 && hour <= 23) {
              return hour.toString();
            }
            return '';
          },
          slotLaneClassNames: function(arg) {
            const minutes = arg.date.getMinutes();
            if (minutes === 0) {
              return ['fc-hour-slot'];
            }
            return [];
          }
        },
        timeGridDay: {
          allDaySlot: false,
          slotMinTime: "00:00:00",
          slotMaxTime: "24:00:00",
          slotDuration: "00:05:00",
          slotLabelInterval: "01:00:00",
          slotLabelContent: function(arg) {
            // Return hour number (0-23) - this matches the timezone correctly
            const hour = arg.date.getHours();
            const minutes = arg.date.getMinutes();
            // Only show if exactly on the hour
            if (minutes === 0 && hour >= 0 && hour <= 23) {
              return hour.toString();
            }
            return '';
          },
          slotLaneClassNames: function(arg) {
            const minutes = arg.date.getMinutes();
            if (minutes === 0) {
              return ['fc-hour-slot'];
            }
            return [];
          },
          scrollTime: "09:00:00" // Default scroll position
        }
      }
    });

    calendar.render();

    // Event delegation for day header clicks in week view
    // Target fc-scrollgrid-sync-inner elements that users actually click
    if (calendarRoot) {
      calendarRoot.addEventListener('click', function(e) {
        // Only handle clicks in week view
        if (!calendar || calendar.view.type !== 'timeGridWeek') return;
        
        // Check if clicked element is the cushion anchor (the <a> tag with the text)
        // Check both the element itself and if it's inside a cushion
        const cushionElement = e.target.classList.contains('fc-col-header-cell-cushion') 
          ? e.target 
          : e.target.closest('.fc-col-header-cell-cushion');
        
        // Check if clicked element is inside a header cell
        const headerCell = e.target.closest('.fc-scrollgrid-sync-inner, .fc-col-header-cell');
        
        // Find the clicked header element (prioritize cushion if it exists)
        const clickedElement = cushionElement || headerCell;
        if (!clickedElement) return;
        
        // Don't handle clicks on other interactive elements (but allow cushion anchor)
        if (e.target.closest('button, input, select') && !cushionElement) return;
        
        // Prevent default anchor navigation if clicking on cushion
        if (cushionElement) {
          e.preventDefault();
        }
        
        console.log('Header clicked!', clickedElement, 'isCushion:', !!cushionElement, 'target:', e.target.tagName, e.target.className);
        
        // Try to get date from data attribute (set in dayHeaderDidMount)
        let clickedDate = null;
        const dateStr = clickedElement.getAttribute('data-header-date') || 
                       clickedElement.closest('[data-header-date]')?.getAttribute('data-header-date');
        
        if (dateStr) {
          clickedDate = new Date(dateStr);
          console.log('Date from data attribute:', clickedDate);
        } else {
          // Fallback: find the parent header cell and get its date
          const headerCell = clickedElement.closest('.fc-col-header-cell');
          if (headerCell) {
            // Get all header cells to find index
            const allHeaderCells = Array.from(calendarRoot.querySelectorAll('.fc-col-header-cell'));
            const clickedIndex = allHeaderCells.indexOf(headerCell);
            
            if (clickedIndex !== -1) {
              const view = calendar.view;
              const weekStart = new Date(view.activeStart);
              const timeAxis = calendarRoot.querySelector('.fc-timegrid-axis');
              const dateIndex = timeAxis ? clickedIndex - 1 : clickedIndex;
              
              if (dateIndex >= 0 && dateIndex <= 6) {
                clickedDate = new Date(weekStart);
                clickedDate.setDate(weekStart.getDate() + dateIndex);
                console.log('Date calculated from index:', clickedDate, 'index:', dateIndex);
              }
            }
          }
        }
        
        if (!clickedDate) {
          console.log('Could not determine clicked date');
          return;
        }
        
        console.log('Switching to day view for date:', clickedDate);
        
        e.preventDefault();
        e.stopPropagation();
        
        // Switch to day view and navigate to that date
        calendar.changeView('timeGridDay');
        calendar.gotoDate(clickedDate);
        
        // Update the active view button
        const viewToggleButtons = document.querySelectorAll('.view-toggle-btn');
        viewToggleButtons.forEach(btn => {
          if (btn.dataset.calendarView === 'timeGridDay') {
            btn.classList.add('is-active');
          } else {
            btn.classList.remove('is-active');
          }
        });
        
        // Update date display and calendar size
        setTimeout(() => {
          calendar.updateSize();
          updateDateDisplay();
          markHourSlots();
        }, 100);
      });
    }

    // Mark hour slots for CSS targeting - call multiple times to ensure they persist
    setTimeout(() => {
      markHourSlots();
      // Call again after a delay to ensure classes persist after any re-renders
      setTimeout(() => markHourSlots(), 200);
      setTimeout(() => markHourSlots(), 500);
    }, 100);

    // Listen to calendar's render events to re-mark slots after re-renders
    if (calendar && calendar.on) {
      calendar.on('viewDidMount', function() {
        setTimeout(() => markHourSlots(), 100);
        updateDateDisplay(); // Update date display when view mounts
      });
      
      // Also listen to datesSet event which fires when calendar navigates
      calendar.on('datesSet', function() {
        setTimeout(() => markHourSlots(), 100);
        updateDateDisplay(); // Update date display when dates change
      });
    }
    
    // Initial date display update
    setTimeout(() => updateDateDisplay(), 100);
    
    // Use MutationObserver to watch for DOM changes and re-apply borders
    const observer = new MutationObserver(function(mutations) {
      // Re-mark hour slots if the slots table changes
      const slotsTable = calendarRoot.querySelector('table.fc-timegrid-slots');
      if (slotsTable) {
        setTimeout(() => markHourSlots(), 50);
      }
    });
    
    // Observe the calendar root for changes
    if (calendarRoot) {
      observer.observe(calendarRoot, {
        childList: true,
        subtree: true
      });
    }

    setTimeout(() => {
      calendar.updateSize();
      // If initial view is day or week view, scroll appropriately
      if (calendar.view.type === 'timeGridDay' || calendar.view.type === 'timeGridWeek') {
        setTimeout(() => {
          scrollToAppropriateTime();
          markHourSlots(); // Re-mark after scrolling
        }, 100);
      }
    }, 50);
  }

  function markHourSlots() {
    if (!calendarRoot) return;
    
    // Mark slot 0 (midnight) and then every 12th slot (each hour)
    const slots = calendarRoot.querySelectorAll('table.fc-timegrid-slots tbody tr');
    if (slots.length === 0) return;
    
    slots.forEach((slot, index) => {
      // Slot 0 (index 0) and every 12th slot after that (index 12, 24, 36, etc.)
      const isHourSlot = (index === 0 || index % 12 === 0);
      
      if (isHourSlot) {
        slot.classList.add('fc-hour-slot');
        // Also mark children
        slot.querySelectorAll('td, .fc-timegrid-slot-lane').forEach(el => {
          el.classList.add('fc-hour-slot');
        });
      } else {
        slot.classList.remove('fc-hour-slot');
        slot.querySelectorAll('td, .fc-timegrid-slot-lane').forEach(el => {
          el.classList.remove('fc-hour-slot');
        });
      }
    });
  }

  // Load saved availability slots from backend
  async function loadSavedAvailabilitySlots() {
    try {
      const response = await fetch('{% url "general:dashboard_mentor:get_availability" %}');
      const data = await response.json();
      
      if (data.success && calendar) {
        // Clear existing availability events and tracking
        availabilityEvents = [];
        createdAvailabilitySlots = [];
        originalSavedSlots = []; // Reset original state
        originalDatesWithSlots.clear(); // Reset original dates
        
        // Load one-time slots
        // Note: Slots are stored in UTC (standard time) in the database
        // FullCalendar will automatically display them adjusted to mentorTimezone
        // because we set timeZone: mentorTimezone in the calendar configuration
        if (data.one_time_slots && Array.isArray(data.one_time_slots)) {
          data.one_time_slots.forEach(slot => {
            try {
              // Parse the slot dates (they're stored in UTC ISO format)
              // JavaScript Date will parse them correctly, and FullCalendar will
              // display them in the mentor's timezone automatically
              const startDate = new Date(slot.start);
              const endDate = new Date(slot.end);
              
              // Skip if dates are invalid
              if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                return;
              }
              
              // Calculate length if not provided
              const lengthMinutes = slot.length || Math.round((endDate.getTime() - startDate.getTime()) / (1000 * 60));
              
              // Use existing ID or generate one
              const slotId = slot.id || 'saved_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
              
              // Get type from saved slot or default to 'availability_slot'
              const slotType = slot.type || 'availability_slot';
              
              // Create calendar event
              // FullCalendar expects ISO strings in UTC, and will automatically convert
              // them to the calendar's timezone (mentorTimezone) for display
              // slot.start and slot.end are already in UTC ISO format from the backend
              const slotEvent = {
                id: slotId,
                title: 'Available',
                // Use the UTC ISO string directly - FullCalendar will handle timezone conversion
                start: slot.start, // Already in UTC ISO format
                end: slot.end, // Already in UTC ISO format
                backgroundColor: '#3b82f6',
                borderColor: '#2563eb',
                classNames: ['availability-slot'],
                extendedProps: {
                  isAvailability: true,
                  length: lengthMinutes,
                  slotId: slotId,
                  type: slotType, // Include type from saved slot
                  isSaved: true, // Mark as saved slot
                  originalStart: slot.start, // Store original start time to prevent movement
                  originalEnd: slot.end // Store original end time to prevent resizing
                }
              };
              
              availabilityEvents.push(slotEvent);
              
              // Track in createdAvailabilitySlots for collision detection and saving
              // Use the UTC ISO strings directly (same as slotEvent.start/end)
              const slotData = {
                id: slotId,
                start: slot.start, // UTC ISO string from backend
                end: slot.end, // UTC ISO string from backend
                length: lengthMinutes,
                type: slotType // Include type
              };
              
              createdAvailabilitySlots.push(slotData);
              
              // Store in originalSavedSlots for change detection (deep copy)
              // Use UTC ISO strings directly to match what we track in createdAvailabilitySlots
              originalSavedSlots.push({
                id: slotId,
                start: slot.start, // UTC ISO string from backend
                end: slot.end, // UTC ISO string from backend
                length: lengthMinutes,
                type: slotType
              });
              
              // Track the date this slot is on (for deletion handling)
              const dateStr = slot.start.split('T')[0]; // Extract YYYY-MM-DD
              originalDatesWithSlots.add(dateStr);
              
              // Only add to calendar if we're in availability mode
              // Events are stored in availabilityEvents array and will be shown/hidden based on toggle
              if (isAvailabilityMode) {
                calendar.addEvent(slotEvent);
              }
            } catch (e) {
              console.warn('Error loading slot:', e);
            }
          });
        }
        
        // After loading, update calendar display based on current mode
        updateCalendarEventsForMode();
        
        // Check for collisions and update colors (only if in availability mode)
        if (isAvailabilityMode) {
          updateSlotColors();
        }
        updateSaveButton(); // This will disable the button since state matches original
      }
    } catch (error) {
      console.error('Error loading availability slots:', error);
      throw error; // Re-throw so caller can handle it
    }
  }
  
  function openOverlay() {
    overlay.classList.add("is-visible");
    overlay.setAttribute('aria-hidden', 'false'); // Fix accessibility issue
    
    // Re-read timezone and session_length from profile when opening (in case it was updated)
    updateTimezoneFromProfile();
    
    // Reset availability mode when opening
    isAvailabilityMode = false;
    if (toggleBtn) {
      toggleBtn.classList.remove("active");
    }

    if (!calendar) {
      initCalendar();
      // Load saved slots after calendar is initialized
      setTimeout(() => {
        loadSavedAvailabilitySlots().then(() => {
          // Ensure calendar shows correct events based on mode
          updateCalendarEventsForMode();
          
          // If opened from session length change, check for collisions after slots load
          if (openedFromSessionLengthChange) {
            setTimeout(() => {
              updateSlotColors();
              if (hasAnyCollisions() && typeof window.openCollisionResolutionPopup === 'function') {
                window.openCollisionResolutionPopup(true);
              }
            }, 500);
          }
        });
      }, 100);
    } else {
      // Update calendar timezone in case it changed
      calendar.setOption('timeZone', mentorTimezone);
      calendar.setOption('selectable', isAvailabilityMode);
      calendar.setOption('editable', function(info) {
        // Availability slots are NEVER editable in Sessions mode - they must be fixed like a rock
        const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
        if (isAvailabilitySlot && !isAvailabilityMode) {
          return false; // Completely prevent editing availability slots in Sessions mode
        }
        // Only allow editing if in availability mode
        if (!isAvailabilityMode) return false;
        return true;
      });
      calendar.setOption('eventStartEditable', function(info) {
        // Availability slots are NEVER draggable in Sessions mode - they must be fixed like a rock
        const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
        if (isAvailabilitySlot && !isAvailabilityMode) {
          return false; // Completely prevent dragging availability slots in Sessions mode
        }
        // Only allow dragging if in availability mode
        if (!isAvailabilityMode) return false;
        return true;
      });
      calendar.setOption('eventDurationEditable', function(info) {
        // Availability slots are NEVER resizable in Sessions mode - they must be fixed like a rock
        const slotType = info.event.extendedProps?.type || 'availability_slot';
        const isAvailabilitySlot = info.event.extendedProps?.isAvailability || slotType === 'availability_slot';
        if (isAvailabilitySlot && !isAvailabilityMode) {
          return false; // Completely prevent resizing availability slots in Sessions mode
        }
        if (!isAvailabilityMode) return false;
        return slotType !== 'availability_slot';
      });
      
      // Load saved slots (they'll be filtered by mode inside loadSavedAvailabilitySlots)
      loadSavedAvailabilitySlots().then(() => {
        // Ensure calendar shows correct events based on mode
        updateCalendarEventsForMode();
        
        calendar.render();
        setTimeout(() => {
          calendar.updateSize();
          markHourSlots();
          updateDateDisplay(); // Update date display when opening overlay
          // If current view is day or week view, scroll appropriately
          if (calendar.view.type === 'timeGridDay' || calendar.view.type === 'timeGridWeek') {
            setTimeout(() => scrollToAppropriateTime(), 150);
          }
          
          // If opened from session length change, check for collisions after slots load
          if (openedFromSessionLengthChange) {
            setTimeout(() => {
              updateSlotColors();
              if (hasAnyCollisions() && typeof window.openCollisionResolutionPopup === 'function') {
                window.openCollisionResolutionPopup(true);
              }
            }, 500);
          }
        }, 50);
      });
    }
  }

  function closeOverlay() {
    // If opened from session length change and collisions exist, prevent closing
    if (openedFromSessionLengthChange && hasAnyCollisions()) {
      // Show collision resolution popup
      if (typeof window.openCollisionResolutionPopup === 'function') {
        window.openCollisionResolutionPopup(true); // true = from session length change
      }
      return; // Prevent closing
    }
    
    overlay.classList.remove("is-visible");
    overlay.setAttribute('aria-hidden', 'true'); // Fix accessibility issue
    openedFromSessionLengthChange = false; // Reset flag
    // Stop clock when overlay closes
    if (clockInterval) {
      clearInterval(clockInterval);
      clockInterval = null;
    }
  }
  
  // Expose closeOverlay globally
  window.closeCalendarOverlay = closeOverlay;
  
  // Expose openOverlay globally
  window.openOverlay = openOverlay;
  
  // Expose openedFromSessionLengthChange setter/getter globally
  window.setOpenedFromSessionLengthChange = function(value) {
    openedFromSessionLengthChange = value;
  };
  window.getOpenedFromSessionLengthChange = function() {
    return openedFromSessionLengthChange;
  };

  openTriggers.forEach(btn => btn.addEventListener("click", openOverlay));
  closeTriggers.forEach(btn => btn.addEventListener("click", closeOverlay));
  
  // Auto-open calendar if requested (e.g., after session length change with collisions)
  // Check URL parameter
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get('open_calendar') === 'true') {
    // Mark as opened from session length change
    openedFromSessionLengthChange = true;
    
    // Switch to availability mode and open calendar
    setTimeout(() => {
      // Switch to availability mode first
      if (toggleBtn) {
        toggleBtn.classList.add("active");
        isAvailabilityMode = true;
      }
      // Open the overlay
      openOverlay();
      // After opening, ensure availability mode is active
      // Note: Collision check will happen in openOverlay() after slots are loaded
      setTimeout(() => {
        if (calendar && isAvailabilityMode) {
          // Update calendar options for availability mode
          calendar.setOption('selectable', true);
          calendar.setOption('editable', function(info) {
            // Availability slots are NEVER editable in Sessions mode - they must be fixed like a rock
            const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
            if (isAvailabilitySlot && !isAvailabilityMode) {
              return false; // Completely prevent editing availability slots in Sessions mode
            }
            return true; // Allow editing in availability mode
          });
          calendar.setOption('eventStartEditable', function(info) {
            // Allow dragging to start even in Sessions mode - we'll handle it on drop
            const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
            if (isAvailabilitySlot) {
              return true; // Allow dragging to start - handle on drop
            }
            return true; // Allow dragging in availability mode
          });
          calendar.setOption('eventDurationEditable', function(info) {
            // Availability slots are NEVER resizable in Sessions mode - they must be fixed like a rock
            const slotType = info.event.extendedProps?.type || 'availability_slot';
            const isAvailabilitySlot = info.event.extendedProps?.isAvailability || slotType === 'availability_slot';
            if (isAvailabilitySlot && !isAvailabilityMode) {
              return false; // Completely prevent resizing availability slots in Sessions mode
            }
            return slotType !== 'availability_slot';
          });
          // Update events
          updateCalendarEventsForMode();
          updateSlotColors(); // This will highlight collisions
          
          // Explicitly check for collisions and open popup if needed (for page reload scenario)
          setTimeout(() => {
            if (hasAnyCollisions() && typeof window.openCollisionResolutionPopup === 'function') {
              window.openCollisionResolutionPopup(true); // true = from session length change
            }
          }, 1000); // Give slots time to fully load and colors to update
        }
      }, 500);
      // Remove the parameter from URL without reloading
      urlParams.delete('open_calendar');
      const newUrl = window.location.pathname + (urlParams.toString() ? '?' + urlParams.toString() : '');
      window.history.replaceState({}, '', newUrl);
    }, 300); // Small delay to ensure page is loaded
  }
  

  // Function to update calendar events based on current mode
  function updateCalendarEventsForMode() {
    if (!calendar) return;
    
    // Remove all events first
    calendar.removeAllEvents();
    
    // Always show availability slots, but style them differently based on mode
    availabilityEvents.forEach(event => {
      // Clone the event to avoid modifying the original
      const eventToAdd = { ...event };
      
      if (!isAvailabilityMode) {
        // Sessions mode - make availability slots transparent and non-editable
        // Add a CSS class to mark them as read-only
        const originalClassNames = event.classNames || [];
        eventToAdd.classNames = [...originalClassNames, 'availability-slot-readonly'];
        // Make them visually transparent
        eventToAdd.backgroundColor = 'rgba(59, 130, 246, 0.2)'; // Very transparent blue
        eventToAdd.borderColor = 'rgba(37, 99, 235, 0.3)';
        eventToAdd.textColor = '#64748b'; // Muted text color
      } else {
        // Availability mode - use original styling (remove readonly class if it exists)
        const originalClassNames = event.classNames || [];
        eventToAdd.classNames = originalClassNames.filter(cn => cn !== 'availability-slot-readonly');
        // Restore original colors if they exist
        if (event.backgroundColor) eventToAdd.backgroundColor = event.backgroundColor;
        if (event.borderColor) eventToAdd.borderColor = event.borderColor;
        if (event.textColor) eventToAdd.textColor = event.textColor;
      }
      
      calendar.addEvent(eventToAdd);
    });
    
    // TODO: Load and show actual sessions here when sessions are implemented
    
    calendar.render();
  }
  
  // Toggle button functionality (Sessions / Availability)
  const toggleBtn = document.getElementById("availabilityCalendarToggle");
  if (toggleBtn) {
    // Default to "Sessions" mode (not active = sessions, active = availability)
    toggleBtn.addEventListener("click", async function() {
      toggleBtn.classList.toggle("active");
      isAvailabilityMode = toggleBtn.classList.contains("active");
      
      console.log("Toggle mode:", isAvailabilityMode ? "Availability" : "Sessions");
      
      // Refetch data when toggling modes to reset changes and disable save button
      if (calendar) {
        try {
          // Refetch saved availability slots - this will reset originalSavedSlots and originalDatesWithSlots
          await loadSavedAvailabilitySlots();
          
          // Update calendar based on mode
          // Enable/disable selection and editing based on mode
          calendar.setOption('selectable', isAvailabilityMode);
          calendar.setOption('editable', function(info) {
            // Availability slots are NEVER editable in Sessions mode - they must be fixed like a rock
            const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
            if (isAvailabilitySlot && !isAvailabilityMode) {
              return false; // Completely prevent editing availability slots in Sessions mode
            }
            // Only allow editing if in availability mode
            if (!isAvailabilityMode) return false;
            return true;
          });
          calendar.setOption('eventStartEditable', function(info) {
            // Allow dragging to start even in Sessions mode - we'll handle it on drop
            const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
            if (isAvailabilitySlot) {
              return true; // Allow dragging to start - handle on drop
            }
            // Only allow dragging if in availability mode for non-availability slots
            if (!isAvailabilityMode) return false;
            return true;
          });
          // Set eventDurationEditable as a function to check slot type
          calendar.setOption('eventDurationEditable', function(info) {
            // Availability slots are NEVER resizable in Sessions mode - they must be fixed like a rock
            const slotType = info.event.extendedProps?.type || 'availability_slot';
            const isAvailabilitySlot = info.event.extendedProps?.isAvailability || slotType === 'availability_slot';
            if (isAvailabilitySlot && !isAvailabilityMode) {
              return false; // Completely prevent resizing availability slots in Sessions mode
            }
            if (!isAvailabilityMode) return false;
            return slotType !== 'availability_slot'; // Allow resize only for non-availability slots
          });
          
          // Set eventResizableFromStart to prevent resizing from start edge
          calendar.setOption('eventResizableFromStart', function(info) {
            // Availability slots are NEVER resizable from start in Sessions mode - they must be fixed like a rock
            const slotType = info.event.extendedProps?.type || 'availability_slot';
            const isAvailabilitySlot = info.event.extendedProps?.isAvailability || slotType === 'availability_slot';
            if (isAvailabilitySlot && !isAvailabilityMode) {
              return false; // Completely prevent resizing from start for availability slots in Sessions mode
            }
            if (!isAvailabilityMode) return false;
            return slotType !== 'availability_slot'; // Prevent resizing from start for availability slots
          });
          
          // Set eventDragStart to prevent dragging from starting
          calendar.setOption('eventDragStart', function(dragInfo) {
            // Allow drag to start even in Sessions mode - we'll handle it on drop
            // This allows the user to attempt dragging, then we show popup on drop
          });
          
          // Update events based on mode (this will apply transparency styling)
          updateCalendarEventsForMode();
          
          // Update colors if in availability mode
          if (isAvailabilityMode) {
            updateSlotColors();
          }
          
          // Update save button state (should be disabled after refetch)
          updateSaveButton();
        } catch (error) {
          console.error('Error refetching availability slots on mode toggle:', error);
        }
      }
    });
  }

  // Calendar navigation (prev/next/today)
  const navBtns = overlay.querySelectorAll("[data-calendar-nav]");
  navBtns.forEach(btn => {
    btn.addEventListener("click", function() {
      if (!calendar) return;
      
      const action = this.dataset.calendarNav;
      if (action === "prev") {
        calendar.prev();
      } else if (action === "next") {
        calendar.next();
      } else if (action === "today") {
        calendar.today();
      }
      
      setTimeout(() => {
        calendar.updateSize();
        updateDateDisplay(); // Update date display after navigation
      }, 50);
    });
  });

  // Close when clicking outside the modal (on backdrop/overlay)
  overlay.addEventListener("click", function(e) {
    // Only close if clicking directly on the overlay or backdrop, not on the modal content
    if (e.target === overlay || e.target.classList.contains("availability-calendar-backdrop")) {
      // If opened from session length change and collisions exist, show collision popup instead
      if (openedFromSessionLengthChange && hasAnyCollisions()) {
        if (typeof window.openCollisionResolutionPopup === 'function') {
          window.openCollisionResolutionPopup(true);
        }
        return; // Prevent closing
      }
      closeOverlay();
    }
  });

  // Prevent clicks inside the modal from closing it
  const modal = overlay.querySelector(".availability-calendar-modal");
  if (modal) {
    modal.addEventListener("click", function(e) {
      e.stopPropagation();
    });
  }

  document.addEventListener("keydown", e => {
    if (e.key === "Escape") {
      // Check if any nested popups are open and close them first (in order of priority)
      
      // 1. Check collision resolution popup (highest priority)
      const collisionResolutionPopup = document.getElementById('collisionResolutionPopup');
      if (collisionResolutionPopup && collisionResolutionPopup.getAttribute('aria-hidden') === 'false') {
        if (typeof window.closeCollisionResolutionPopup === 'function') {
          window.closeCollisionResolutionPopup();
        }
        e.preventDefault();
        e.stopPropagation();
        return; // Don't close calendar popup
      }
      
      // 2. Check slot settings popup
      const slotSettingsPopup = document.getElementById('slotSettingsPopup');
      if (slotSettingsPopup && slotSettingsPopup.getAttribute('aria-hidden') === 'false') {
        if (typeof window.closeSlotSettings === 'function') {
          window.closeSlotSettings();
        }
        e.preventDefault();
        e.stopPropagation();
        return; // Don't close calendar popup
      }
      
      // 3. Check schedule session popup
      const scheduleSessionPopup = document.getElementById('scheduleSessionPopup');
      if (scheduleSessionPopup && scheduleSessionPopup.getAttribute('aria-hidden') === 'false') {
        closeScheduleSessionPopup();
        e.preventDefault();
        e.stopPropagation();
        return; // Don't close calendar popup
      }
      
      // 4. Check switch mode popup
      const switchModePopup = document.getElementById('switchToAvailabilityModePopup');
      if (switchModePopup && switchModePopup.getAttribute('aria-hidden') === 'false') {
        closeSwitchToAvailabilityModePopup();
        e.preventDefault();
        e.stopPropagation();
        return; // Don't close calendar popup
      }
      
      // 5. Check collision warning modal
      const collisionWarningModal = document.getElementById('collisionWarningModal');
      if (collisionWarningModal && collisionWarningModal.getAttribute('aria-hidden') === 'false') {
        closeCollisionWarning();
        e.preventDefault();
        e.stopPropagation();
        return; // Don't close calendar popup
      }
      
      // If opened from session length change and collisions exist, show collision popup instead
      if (openedFromSessionLengthChange && hasAnyCollisions()) {
        if (typeof window.openCollisionResolutionPopup === 'function') {
          window.openCollisionResolutionPopup(true);
        }
        return; // Prevent closing
      }
      
      // Only close calendar popup if no nested popups are open
      closeOverlay();
    }
  });

  viewBtnEls.forEach(btn => {
    btn.addEventListener("click", function() {
      const targetView = this.dataset.calendarView;

      viewBtnEls.forEach(b => b.classList.toggle("is-active", b === this));

      if (calendar) {
        calendar.changeView(targetView);

        setTimeout(() => {
          calendar.updateSize();
          calendar.render();
          markHourSlots();
          updateDateDisplay(); // Update date display when view changes
          
          // If switching to day or week view, scroll to appropriate time
          if (targetView === "timeGridDay" || targetView === "timeGridWeek") {
            setTimeout(() => scrollToAppropriateTime(), 150);
          }
        }, 50);
      }
    });
  });

  // Expose functions for collision resolution popup
  window.getCalendarCollisions = getAllCollisionsForResolution;
  
  // Navigate to collision in calendar
  window.navigateToCollisionInCalendar = function(slot1Id, slot2Id) {
    if (!calendar) return;
    
    // Ensure availability mode is on
    if (!isAvailabilityMode) {
      isAvailabilityMode = true;
      if (toggleBtn) {
        toggleBtn.classList.add("active");
      }
      
      // Update calendar options for availability mode
      calendar.setOption('selectable', true);
      calendar.setOption('editable', function(info) {
        // Availability slots are NEVER editable in Sessions mode - they must be fixed like a rock
        const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
        if (isAvailabilitySlot && !isAvailabilityMode) {
          return false; // Completely prevent editing availability slots in Sessions mode
        }
        return true; // Allow editing in availability mode
      });
      calendar.setOption('eventStartEditable', function(info) {
        // Allow dragging to start even in Sessions mode - we'll handle it on drop
        const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
        if (isAvailabilitySlot) {
          return true; // Allow dragging to start - handle on drop
        }
        return true; // Allow dragging in availability mode
      });
      calendar.setOption('eventDurationEditable', function(info) {
        // Availability slots are NEVER resizable in Sessions mode - they must be fixed like a rock
        const slotType = info.event.extendedProps?.type || 'availability_slot';
        const isAvailabilitySlot = info.event.extendedProps?.isAvailability || slotType === 'availability_slot';
        if (isAvailabilitySlot && !isAvailabilityMode) {
          return false; // Completely prevent resizing availability slots in Sessions mode
        }
        return slotType !== 'availability_slot';
      });
      
      // Update events to show availability slots properly
      updateCalendarEventsForMode();
    }
    
    // Find the events by slotId (check both id and extendedProps.slotId)
    const allEvents = calendar.getEvents();
    let event1 = null;
    let event2 = null;
    
    for (const event of allEvents) {
      if (!event.extendedProps || !event.extendedProps.isAvailability) continue;
      
      const eventSlotId = event.extendedProps.slotId || event.id;
      if (eventSlotId === slot1Id) {
        event1 = event;
      }
      if (eventSlotId === slot2Id) {
        event2 = event;
      }
    }
    
    if (!event1 && !event2) return;
    
    // Use the first available event
    const targetEvent = event1 || event2;
    const targetDate = new Date(targetEvent.start);
    
    // Switch to day view
    calendar.changeView('timeGridDay');
    
    // Update view toggle buttons to show Day as active
    const viewToggleButtons = document.querySelectorAll('.view-toggle-btn');
    viewToggleButtons.forEach(btn => {
      if (btn.dataset.calendarView === 'timeGridDay') {
        btn.classList.add('is-active');
      } else {
        btn.classList.remove('is-active');
      }
    });
    
    // Navigate to the date
    calendar.gotoDate(targetDate);
    
    // Update date display
    setTimeout(() => {
      calendar.updateSize();
      updateDateDisplay();
    }, 50);
    
    // Scroll to the time
    setTimeout(() => {
      const hours = targetDate.getHours();
      const minutes = targetDate.getMinutes();
      calendar.scrollToTime({ hours: hours, minutes: minutes });
      
      // Highlight the events briefly
      if (event1) {
        event1.setProp('backgroundColor', '#fbbf24');
        setTimeout(() => {
          updateSlotColors(); // Restore collision colors
        }, 2000);
      }
      if (event2) {
        event2.setProp('backgroundColor', '#fbbf24');
        setTimeout(() => {
          updateSlotColors(); // Restore collision colors
        }, 2000);
      }
    }, 300);
  };
  
  // Delete slots by IDs
  window.deleteSlotsByIds = async function(slotIds) {
    if (!calendar) return;
    
    const allEvents = calendar.getEvents();
    
    slotIds.forEach(slotId => {
      // Find event by slotId (check both id and extendedProps.slotId)
      let eventToRemove = null;
      for (const event of allEvents) {
        if (!event.extendedProps || !event.extendedProps.isAvailability) continue;
        const eventSlotId = event.extendedProps.slotId || event.id;
        if (eventSlotId === slotId) {
          eventToRemove = event;
          break;
        }
      }
      
      if (eventToRemove) {
        eventToRemove.remove();
      }
      
      // Remove from tracking arrays
      const slotIndex = createdAvailabilitySlots.findIndex(s => s.id === slotId);
      if (slotIndex !== -1) {
        createdAvailabilitySlots.splice(slotIndex, 1);
      }
      
      const eventIndex = availabilityEvents.findIndex(e => {
        const eventSlotId = (e.extendedProps && e.extendedProps.slotId) || e.id;
        return eventSlotId === slotId;
      });
      if (eventIndex !== -1) {
        availabilityEvents.splice(eventIndex, 1);
      }
    });
    
    // Update colors and save button
    updateSlotColors();
    updateSaveButton();
  };
  
  // Save calendar changes
  window.saveCalendarChanges = async function() {
    if (!saveBtn || saveBtn.disabled) return;
    
    // Trigger save button click
    saveBtn.click();
    
    // Wait for save to complete (poll for button to be disabled again)
    return new Promise((resolve) => {
      const checkInterval = setInterval(() => {
        if (saveBtn.disabled && saveBtn.textContent === 'Save') {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
      
      // Timeout after 5 seconds
      setTimeout(() => {
        clearInterval(checkInterval);
        resolve();
      }, 5000);
    });
  };

  // Schedule Session Popup Functions
  function openScheduleSessionPopup(event) {
    const popup = document.getElementById('scheduleSessionPopup');
    const slotInfoEl = document.getElementById('scheduleSessionSlotInfo');
    const emailInput = document.getElementById('scheduleSessionEmail');
    
    if (!popup || !slotInfoEl || !emailInput) return;
    
    // Format the slot time information
    const startDate = new Date(event.start);
    const endDate = new Date(event.end);
    
    // Format date and time
    const dateFormatter = new Intl.DateTimeFormat('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
    
    const timeFormatter = new Intl.DateTimeFormat('en-US', {
      timeZone: mentorTimezone,
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });
    
    const dateStr = dateFormatter.format(startDate);
    const startTime = timeFormatter.format(startDate);
    const endTime = timeFormatter.format(endDate);
    const duration = Math.round((endDate - startDate) / (1000 * 60));
    
    // Display slot information
    slotInfoEl.innerHTML = `
      <div class="schedule-session-date">${dateStr}</div>
      <div class="schedule-session-time">${startTime} - ${endTime}</div>
      <div class="schedule-session-duration">Duration: ${duration} minutes</div>
    `;
    
    // Clear email input
    emailInput.value = '';
    
    // Store event data for submission
    emailInput.dataset.eventId = event.id;
    emailInput.dataset.startTime = event.start.toISOString();
    emailInput.dataset.endTime = event.end.toISOString();
    
    // Show popup
    popup.setAttribute('aria-hidden', 'false');
    popup.style.display = 'flex';
    
    // Focus email input
    setTimeout(() => {
      emailInput.focus();
    }, 100);
  }
  
  function closeScheduleSessionPopup() {
    const popup = document.getElementById('scheduleSessionPopup');
    if (popup) {
      popup.setAttribute('aria-hidden', 'true');
      popup.style.display = 'none';
    }
  }
  
  // Event listeners for schedule session popup
  const scheduleSessionCloseTriggers = document.querySelectorAll('[data-close-schedule-session]');
  scheduleSessionCloseTriggers.forEach(btn => {
    btn.addEventListener('click', closeScheduleSessionPopup);
  });
  
  // Handle form submission
  const scheduleSessionSubmitBtn = document.getElementById('scheduleSessionSubmitBtn');
  const scheduleSessionEmailInput = document.getElementById('scheduleSessionEmail');
  
  if (scheduleSessionSubmitBtn && scheduleSessionEmailInput) {
    scheduleSessionSubmitBtn.addEventListener('click', function() {
      const email = scheduleSessionEmailInput.value.trim();
      
      if (!email) {
        alert('Please enter a client email address');
        return;
      }
      
      // Basic email validation
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        alert('Please enter a valid email address');
        return;
      }
      
      // Get event data
      const eventId = scheduleSessionEmailInput.dataset.eventId;
      const startTime = scheduleSessionEmailInput.dataset.startTime;
      const endTime = scheduleSessionEmailInput.dataset.endTime;
      
      // TODO: Implement actual session scheduling logic here
      // For now, just show a success message
      console.log('Schedule session:', {
        email: email,
        startTime: startTime,
        endTime: endTime,
        eventId: eventId
      });
      
      // Show success notification
      if (typeof showNotification === 'function') {
        showNotification('Session scheduled successfully!', 'success');
      } else {
        alert('Session scheduled successfully!');
      }
      
      // Close popup
      closeScheduleSessionPopup();
    });
    
    // Allow Enter key to submit
    scheduleSessionEmailInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        scheduleSessionSubmitBtn.click();
      }
    });
  }
  
  // Close popup when clicking backdrop
  const scheduleSessionBackdrop = document.querySelector('.schedule-session-backdrop');
  if (scheduleSessionBackdrop) {
    scheduleSessionBackdrop.addEventListener('click', closeScheduleSessionPopup);
  }

  // Switch to Availability Mode Popup Functions
  function openSwitchToAvailabilityModePopup() {
    const popup = document.getElementById('switchToAvailabilityModePopup');
    if (popup) {
      popup.setAttribute('aria-hidden', 'false');
      popup.style.display = 'flex';
    }
  }
  
  function closeSwitchToAvailabilityModePopup() {
    const popup = document.getElementById('switchToAvailabilityModePopup');
    if (popup) {
      popup.setAttribute('aria-hidden', 'true');
      popup.style.display = 'none';
    }
  }
  
  // Event listeners for switch mode popup
  const switchModeCloseTriggers = document.querySelectorAll('[data-close-switch-mode]');
  switchModeCloseTriggers.forEach(btn => {
    btn.addEventListener('click', closeSwitchToAvailabilityModePopup);
  });
  
  // Handle switch button click
  const switchToAvailabilityModeBtn = document.getElementById('switchToAvailabilityModeBtn');
  if (switchToAvailabilityModeBtn) {
    switchToAvailabilityModeBtn.addEventListener('click', function() {
      // Close the popup
      closeSwitchToAvailabilityModePopup();
      
      // Switch to availability mode
      if (toggleBtn) {
        toggleBtn.classList.add('active');
        isAvailabilityMode = true;
        
        // Update calendar options for availability mode
        if (calendar) {
          calendar.setOption('selectable', true);
          calendar.setOption('editable', function(info) {
            const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
            if (isAvailabilitySlot && !isAvailabilityMode) {
              return false;
            }
            if (!isAvailabilityMode) return false;
            return true;
          });
          calendar.setOption('eventStartEditable', function(info) {
            const isAvailabilitySlot = info.event.extendedProps?.isAvailability || info.event.extendedProps?.type === 'availability_slot';
            if (isAvailabilitySlot && !isAvailabilityMode) {
              return false;
            }
            if (!isAvailabilityMode) return false;
            return true;
          });
          calendar.setOption('eventDurationEditable', function(info) {
            const slotType = info.event.extendedProps?.type || 'availability_slot';
            const isAvailabilitySlot = info.event.extendedProps?.isAvailability || slotType === 'availability_slot';
            if (isAvailabilitySlot && !isAvailabilityMode) {
              return false;
            }
            if (!isAvailabilityMode) return false;
            return slotType !== 'availability_slot';
          });
          calendar.setOption('eventResizableFromStart', function(info) {
            const slotType = info.event.extendedProps?.type || 'availability_slot';
            const isAvailabilitySlot = info.event.extendedProps?.isAvailability || slotType === 'availability_slot';
            if (isAvailabilitySlot && !isAvailabilityMode) {
              return false;
            }
            if (!isAvailabilityMode) return false;
            return slotType !== 'availability_slot';
          });
          calendar.setOption('eventDragStart', function(dragInfo) {
            const isAvailabilitySlot = dragInfo.event.extendedProps?.isAvailability || dragInfo.event.extendedProps?.type === 'availability_slot';
            if (isAvailabilitySlot && !isAvailabilityMode) {
              dragInfo.jsEvent.preventDefault();
              dragInfo.jsEvent.stopPropagation();
              openSwitchToAvailabilityModePopup();
              return false;
            }
          });
          
          // Update events to show availability slots properly
          updateCalendarEventsForMode();
          
          // Update colors
          updateSlotColors();
        }
      }
    });
  }
  
  // Close popup when clicking backdrop
  const switchModeBackdrop = document.querySelector('.switch-mode-backdrop');
  if (switchModeBackdrop) {
    switchModeBackdrop.addEventListener('click', closeSwitchToAvailabilityModePopup);
  }

})();
</script>

