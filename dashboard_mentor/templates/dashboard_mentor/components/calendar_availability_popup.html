{% load static %}

<!-- ===================== AVAILABILITY CALENDAR MODAL ===================== -->
<div id="availabilityCalendarOverlay" class="availability-calendar-overlay" aria-hidden="true">
  <div class="availability-calendar-backdrop" data-close-availability-calendar></div>

  <div class="availability-calendar-modal">
    <header class="availability-calendar-header">
      <div class="availability-calendar-title-group">
        <h2>Manage Sessions & Availability</h2>
        <p class="availability-calendar-subtitle">
          <span class="timezone-label">Your Timezone</span>
          <span class="timezone-value" id="timezoneDisplayValue">UTC+01</span>
          <span class="timezone-time" id="timezoneTimeDisplay">--:--:--</span>
          <a href="{% url 'general:dashboard_mentor:profile' %}#timezone-section" class="timezone-change-link">Change</a>
        </p>
      </div>

      <div class="availability-calendar-toggle-group">
        <button class="availability-calendar-toggle-btn" id="availabilityCalendarToggle" aria-label="Toggle view">
          <span class="toggle-label">Sessions</span>
          <span class="toggle-switch">
            <span class="toggle-slider"></span>
          </span>
          <span class="toggle-label">Availability</span>
        </button>
      </div>

      <div class="availability-calendar-nav">
        <button class="calendar-nav-btn" data-calendar-nav="prev" aria-label="Previous">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <div class="calendar-date-display" id="calendarDateDisplay">Loading...</div>
        <button class="calendar-nav-btn" data-calendar-nav="next" aria-label="Next">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>

      <div class="availability-calendar-header-actions">
        <button class="calendar-nav-btn" data-calendar-nav="today" aria-label="Today">Today</button>
        <div class="availability-calendar-view-toggle">
          <button class="view-toggle-btn" data-calendar-view="timeGridDay">Day</button>
          <button class="view-toggle-btn is-active" data-calendar-view="timeGridWeek">Week</button>
          <button class="view-toggle-btn" data-calendar-view="dayGridMonth">Month</button>
        </div>
        <button class="availability-calendar-save-btn" id="availabilityCalendarSaveBtn" disabled>Save</button>
        <button class="availability-calendar-close-btn" data-close-availability-calendar>✕</button>
      </div>
    </header>

    <section class="availability-calendar-body">
      <div id="mentorAvailabilityCalendar" class="availability-calendar-root"></div>
    </section>
  </div>
</div>

<!-- Collision Warning Modal -->
<div id="collisionWarningModal" class="collision-warning-overlay" aria-hidden="true">
  <div class="collision-warning-backdrop" data-close-collision-warning></div>
  <div class="collision-warning-modal">
    <div class="collision-warning-header">
      <h3>⚠️ Collision Detected</h3>
      <button class="collision-warning-close" data-close-collision-warning>✕</button>
    </div>
    <div class="collision-warning-body">
      <p>You have overlapping availability slots. Please resolve the conflicts before saving.</p>
      <div id="collisionList" class="collision-list">
        <!-- Collisions will be listed here -->
      </div>
    </div>
    <div class="collision-warning-footer">
      <button class="collision-warning-btn-ok" data-close-collision-warning>OK</button>
    </div>
  </div>
</div>


<!-- ===================== FullCalendar v6 CSS ===================== -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.css">

<!-- ===================== FullCalendar v6 JS (core + plugins) ===================== -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/locales-all.global.min.js"></script>

<!-- ===================== CSS ===================== -->
<style>
/* Overlay */
.availability-calendar-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(15, 23, 42, 0.6);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  z-index: 2000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}
.availability-calendar-overlay.is-visible { 
  opacity: 1;
  visibility: visible;
}

/* Modal */
.availability-calendar-modal {
  background: #ffffff;
  width: 95%;
  max-width: 1400px;
  height: 90vh;
  border-radius: 24px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 
    0 25px 50px -12px rgba(0, 0, 0, 0.25),
    0 0 0 1px rgba(0, 0, 0, 0.05); /* Subtle border ring */
  transform: translateY(20px);
  transition: transform 0.3s ease, opacity 0.3s ease;
  opacity: 0;
}

.availability-calendar-overlay.is-visible .availability-calendar-modal {
  transform: translateY(0);
  opacity: 1;
}

/* Header */
.availability-calendar-header {
  padding: 20px 32px;
  background: #ffffff;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 24px;
}

.availability-calendar-title-group {
  flex: 1;
  min-width: 0;
}

.availability-calendar-title-group h2 {
  margin: 0;
  font-size: 1.5rem;
  font-weight: 700;
  color: #0f172a;
  letter-spacing: -0.025em;
  line-height: 1.2;
}

.availability-calendar-title-group .availability-calendar-subtitle {
  margin: 4px 0 0 0;
  font-size: 0.875rem;
  color: #64748b;
  font-weight: 400;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.availability-calendar-subtitle .timezone-label {
  font-weight: 500;
}

.availability-calendar-subtitle .timezone-value {
  font-weight: 500;
}

.availability-calendar-subtitle .timezone-time {
  font-weight: 600;
  font-variant-numeric: tabular-nums;
  color: #334155;
  font-family: 'Courier New', monospace;
}

.availability-calendar-subtitle .timezone-change-link {
  color: var(--dash-primary, #3b82f6);
  text-decoration: none;
  font-weight: 500;
  margin-left: 4px;
  transition: color 0.2s ease;
}

.availability-calendar-subtitle .timezone-change-link:hover {
  color: #2563eb;
  text-decoration: underline;
}

/* Toggle Group */
.availability-calendar-toggle-group {
  display: flex;
  align-items: center;
}

.availability-calendar-toggle-btn {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 16px;
  background: #f0fdf4;
  border: 1px solid #10b981;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 0.875rem;
  font-weight: 500;
  color: #64748b;
}

.availability-calendar-toggle-btn:hover {
  background: #dcfce7;
  border-color: #059669;
}

.availability-calendar-toggle-btn .toggle-label {
  transition: color 0.2s ease;
  white-space: nowrap;
  font-weight: 600; /* Always bold */
}

.availability-calendar-toggle-btn .toggle-switch {
  position: relative;
  width: 44px;
  height: 24px;
  background: #10b981;
  border-radius: 12px;
  transition: background 0.2s ease;
}

.availability-calendar-toggle-btn.active .toggle-switch {
  background:  #3b82f6;
}

.availability-calendar-toggle-btn.active {
  background: #eff6ff; /* Light blue background */
  border-color: #3b82f6;
}

.availability-calendar-toggle-btn .toggle-slider {
  position: absolute;
  top: 2px;
  left: 2px;
  width: 20px;
  height: 20px;
  background: white;
  border-radius: 50%;
  transition: transform 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.availability-calendar-toggle-btn .toggle-slider::before {
  content: none;
}

.availability-calendar-toggle-btn.active .toggle-slider {
  transform: translateX(20px);
}

/* Sessions mode (not active) - Green */
.availability-calendar-toggle-btn:not(.active) .toggle-label:first-child {
  color: #10b981;
  font-weight: 600; /* Always bold */
}

.availability-calendar-toggle-btn:not(.active) .toggle-label:last-child {
  color: #64748b;
  font-weight: 600; /* Always bold */
}

/* Availability mode (active) - Blue */
.availability-calendar-toggle-btn.active .toggle-label:first-child {
  color: #64748b; /* Gray for Sessions label */
  font-weight: 600; /* Always bold */
}

.availability-calendar-toggle-btn.active .toggle-label:last-child {
  color: #3b82f6; /* Blue text for Availability label */
  font-weight: 600; /* Always bold */
}

/* Navigation Group */
.availability-calendar-nav {
  display: flex;
  min-width: 280px;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  background: #f8fafc;
  padding: 4px;
  border-radius: 12px;
  border: 1px solid #e2e8f0;
}

.calendar-nav-btn {
  border: none;
  background: transparent;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  cursor: pointer;
  color: #64748b;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.calendar-nav-btn:hover {
  background: #ffffff;
  color: #0f172a;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.calendar-date-display {
  padding: 0 16px;
  font-size: 0.925rem;
  font-weight: 600;
  color: #334155;
  white-space: nowrap;
  min-width: 140px;
  text-align: center;
  font-variant-numeric: tabular-nums;
}

/* Header Actions */
.availability-calendar-header-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}

/* Today Button */
.calendar-nav-btn[data-calendar-nav="today"] {
  width: auto;
  padding: 8px 20px;
  background: #f1f5f9;
  color: #475569;
  font-weight: 600;
  font-size: 0.875rem;
  height: 36px;
  border-radius: 10px;
}

.calendar-nav-btn[data-calendar-nav="today"]:hover {
  background: #e2e8f0;
  color: #1e293b;
}

/* View Toggle (Segmented Control) */
.availability-calendar-view-toggle {
  min-width: 240px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: #f1f5f9;
  border-radius: 10px;
  padding: 4px;
  gap: 0;
  border: 1px solid #e2e8f0;
}

.view-toggle-btn {
  padding: 6px 16px;
  border: none;
  cursor: pointer;
  border-radius: 8px;
  background: transparent;
  color: #64748b;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.2s ease;
  position: relative;
}

.view-toggle-btn:hover:not(.is-active) {
  color: #334155;
}

.view-toggle-btn.is-active {
  background: #3b82f6;
  color: #ffffff;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  font-weight: 600;
}

/* Save Button */
.availability-calendar-save-btn {
  border: none;
  background: #cbd5e1;
  color: #64748b;
  padding: 8px 20px;
  border-radius: 10px;
  cursor: not-allowed;
  font-size: 0.875rem;
  font-weight: 600;
  transition: all 0.2s ease;
  margin-left: 8px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Disabled state - just grey, no hover effects */
.availability-calendar-save-btn:disabled {
  background: #cbd5e1 !important;
  color: #64748b !important;
  cursor: not-allowed !important;
}

.availability-calendar-save-btn:disabled:hover {
  background: #cbd5e1 !important; /* Stay grey on hover when disabled */
  color: #64748b !important;
}

/* Enabled state - green with darker green hover and white text */
.availability-calendar-save-btn:not(:disabled) {
  background: #10b981 !important; /* Green background when enabled */
  color: #ffffff !important;
  cursor: pointer !important;
}

.availability-calendar-save-btn:not(:disabled):hover {
  background: #059669 !important; /* Darker green on hover */
  color: #ffffff !important;
}

/* Close Button */
.availability-calendar-close-btn {
  border: none;
  background: transparent;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  color: #94a3b8;
  font-size: 1.25rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  margin-left: 8px;
}

.availability-calendar-close-btn:hover {
  background: #fee2e2;
  color: #ef4444;
  transform: rotate(90deg);
}

/* Body */
.availability-calendar-body {
  flex: 1;
  min-height: 0;
  display: flex;
  padding: 0; /* Remove padding for flush look */
  background: #f8fafc; /* Slight contrast for calendar area */
  position: relative;
}

.availability-calendar-root {
  flex: 1;
  min-height: 420px;
  border: none;
  background: #ffffff;
}

/* --- FullCalendar Overrides --- */

/* General Text */
.availability-calendar-root {
  font-family: inherit;
  --fc-border-color: #cbd5e1; /* Stronger, balanced border color */
  --fc-page-bg-color: #ffffff;
  --fc-neutral-bg-color: #f8fafc;
  --fc-today-bg-color: #f0fdf4;
  --fc-now-indicator-color: #ef4444;
}

/* Headers */
.fc-theme-standard th {
  border: 1px solid var(--fc-border-color); /* Restore native borders */
  background: #f8fafc;
}

.fc-col-header-cell-cushion {
  color: #64748b;
  font-weight: 600;
  font-size: 0.875rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 8px 0;
}

/* Time Labels */
.fc-timegrid-axis-cushion,
.fc-timegrid-slot-label-cushion {
  color: #64748b; /* Slightly darker for readability */
  font-size: 0.75rem;
  font-weight: 500;
}

/* Slots */
.availability-calendar-root .fc-timegrid-slot {
  height: 20px; 
}

/* Ensure Month View borders are visible and match */
.fc-theme-standard td, 
.fc-theme-standard .fc-scrollgrid {
  border-color: var(--fc-border-color);
}

/* Hour slots styling (targeted by JS adding .fc-hour-slot) */
.availability-calendar-root .fc-hour-slot {
  border-top-color: var(--fc-border-color) !important;
}

/* Events */
.fc-event {
  border: none;
  border-radius: 4px;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  font-size: 0.8rem;
  font-weight: 500;
  padding: 2px;
}

.fc-v-event {
  background-color: #d1fae5;
  border-left: 3px solid #10b981;
  color: #065f46;
}

.fc-event-main {
  color: inherit;
  padding: 2px 4px;
}

/* Now Indicator */
.fc-timegrid-now-indicator-line {
  border-color: #ef4444;
  border-width: 2px;
}
.fc-timegrid-now-indicator-arrow {
  border-color: #ef4444;
  border-width: 6px;
}

/* Scrollbar */
.fc-scroller::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
.fc-scroller::-webkit-scrollbar-track {
  background: transparent;
}
.fc-scroller::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 4px;
}
.fc-scroller::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Header */
.availability-calendar-header {
  padding: 12px 18px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 16px;
}

.availability-calendar-title-group {
  flex: 1;
  min-width: 0;
}

.availability-calendar-title-group h2 {
  margin: 0;
  font-size: 1.125rem;
  font-weight: 600;
  color: #1e293b;
  line-height: 1.3;
}

.availability-calendar-title-group .availability-calendar-subtitle {
  margin: 2px 0 0 0;
  font-size: 0.75rem;
  color: #64748b;
  line-height: 1.2;
}

.availability-calendar-nav {
  display: flex;
  align-items: center;
  gap: 4px;
}

.calendar-nav-btn {
  border: none;
  background: #f1f5f9;
  padding: 6px 10px;
  border-radius: 6px;
  cursor: pointer;
  color: #64748b;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 32px;
  height: 32px;
}

.calendar-nav-btn:hover {
  background: #e2e8f0;
  color: #1e293b;
}

.calendar-nav-btn svg {
  display: block;
}

.calendar-date-display {
  padding: 6px 16px;
  font-size: 0.875rem;
  font-weight: 600;
  color: #1e293b;
  white-space: nowrap;
  min-width: 120px;
  text-align: center;
}

.availability-calendar-header-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

.availability-calendar-body {
  flex: 1;
  min-height: 0;
  display: flex;
  padding: 10px;
}

.availability-calendar-root {
  flex: 1;
  min-height: 420px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid #e5e7eb;
}

/* View Toggle Buttons - grouped in a row */
.availability-calendar-view-toggle {
  display: inline-flex;
  align-items: center;
  background: #f1f5f9;
  border-radius: 8px;
  padding: 2px;
  gap: 0;
  border: 1px solid #e2e8f0;
}

.view-toggle-btn {
  padding: 6px 12px;
  border: none;
  cursor: pointer;
  border-radius: 6px;
  background: transparent;
  color: #64748b;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.15s ease;
}

.view-toggle-btn:hover:not(.is-active) {
  background: #e2e8f0;
  color: #1e293b;
}

.view-toggle-btn.is-active {
  background: #3b82f6;
  color: #fff;
}

/* Save Button - mobile */
.availability-calendar-save-btn {
  border: none;
  background: #cbd5e1;
  color: #64748b;
  padding: 8px 20px;
  border-radius: 10px;
  cursor: not-allowed;
  font-size: 0.875rem;
  font-weight: 600;
  transition: all 0.2s ease;
  margin-left: 8px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Disabled state - just grey, no hover effects */
.availability-calendar-save-btn:disabled {
  background: #cbd5e1 !important;
  color: #64748b !important;
  cursor: not-allowed !important;
}

.availability-calendar-save-btn:disabled:hover {
  background: #cbd5e1 !important; /* Stay grey on hover when disabled */
  color: #64748b !important;
}

/* Enabled state - green with darker green hover and white text */
.availability-calendar-save-btn:not(:disabled) {
  background: #10b981 !important; /* Green background when enabled */
  color: #ffffff !important;
  cursor: pointer !important;
}

.availability-calendar-save-btn:not(:disabled):hover {
  background: #059669 !important; /* Darker green on hover */
  color: #ffffff !important;
}

/* Close Button - separate */
.availability-calendar-close-btn {
  border: none;
  background: #f1f5f9;
  padding: 8px 12px;
  border-radius: 8px;
  cursor: pointer;
  color: #64748b;
  font-size: 1.125rem;
  line-height: 1;
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
}

.availability-calendar-close-btn:hover {
  background: #e2e8f0;
  color: #ef4444;
}

/* Make time slot rows thinner - target all possible elements */
.availability-calendar-root .fc-timegrid-slot,
.availability-calendar-root .fc-timegrid-slot table,
.availability-calendar-root .fc-timegrid-slot tr,
.availability-calendar-root .fc-timegrid-slot td,
.availability-calendar-root .fc-timegrid-slot-lane,
.availability-calendar-root .fc-timegrid-slot-lane table,
.availability-calendar-root .fc-timegrid-slot-lane tr,
.availability-calendar-root .fc-timegrid-slot-lane td {
  height: 3px !important;
  min-height: 3px !important;
  max-height: 3px !important;
  line-height: 3px !important;
}

/* Target the table rows directly */
.availability-calendar-root table.fc-timegrid-slots tr {
  height: 3px !important;
  min-height: 3px !important;
  max-height: 3px !important;
}

.availability-calendar-root table.fc-timegrid-slots tr td {
  height: 3px !important;
  min-height: 3px !important;
  max-height: 3px !important;
  padding: 0 !important;
  line-height: 3px !important;
}

/* Hide horizontal borders for 5-min slots, but PRESERVE vertical borders */
.availability-calendar-root .fc-timegrid-slot {
  border-top: none !important;
  border-bottom: none !important;
}

/* Only show borders on hour slots (slot 0 and every 12th slot) */
.availability-calendar-root .fc-hour-slot {
  border-top: 1px solid var(--fc-border-color) !important;
}

/* Ensure Month View borders are strong */
.availability-calendar-root .fc-daygrid-day-frame {
  border: 0px solid var(--fc-border-color);
}

/* Style hour labels */
.availability-calendar-root .fc-timegrid-slot-label {
  font-size: 0.75rem;
  padding: 2px 8px;
}

/* Make slot labels show hour ranges */
.availability-calendar-root .fc-timegrid-slot-label-cushion {
  font-weight: 500;
}

/* Collision Warning Modal */
.collision-warning-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(15, 23, 42, 0.6);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
  z-index: 3000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s ease, visibility 0.2s ease;
}

.collision-warning-overlay.is-visible {
  opacity: 1;
  visibility: visible;
}

.collision-warning-backdrop {
  position: absolute;
  inset: 0;
}

.collision-warning-modal {
  position: relative;
  background: #ffffff;
  width: 90%;
  max-width: 500px;
  border-radius: 16px;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  transform: translateY(10px);
  transition: transform 0.2s ease, opacity 0.2s ease;
  opacity: 0;
}

.collision-warning-overlay.is-visible .collision-warning-modal {
  transform: translateY(0);
  opacity: 1;
}

.collision-warning-header {
  padding: 20px 24px;
  border-bottom: 1px solid #e5e7eb;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.collision-warning-header h3 {
  margin: 0;
  font-size: 1.25rem;
  font-weight: 700;
  color: #dc2626;
}

.collision-warning-close {
  border: none;
  background: transparent;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  cursor: pointer;
  color: #94a3b8;
  font-size: 1.125rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.collision-warning-close:hover {
  background: #fee2e2;
  color: #dc2626;
}

.collision-warning-body {
  padding: 24px;
}

.collision-warning-body > p {
  margin: 0 0 16px 0;
  color: #64748b;
  font-size: 0.95rem;
  line-height: 1.5;
}

.collision-list {
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 12px;
  background: #f8fafc;
}

.collision-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 0;
  border-bottom: 1px solid #e5e7eb;
}

.collision-item:last-child {
  border-bottom: none;
}

.collision-number {
  font-weight: 600;
  color: #64748b;
  min-width: 24px;
}

.collision-slots {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
}

.collision-slot {
  padding: 4px 12px;
  background: #fee2e2;
  border: 1px solid #fecaca;
  border-radius: 6px;
  color: #991b1b;
  font-weight: 500;
  font-size: 0.875rem;
  font-family: 'Courier New', monospace;
}

.collision-vs {
  color: #64748b;
  font-weight: 600;
  font-size: 0.875rem;
}

.collision-warning-footer {
  padding: 16px 24px;
  border-top: 1px solid #e5e7eb;
  display: flex;
  justify-content: flex-end;
}

.collision-warning-btn-ok {
  padding: 8px 20px;
  background: #3b82f6;
  color: #ffffff;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.875rem;
  transition: background 0.2s ease;
}

.collision-warning-btn-ok:hover {
  background: #2563eb;
}
</style>

<!-- ===================== JS ===================== -->
<script>
(function() {
  const overlay = document.getElementById("availabilityCalendarOverlay");
  const calendarRoot = document.getElementById("mentorAvailabilityCalendar");
  const openTriggers = document.querySelectorAll("[data-open-availability-calendar]");
  const closeTriggers = document.querySelectorAll("[data-close-availability-calendar]");
  const viewBtnEls = document.querySelectorAll("[data-calendar-view]");
  const subtitleEl = document.querySelector(".availability-calendar-subtitle");
  const timezoneValueEl = document.getElementById("timezoneDisplayValue");
  const timezoneTimeEl = document.getElementById("timezoneTimeDisplay");
  const dateDisplayEl = document.getElementById("calendarDateDisplay");

  // Format date display based on current view type
  function updateDateDisplay() {
    if (!calendar || !dateDisplayEl) return;
    
    const view = calendar.view;
    const start = view.activeStart;
    const end = view.activeEnd;
    
    let displayText = '';
    
    if (view.type === 'timeGridDay') {
      // Day view: show specific date (e.g., "January 15, 2024")
      const dateFormatter = new Intl.DateTimeFormat('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      displayText = dateFormatter.format(start);
    } else if (view.type === 'timeGridWeek') {
      // Week view: show date range (e.g., "Jan 15 - Jan 21, 2024")
      const startFormatter = new Intl.DateTimeFormat('en-US', {
        month: 'short',
        day: 'numeric'
      });
      const endFormatter = new Intl.DateTimeFormat('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
      const startStr = startFormatter.format(start);
      const endStr = endFormatter.format(new Date(end.getTime() - 1)); // Subtract 1ms to get last day
      displayText = startStr + ' - ' + endStr;
    } else if (view.type === 'dayGridMonth') {
      // Month view: show month name and year (e.g., "January 2024")
      // Calculate the month from the middle of the view range to avoid boundary issues
      // This handles cases where activeStart might be at the end of previous month
      const midDate = new Date((start.getTime() + end.getTime()) / 2);
      // Get the first day of the month that midDate falls into
      const monthStart = new Date(midDate.getFullYear(), midDate.getMonth(), 1);
      const monthFormatter = new Intl.DateTimeFormat('en-US', {
        year: 'numeric',
        month: 'long'
      });
      displayText = monthFormatter.format(monthStart);
    }
    
    dateDisplayEl.textContent = displayText;
  }

  // Get current UTC offset for a timezone (handles DST automatically)
  // Uses JavaScript's native timezone support - IANA timezones already handle DST
  function getCurrentTimezoneOffset(ianaId) {
    try {
      const now = new Date();
      
      // Use Intl.DateTimeFormat to get the timezone offset
      // This automatically handles DST based on the current date
      const formatter = new Intl.DateTimeFormat('en', {
        timeZone: ianaId,
        timeZoneName: 'longOffset'
      });
      
      const parts = formatter.formatToParts(now);
      const offsetPart = parts.find(p => p.type === 'timeZoneName');
      
      if (offsetPart && offsetPart.value) {
        // offsetPart.value will be like "GMT+1", "GMT+02:00", "GMT+1:00", etc.
        // Extract the offset part
        const offsetMatch = offsetPart.value.match(/GMT([+-])(\d{1,2})(:?(\d{2}))?/);
        if (offsetMatch) {
          const sign = offsetMatch[1];
          const hours = parseInt(offsetMatch[2]) || 0;
          const minutes = offsetMatch[4] ? parseInt(offsetMatch[4]) : 0;
          
          if (minutes === 0) {
            return 'UTC' + sign + String(hours).padStart(2, '0');
          } else {
            return 'UTC' + sign + String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0');
          }
        }
      }
      
      // Fallback: Calculate offset by comparing what time it is in UTC vs the timezone
      // Format the same moment in both timezones and compare
      const utcTimeStr = now.toLocaleString('sv-SE', { timeZone: 'UTC' }); // ISO-like format
      const tzTimeStr = now.toLocaleString('sv-SE', { timeZone: ianaId });
      
      // Parse both (format: "YYYY-MM-DD HH:mm:ss")
      const utcDate = new Date(utcTimeStr.replace(' ', 'T') + 'Z');
      const tzDate = new Date(tzTimeStr.replace(' ', 'T') + 'Z');
      
      // The difference tells us the offset
      const diffMs = tzDate.getTime() - utcDate.getTime();
      const diffHours = diffMs / (1000 * 60 * 60);
      
      const sign = diffHours >= 0 ? '+' : '-';
      const absHours = Math.abs(diffHours);
      const hours = Math.floor(absHours);
      const minutes = Math.round((absHours - hours) * 60);
      
      if (minutes === 0) {
        return 'UTC' + sign + String(hours).padStart(2, '0');
      } else {
        return 'UTC' + sign + String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0');
      }
    } catch (e) {
      console.warn('Could not get timezone offset for', ianaId, ':', e);
      return 'UTC+0';
    }
  }

  // Get timezone display name from IANA ID using COMMON_TIMEZONES, with dynamic offset
  function getTimezoneDisplayName(ianaId) {
    try {
      const timezonesDataEl = document.getElementById('timezonesData');
      if (timezonesDataEl && timezonesDataEl.textContent) {
        const timezones = JSON.parse(timezonesDataEl.textContent);
        const tz = timezones.find(t => t.id === ianaId);
        if (tz) {
          // Get current offset dynamically (handles DST)
          const currentOffset = getCurrentTimezoneOffset(ianaId);
          // Return format: "Prague (UTC+1)" or "Prague (UTC+2)" depending on season
          return tz.name + ' (' + currentOffset + ')';
        }
      }
    } catch (e) {
      console.warn('Could not get timezone display name:', e);
    }
    // Fallback: return IANA ID with dynamic offset
    const currentOffset = getCurrentTimezoneOffset(ianaId);
    return ianaId + ' (' + currentOffset + ')';
  }

  // Helper: Find IANA ID from display name or IANA ID in COMMON_TIMEZONES
  function findIanaIdFromTimezone(timezoneValue) {
    if (!timezoneValue || !timezoneValue.trim()) return null;
    
    const trimmed = timezoneValue.trim();
    
    try {
      const timezonesDataEl = document.getElementById('timezonesData');
      if (timezonesDataEl && timezonesDataEl.textContent) {
        const timezones = JSON.parse(timezonesDataEl.textContent);
        
        // First, try exact IANA ID match
        const exactMatch = timezones.find(t => t.id === trimmed);
        if (exactMatch) {
          return exactMatch.id;
        }
        
        // Then, try matching by display name (e.g., "Prague (UTC+1)")
        const nameMatch = timezones.find(t => {
          // Match exact name
          if (t.name === trimmed) return true;
          // Match name with offset (e.g., "Prague (UTC+1)")
          const nameWithOffset = t.name + ' (' + t.offset + ')';
          if (nameWithOffset === trimmed) return true;
          // Match partial name (e.g., "Prague" matches "Prague (UTC+1)")
          if (trimmed.startsWith(t.name + ' (')) return true;
          return false;
        });
        
        if (nameMatch) {
          return nameMatch.id;
        }
      }
    } catch (e) {
      console.warn('Error looking up timezone in COMMON_TIMEZONES:', e);
    }
    
    // If it looks like an IANA ID (contains '/'), return as-is
    if (trimmed.includes('/')) {
      return trimmed;
    }
    
    return null;
  }

  // Resolve mentor timezone from global userProfileData JSON (provided by dashboard_mentor/base.html)
  function resolveMentorTimezone() {
    let tz = null;
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const rawText = dataEl.textContent.trim();
        console.log('[Calendar] userProfileData raw text:', rawText);
        
        if (rawText) {
          const data = JSON.parse(rawText);
          console.log('[Calendar] userProfileData parsed:', data);
          
          let rawTimezone = null;
          
          // Priority 1: selected_timezone
          if (data.selected_timezone && data.selected_timezone.trim() !== '') {
            rawTimezone = data.selected_timezone.trim();
            console.log('[Calendar] Using selected_timezone:', rawTimezone);
          } 
          // Priority 2: detected_timezone
          else if (data.detected_timezone && data.detected_timezone.trim() !== '') {
            rawTimezone = data.detected_timezone.trim();
            console.log('[Calendar] Using detected_timezone:', rawTimezone);
          } else {
            console.warn('[Calendar] Both selected_timezone and detected_timezone are empty');
            console.warn('[Calendar] selected_timezone:', data.selected_timezone);
            console.warn('[Calendar] detected_timezone:', data.detected_timezone);
            // Fallback: try browser-detected timezone
            try {
              const browserTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
              if (browserTz) {
                rawTimezone = browserTz;
                console.log('[Calendar] Fallback: Using browser-detected timezone:', browserTz);
              }
            } catch (e) {
              console.warn('[Calendar] Could not detect browser timezone:', e);
            }
          }
          
          // Convert to IANA ID if we have a timezone value
          if (rawTimezone) {
            const ianaId = findIanaIdFromTimezone(rawTimezone);
            if (ianaId) {
              tz = ianaId;
              console.log('[Calendar] Resolved timezone:', rawTimezone, '->', ianaId);
            } else {
              // If lookup failed but it looks like an IANA ID, use it
              if (rawTimezone.includes('/')) {
                tz = rawTimezone;
                console.log('[Calendar] Using raw timezone as IANA ID:', tz);
              } else {
                console.warn('[Calendar] Could not resolve timezone:', rawTimezone);
              }
            }
          }
        } else {
          console.warn('[Calendar] userProfileData element has empty textContent');
        }
      } else {
        console.error('[Calendar] userProfileData element not found!');
      }
    } catch (e) {
      console.error('[Calendar] Could not resolve mentor timezone:', e);
    }
    
    // Final fallback: browser timezone or UTC
    if (!tz) {
      try {
        tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
        console.log('[Calendar] Final fallback: Using browser timezone:', tz);
      } catch (e) {
        tz = 'UTC';
        console.warn('[Calendar] Final fallback: Using UTC');
      }
    }
    
    console.log('[Calendar] Final resolved timezone:', tz);
    return tz || 'UTC';
  }

  let calendar = null;
  let mentorTimezone = resolveMentorTimezone();
  let mentorTimezoneDisplay = getTimezoneDisplayName(mentorTimezone);
  let isAvailabilityMode = false; // Track toggle state
  let sessionLength = 60; // Default session length in minutes
  let createdAvailabilitySlots = []; // Track created availability slots
  let originalSavedSlots = []; // Track original saved state for change detection
  const saveBtn = document.getElementById("availabilityCalendarSaveBtn");
  
  // Get session_length from userProfileData
  function getSessionLength() {
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const data = JSON.parse(dataEl.textContent);
        return data.session_length || 60;
      }
    } catch (e) {
      console.warn('Could not get session_length:', e);
    }
    return 60; // Default fallback
  }
  
  // Function to update timezone (call this when popup opens to get latest values)
  function updateTimezoneFromProfile() {
    mentorTimezone = resolveMentorTimezone();
    mentorTimezoneDisplay = getTimezoneDisplayName(mentorTimezone);
    sessionLength = getSessionLength();
    
    // Update timezone display
    updateTimezoneDisplay();
    
    // Update calendar timezone if it exists
    if (calendar) {
      calendar.setOption('timeZone', mentorTimezone);
      calendar.render();
    }
  }
  
  // Compare current slots with original saved state to detect changes
  function hasUnsavedChanges() {
    if (createdAvailabilitySlots.length !== originalSavedSlots.length) {
      return true;
    }
    
    // Create a map of original slots by ID for quick lookup
    const originalMap = new Map();
    originalSavedSlots.forEach(slot => {
      const key = `${slot.id}_${slot.start}_${slot.end}_${slot.length}_${slot.type || 'availability_slot'}`;
      originalMap.set(key, true);
    });
    
    // Check if all current slots exist in original state
    for (const slot of createdAvailabilitySlots) {
      const key = `${slot.id}_${slot.start}_${slot.end}_${slot.length}_${slot.type || 'availability_slot'}`;
      if (!originalMap.has(key)) {
        return true; // Found a slot that doesn't match original
      }
    }
    
    return false; // No changes detected
  }
  
  // Enable/disable Save button based on changes
  function updateSaveButton() {
    if (saveBtn) {
      const hasChanges = hasUnsavedChanges();
      saveBtn.disabled = !hasChanges || createdAvailabilitySlots.length === 0;
      // Reset button text if it was in "Saving..." state and we're not currently saving
      if (saveBtn.textContent === 'Saving...' && !saveBtn.disabled) {
        saveBtn.textContent = 'Save';
      }
    }
  }
  
  // Extract UTC offset from timezone display name (e.g., "Prague (UTC+1)" -> "UTC+1")
  function extractUTCOffset(displayName) {
    // Extract offset from format like "Prague (UTC+1)" or "UTC+1"
    const match = displayName.match(/UTC[+-]\d{1,2}(:\d{2})?/);
    if (match) {
      return match[0];
    }
    // Fallback: get current offset dynamically
    return getCurrentTimezoneOffset(mentorTimezone);
  }
  
  // Update timezone display and start real-time clock
  function updateTimezoneDisplay() {
    if (timezoneValueEl) {
      // Extract just the UTC offset (e.g., "UTC+01")
      const offset = extractUTCOffset(mentorTimezoneDisplay);
      timezoneValueEl.textContent = offset;
    }
  }
  
  // Update real-time clock in timezone
  function updateTimezoneClock() {
    if (timezoneTimeEl && mentorTimezone) {
      try {
        const now = new Date();
        const formatter = new Intl.DateTimeFormat('en-US', {
          timeZone: mentorTimezone,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        });
        timezoneTimeEl.textContent = formatter.format(now);
      } catch (e) {
        console.warn('Could not update timezone clock:', e);
      }
    }
  }
  
  // Start clock update interval
  let clockInterval = null;
  function startTimezoneClock() {
    updateTimezoneClock();
    if (clockInterval) clearInterval(clockInterval);
    clockInterval = setInterval(updateTimezoneClock, 1000);
  }
  
  // Initialize session length
  sessionLength = getSessionLength();
  
  // Update timezone display immediately
  updateTimezoneDisplay();
  startTimezoneClock();
  
  // Collision warning modal handlers
  const collisionModal = document.getElementById("collisionWarningModal");
  const collisionCloseTriggers = document.querySelectorAll("[data-close-collision-warning]");
  
  function openCollisionWarning() {
    if (!collisionModal) return;
    
    // Get all collisions
    const collisions = getAllCollisions();
    const collisionListEl = document.getElementById("collisionList");
    
    if (collisionListEl) {
      if (collisions.length === 0) {
        collisionListEl.innerHTML = '<p style="color: #64748b; margin: 0;">No collisions found.</p>';
      } else {
        collisionListEl.innerHTML = collisions.map((pair, index) => `
          <div class="collision-item">
            <span class="collision-number">${index + 1}.</span>
            <div class="collision-slots">
              <span class="collision-slot">${pair.slot1.time}</span>
              <span class="collision-vs">vs</span>
              <span class="collision-slot">${pair.slot2.time}</span>
            </div>
          </div>
        `).join('');
      }
    }
    
    collisionModal.classList.add("is-visible");
  }
  
  function closeCollisionWarning() {
    if (collisionModal) {
      collisionModal.classList.remove("is-visible");
    }
  }
  
  if (collisionCloseTriggers.length > 0) {
    collisionCloseTriggers.forEach(btn => {
      btn.addEventListener("click", closeCollisionWarning);
    });
  }
  
  // Close collision modal when clicking backdrop
  if (collisionModal) {
    collisionModal.addEventListener("click", function(e) {
      if (e.target === collisionModal || e.target.classList.contains("collision-warning-backdrop")) {
        closeCollisionWarning();
      }
    });
  }
  
  // Save button click handler
  if (saveBtn) {
    saveBtn.addEventListener('click', function() {
      if (saveBtn.disabled) return;
      
      if (createdAvailabilitySlots.length === 0) {
        alert('No availability slots to save.');
        return;
      }
      
      // Check for collisions before saving
      if (hasAnyCollisions()) {
        openCollisionWarning();
        return; // Prevent saving
      }
      
      // Prepare data for backend
      // Group slots by date and format them
      const slotsByDate = {};
      
      createdAvailabilitySlots.forEach(slot => {
        // Parse dates - they're already in ISO format from calendar
        const startDate = new Date(slot.start);
        const endDate = new Date(slot.end);
        
        // Format date in mentor's timezone (YYYY-MM-DD)
        const dateFormatter = new Intl.DateTimeFormat('en-CA', {
          timeZone: mentorTimezone,
          year: 'numeric',
          month: '2-digit',
          day: '2-digit'
        });
        const dateStr = dateFormatter.format(startDate);
        
        // Format times in mentor's timezone (HH:MM)
        const timeFormatter = new Intl.DateTimeFormat('en-US', {
          timeZone: mentorTimezone,
          hour: '2-digit',
          minute: '2-digit',
          hour12: false
        });
        const startTimeParts = timeFormatter.formatToParts(startDate);
        const endTimeParts = timeFormatter.formatToParts(endDate);
        
        const startTime = startTimeParts.find(p => p.type === 'hour').value.padStart(2, '0') + ':' + 
                         startTimeParts.find(p => p.type === 'minute').value.padStart(2, '0');
        const endTime = endTimeParts.find(p => p.type === 'hour').value.padStart(2, '0') + ':' + 
                       endTimeParts.find(p => p.type === 'minute').value.padStart(2, '0');
        
        if (!slotsByDate[dateStr]) {
          slotsByDate[dateStr] = [];
        }
        
        // Get type from the calendar event if available
        const calendarEvent = calendar ? calendar.getEventById(slot.id) : null;
        const slotType = calendarEvent?.extendedProps?.type || slot.type || 'availability_slot';
        
        slotsByDate[dateStr].push({
          date: dateStr,
          start: startTime,
          end: endTime,
          length: slot.length,
          id: slot.id,
          type: slotType
        });
      });
      
      // Collect all slots from all dates into a single array
      const allAvailabilityData = [];
      const dates = Object.keys(slotsByDate);
      
      if (dates.length === 0) {
        alert('No valid date found.');
        return;
      }
      
      // Flatten all slots from all dates into a single array
      dates.forEach(dateStr => {
        allAvailabilityData.push(...slotsByDate[dateStr]);
      });
      
      // Use the first date as the selected_date for backward compatibility
      // (backend will process all slots but use this date for filtering)
      const firstDate = dates[0];
      
      // Get CSRF token
      const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
      if (!csrfToken) {
        alert('CSRF token not found. Please refresh the page.');
        return;
      }
      
      // Disable save button during request
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
      
      // Send to backend - send all slots, backend will handle them by date
      fetch('{% url "general:dashboard_mentor:save_availability" %}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({
          availability: allAvailabilityData,
          selected_date: firstDate
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Reset button text
          saveBtn.textContent = 'Save';
          
          // Reload saved slots from backend to reflect the saved state
          loadSavedAvailabilitySlots().then(() => {
            // Show success message after reloading
            alert(data.message || 'Availability slots saved successfully!');
          }).catch(error => {
            console.error('Error reloading slots after save:', error);
            alert(data.message || 'Availability slots saved successfully!');
          });
        } else {
          alert(data.error || 'Failed to save availability slots.');
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save';
        }
      })
      .catch(error => {
        console.error('Error saving availability:', error);
        alert('An error occurred while saving. Please try again.');
        saveBtn.disabled = false;
        saveBtn.textContent = 'Save';
      });
    });
  }

  // Store availability slots as events
  let availabilityEvents = [];
  
  // Check if two time ranges overlap
  function slotsOverlap(start1, end1, start2, end2) {
    // Convert to timestamps for comparison
    const s1 = new Date(start1).getTime();
    const e1 = new Date(end1).getTime();
    const s2 = new Date(start2).getTime();
    const e2 = new Date(end2).getTime();
    
    // Two ranges overlap if: start1 < end2 AND start2 < end1
    return s1 < e2 && s2 < e1;
  }
  
  // Check if a slot collides with any existing slots
  function checkSlotCollisions(startDate, endDate, excludeSlotId = null) {
    const collisions = [];
    
    // Check against all existing availability events
    if (calendar) {
      const allEvents = calendar.getEvents();
      allEvents.forEach(event => {
        // Skip if it's not an availability slot or if it's the slot we're checking
        if (!event.extendedProps || !event.extendedProps.isAvailability) {
          return;
        }
        
        if (excludeSlotId && event.extendedProps.slotId === excludeSlotId) {
          return;
        }
        
        // Check for overlap
        if (slotsOverlap(startDate, endDate, event.start, event.end)) {
          collisions.push(event);
        }
      });
    }
    
    return collisions;
  }
  
  // Check if there are any collisions in all availability slots
  function hasAnyCollisions() {
    if (!calendar) return false;
    
    const allEvents = calendar.getEvents().filter(e => 
      e.extendedProps && e.extendedProps.isAvailability
    );
    
    // Check each slot for collisions
    for (let i = 0; i < allEvents.length; i++) {
      const event = allEvents[i];
      const collisions = checkSlotCollisions(event.start, event.end, event.extendedProps.slotId);
      if (collisions.length > 0) {
        return true;
      }
    }
    
    return false;
  }
  
  // Get all collision pairs for display
  function getAllCollisions() {
    if (!calendar) return [];
    
    const allEvents = calendar.getEvents().filter(e => 
      e.extendedProps && e.extendedProps.isAvailability
    );
    
    const collisionPairs = [];
    const processedPairs = new Set();
    
    for (let i = 0; i < allEvents.length; i++) {
      const event = allEvents[i];
      const collisions = checkSlotCollisions(event.start, event.end, event.extendedProps.slotId);
      
      collisions.forEach(collidingEvent => {
        // Create a unique pair ID to avoid duplicates
        const pairId1 = event.id + '_' + collidingEvent.id;
        const pairId2 = collidingEvent.id + '_' + event.id;
        
        if (!processedPairs.has(pairId1) && !processedPairs.has(pairId2)) {
          processedPairs.add(pairId1);
          processedPairs.add(pairId2);
          
          // Format times for display
          const start1 = formatEventTime(event.start);
          const end1 = formatEventTime(event.end);
          const start2 = formatEventTime(collidingEvent.start);
          const end2 = formatEventTime(collidingEvent.end);
          
          collisionPairs.push({
            slot1: { time: `${start1} - ${end1}` },
            slot2: { time: `${start2} - ${end2}` }
          });
        }
      });
    }
    
    return collisionPairs;
  }
  
  // Format event time for display
  function formatEventTime(dateStr) {
    const date = new Date(dateStr);
    const formatter = new Intl.DateTimeFormat('en-US', {
      timeZone: mentorTimezone,
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
    return formatter.format(date);
  }
  
  // Update slot colors based on collisions
  function updateSlotColors() {
    if (!calendar) return;
    
    const allEvents = calendar.getEvents();
    
    // Reset all availability slots to blue
    allEvents.forEach(event => {
      if (event.extendedProps && event.extendedProps.isAvailability) {
        event.setProp('backgroundColor', '#3b82f6');
        event.setProp('borderColor', '#2563eb');
      }
    });
    
    // Check each slot for collisions
    allEvents.forEach(event => {
      if (event.extendedProps && event.extendedProps.isAvailability) {
        const collisions = checkSlotCollisions(event.start, event.end, event.extendedProps.slotId);
        
        if (collisions.length > 0) {
          // This slot has collisions - make it red
          event.setProp('backgroundColor', '#ef4444');
          event.setProp('borderColor', '#dc2626');
          
          // Also make colliding slots red
          collisions.forEach(collidingEvent => {
            collidingEvent.setProp('backgroundColor', '#ef4444');
            collidingEvent.setProp('borderColor', '#dc2626');
          });
        }
      }
    });
  }
  
  // Create an availability slot event from a date/time
  function createAvailabilitySlotEvent(startDate, lengthMinutes) {
    const endDate = new Date(startDate.getTime() + lengthMinutes * 60 * 1000);
    
    // Generate unique ID for this slot
    const slotId = 'avail_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    
    // Check for collisions
    const collisions = checkSlotCollisions(startDate.toISOString(), endDate.toISOString());
    const hasCollision = collisions.length > 0;
    
    return {
      id: slotId,
      title: 'Available',
      start: startDate.toISOString(),
      end: endDate.toISOString(),
      backgroundColor: hasCollision ? '#ef4444' : '#3b82f6', // Red if collision, blue otherwise
      borderColor: hasCollision ? '#dc2626' : '#2563eb',
      classNames: ['availability-slot'],
      extendedProps: {
        isAvailability: true,
        length: lengthMinutes,
        slotId: slotId,
        type: 'availability_slot' // Mark as availability slot (fixed length)
      }
    };
  }
  
  // Handle date/time slot click in availability mode
  function handleSlotClick(selectInfo) {
    if (!isAvailabilityMode) return;
    
    // Only allow in day and week views
    const currentView = calendar.view;
    if (currentView.type !== 'timeGridDay' && currentView.type !== 'timeGridWeek') {
      return;
    }
    
    const startDate = selectInfo.start;
    
    // Use fixed session_length from mentor profile (ignore selection duration)
    const lengthMinutes = sessionLength;
    
    // Create the slot event with fixed length
    const slotEvent = createAvailabilitySlotEvent(startDate, lengthMinutes);
    
    // Add to availability events
    availabilityEvents.push(slotEvent);
    
    // Add to created slots tracking (for saving)
    createdAvailabilitySlots.push({
      id: slotEvent.extendedProps.slotId,
      start: slotEvent.start,
      end: slotEvent.end,
      length: lengthMinutes,
      type: 'availability_slot' // Include type
    });
    
    // Add event to calendar
    calendar.addEvent(slotEvent);
    
    // Update colors to check for collisions
    updateSlotColors();
    
    // Enable Save button
    updateSaveButton();
    
    // Unselect the time slot
    calendar.unselect();
  }
  
  // Handle event drop (when dragging availability slots)
  function handleEventDrop(dropInfo) {
    if (!isAvailabilityMode) return;
    
    const event = dropInfo.event;
    
    // Only handle availability slots
    if (!event.extendedProps || !event.extendedProps.isAvailability) {
      return;
    }
    
    // Update the slot in our tracking array
    const slotId = event.extendedProps.slotId;
    const slotIndex = createdAvailabilitySlots.findIndex(s => s.id === slotId);
    
    if (slotIndex !== -1) {
      // Convert Date objects to ISO strings properly
      const newStart = event.start instanceof Date ? event.start.toISOString() : event.start;
      const newEnd = event.end instanceof Date ? event.end.toISOString() : event.end;
      
      // Update the slot with new start/end times
      createdAvailabilitySlots[slotIndex].start = newStart;
      createdAvailabilitySlots[slotIndex].end = newEnd;
      
      // Preserve type if it exists
      if (!createdAvailabilitySlots[slotIndex].type) {
        createdAvailabilitySlots[slotIndex].type = event.extendedProps?.type || 'availability_slot';
      }
      
      // Check for collisions and update colors
      updateSlotColors();
      
      // Enable Save button since we have changes
      updateSaveButton();
    } else {
      // Slot not found in tracking array - this shouldn't happen, but if it does,
      // we should still enable the save button as a safety measure
      console.warn('Slot moved but not found in tracking array:', slotId);
      updateSaveButton();
    }
  }
  
  // Handle event resize (when resizing availability slots)
  function handleEventResize(resizeInfo) {
    if (!isAvailabilityMode) return;
    
    const event = resizeInfo.event;
    
    // Only handle availability slots
    if (!event.extendedProps || !event.extendedProps.isAvailability) {
      return;
    }
    
    // Prevent resizing if this is an availability_slot (fixed length)
    const slotType = event.extendedProps.type || 'availability_slot';
    if (slotType === 'availability_slot') {
      // Revert to original length
      const originalLength = event.extendedProps.length || sessionLength;
      const startDate = new Date(event.start);
      const endDate = new Date(startDate.getTime() + originalLength * 60 * 1000);
      
      // Prevent the resize by setting the end time back
      event.setEnd(endDate);
      
      // Show a message to the user
      console.log('Availability slots have fixed length and cannot be resized.');
      return;
    }
    
    // Allow resizing for session slots (type !== 'availability_slot')
    const slotId = event.extendedProps.slotId;
    const slotIndex = createdAvailabilitySlots.findIndex(s => s.id === slotId);
    
    if (slotIndex !== -1) {
      // Calculate new length
      const startDate = new Date(event.start);
      const endDate = new Date(event.end);
      const diffMs = endDate.getTime() - startDate.getTime();
      const lengthMinutes = Math.round(diffMs / (1000 * 60));
      
      createdAvailabilitySlots[slotIndex].start = event.start.toISOString();
      createdAvailabilitySlots[slotIndex].end = event.end.toISOString();
      createdAvailabilitySlots[slotIndex].length = lengthMinutes;
      
      // Update extended props
      event.setExtendedProp('length', lengthMinutes);
      
      // Check for collisions and update colors
      updateSlotColors();
      
      // Enable Save button since we have changes
      updateSaveButton();
    }
  }
  
  // Handle event removal (when deleting availability slots)
  function handleEventRemove(removeInfo) {
    if (!isAvailabilityMode) return;
    
    const event = removeInfo.event;
    
    // Only handle availability slots
    if (!event.extendedProps || !event.extendedProps.isAvailability) {
      return;
    }
    
    // Remove from tracking arrays
    const slotId = event.extendedProps.slotId;
    const slotIndex = createdAvailabilitySlots.findIndex(s => s.id === slotId);
    
    if (slotIndex !== -1) {
      createdAvailabilitySlots.splice(slotIndex, 1);
      
      // Also remove from availabilityEvents if it exists there
      const eventIndex = availabilityEvents.findIndex(e => e.id === event.id);
      if (eventIndex !== -1) {
        availabilityEvents.splice(eventIndex, 1);
      }
      
      // Update colors and save button
      updateSlotColors();
      updateSaveButton();
    }
  }

  function scrollToAppropriateTime() {
    if (!calendar) return;
    
    const currentView = calendar.view;
    // Apply scrolling to both day and week views
    if (currentView.type !== 'timeGridDay' && currentView.type !== 'timeGridWeek') return;
    
    // Always scroll to 9am
    calendar.scrollToTime({ hours: 9, minutes: 0 });
    
    // Then adjust to center it in the viewport
    setTimeout(() => {
      const scrollContainer = calendarRoot.querySelector('.fc-scroller');
      if (!scrollContainer) return;
      
      // Find the time slot element for 9am
      const timeSlots = scrollContainer.querySelectorAll('.fc-timegrid-slot');
      if (timeSlots.length === 0) return;
      
      // 9am = 9 * 12 = slot 108 (each slot is 5 minutes, so 12 slots per hour)
      const slotIndex = 9 * 12;
      const targetSlot = timeSlots[slotIndex];
      
      if (targetSlot) {
        const containerRect = scrollContainer.getBoundingClientRect();
        const slotRect = targetSlot.getBoundingClientRect();
        const scrollTop = scrollContainer.scrollTop;
        
        // Calculate position relative to scroll container
        const slotTop = slotRect.top - containerRect.top + scrollTop;
        const viewportHeight = containerRect.height;
        
        // Center the slot in the viewport
        const targetScrollTop = slotTop - (viewportHeight / 2);
        
        scrollContainer.scrollTo({
          top: Math.max(0, targetScrollTop),
          behavior: 'smooth'
        });
      }
    }, 100);
  }

  function initCalendar() {
    // Debug: log the timezone being used
    console.log('Calendar timezone:', mentorTimezone);
    console.log('Current UTC time:', new Date().toISOString());
    
    // For nowIndicator to work correctly with timeZone, we need to provide
    // a function that returns the current time, and FullCalendar will interpret it
    // in the context of the specified timeZone
    // Using a function ensures it updates dynamically
    calendar = new FullCalendar.Calendar(calendarRoot, {
      timeZone: mentorTimezone,
      initialView: "timeGridWeek",
      height: "100%",
      nowIndicator: true,
      // Don't set 'now' explicitly - let FullCalendar use current time
      // It should automatically respect the timeZone setting
      slotMinTime: "00:00:00", // Start at midnight
      slotMaxTime: "24:00:00", // End at midnight (24 hours)
      slotDuration: "00:05:00", // 5-minute intervals for thin rows
      slotLabelInterval: "01:00:00", // Show labels every hour
      slotLabelContent: function(arg) {
        // Return hour number (0-23) - this matches the timezone correctly
        const hour = arg.date.getHours();
        const minutes = arg.date.getMinutes();
        // Only show if exactly on the hour
        if (minutes === 0 && hour >= 0 && hour <= 23) {
          return hour.toString();
        }
        return '';
      },
      headerToolbar: false,
      selectable: isAvailabilityMode, // Only allow selection in availability mode
      selectMirror: true,
      selectOverlap: false, // Prevent overlapping selections
      editable: isAvailabilityMode, // Allow dragging/resizing in availability mode
      eventStartEditable: isAvailabilityMode, // Allow dragging
      eventDurationEditable: function(info) {
        // Only allow resizing if it's not an availability_slot (fixed length)
        if (!isAvailabilityMode) return false;
        const slotType = info.event.extendedProps?.type || 'availability_slot';
        return slotType !== 'availability_slot'; // Allow resize only for non-availability slots
      },
      eventResizableFromStart: true, // Allow resizing from start (if allowed)
      firstDay: 1, // Start week with Monday
      allDaySlot: false, // Remove all-day row from week and day views
      events: availabilityEvents,
      select: handleSlotClick, // Handle slot selection
      eventDrop: handleEventDrop, // Handle event drag
      eventResize: handleEventResize, // Handle event resize
      eventRemove: handleEventRemove, // Handle event removal
      // Remove all-day slot from specific views
      views: {
        timeGridWeek: {
          allDaySlot: false,
          slotMinTime: "00:00:00",
          slotMaxTime: "24:00:00",
          slotDuration: "00:05:00",
          slotLabelInterval: "01:00:00",
          slotLabelContent: function(arg) {
            // Return hour number (0-23) - this matches the timezone correctly
            const hour = arg.date.getHours();
            const minutes = arg.date.getMinutes();
            // Only show if exactly on the hour
            if (minutes === 0 && hour >= 0 && hour <= 23) {
              return hour.toString();
            }
            return '';
          },
          slotLaneClassNames: function(arg) {
            const minutes = arg.date.getMinutes();
            if (minutes === 0) {
              return ['fc-hour-slot'];
            }
            return [];
          }
        },
        timeGridDay: {
          allDaySlot: false,
          slotMinTime: "00:00:00",
          slotMaxTime: "24:00:00",
          slotDuration: "00:05:00",
          slotLabelInterval: "01:00:00",
          slotLabelContent: function(arg) {
            // Return hour number (0-23) - this matches the timezone correctly
            const hour = arg.date.getHours();
            const minutes = arg.date.getMinutes();
            // Only show if exactly on the hour
            if (minutes === 0 && hour >= 0 && hour <= 23) {
              return hour.toString();
            }
            return '';
          },
          slotLaneClassNames: function(arg) {
            const minutes = arg.date.getMinutes();
            if (minutes === 0) {
              return ['fc-hour-slot'];
            }
            return [];
          },
          scrollTime: "09:00:00" // Default scroll position
        }
      }
    });

    calendar.render();

    // Update timezone display
    updateTimezoneDisplay();

    // Mark hour slots for CSS targeting - call multiple times to ensure they persist
    setTimeout(() => {
      markHourSlots();
      // Call again after a delay to ensure classes persist after any re-renders
      setTimeout(() => markHourSlots(), 200);
      setTimeout(() => markHourSlots(), 500);
    }, 100);

    // Listen to calendar's render events to re-mark slots after re-renders
    if (calendar && calendar.on) {
      calendar.on('viewDidMount', function() {
        setTimeout(() => markHourSlots(), 100);
        updateDateDisplay(); // Update date display when view mounts
      });
      
      // Also listen to datesSet event which fires when calendar navigates
      calendar.on('datesSet', function() {
        setTimeout(() => markHourSlots(), 100);
        updateDateDisplay(); // Update date display when dates change
      });
    }
    
    // Initial date display update
    setTimeout(() => updateDateDisplay(), 100);
    
    // Use MutationObserver to watch for DOM changes and re-apply borders
    const observer = new MutationObserver(function(mutations) {
      // Re-mark hour slots if the slots table changes
      const slotsTable = calendarRoot.querySelector('table.fc-timegrid-slots');
      if (slotsTable) {
        setTimeout(() => markHourSlots(), 50);
      }
    });
    
    // Observe the calendar root for changes
    if (calendarRoot) {
      observer.observe(calendarRoot, {
        childList: true,
        subtree: true
      });
    }

    setTimeout(() => {
      calendar.updateSize();
      // If initial view is day or week view, scroll appropriately
      if (calendar.view.type === 'timeGridDay' || calendar.view.type === 'timeGridWeek') {
        setTimeout(() => {
          scrollToAppropriateTime();
          markHourSlots(); // Re-mark after scrolling
        }, 100);
      }
    }, 50);
  }

  function markHourSlots() {
    if (!calendarRoot) return;
    
    // Mark slot 0 (midnight) and then every 12th slot (each hour)
    const slots = calendarRoot.querySelectorAll('table.fc-timegrid-slots tbody tr');
    if (slots.length === 0) return;
    
    slots.forEach((slot, index) => {
      // Slot 0 (index 0) and every 12th slot after that (index 12, 24, 36, etc.)
      const isHourSlot = (index === 0 || index % 12 === 0);
      
      if (isHourSlot) {
        slot.classList.add('fc-hour-slot');
        // Also mark children
        slot.querySelectorAll('td, .fc-timegrid-slot-lane').forEach(el => {
          el.classList.add('fc-hour-slot');
        });
      } else {
        slot.classList.remove('fc-hour-slot');
        slot.querySelectorAll('td, .fc-timegrid-slot-lane').forEach(el => {
          el.classList.remove('fc-hour-slot');
        });
      }
    });
  }

  // Load saved availability slots from backend
  async function loadSavedAvailabilitySlots() {
    try {
      const response = await fetch('{% url "general:dashboard_mentor:get_availability" %}');
      const data = await response.json();
      
      if (data.success && calendar) {
        // Clear existing availability events and tracking
        availabilityEvents = [];
        createdAvailabilitySlots = [];
        originalSavedSlots = []; // Reset original state
        
        // Load one-time slots
        // Note: Slots are stored in UTC (standard time) in the database
        // FullCalendar will automatically display them adjusted to mentorTimezone
        // because we set timeZone: mentorTimezone in the calendar configuration
        if (data.one_time_slots && Array.isArray(data.one_time_slots)) {
          data.one_time_slots.forEach(slot => {
            try {
              // Parse the slot dates (they're stored in UTC ISO format)
              // JavaScript Date will parse them correctly, and FullCalendar will
              // display them in the mentor's timezone automatically
              const startDate = new Date(slot.start);
              const endDate = new Date(slot.end);
              
              // Skip if dates are invalid
              if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                return;
              }
              
              // Calculate length if not provided
              const lengthMinutes = slot.length || Math.round((endDate.getTime() - startDate.getTime()) / (1000 * 60));
              
              // Use existing ID or generate one
              const slotId = slot.id || 'saved_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
              
              // Get type from saved slot or default to 'availability_slot'
              const slotType = slot.type || 'availability_slot';
              
              // Create calendar event
              const slotEvent = {
                id: slotId,
                title: 'Available',
                start: startDate.toISOString(),
                end: endDate.toISOString(),
                backgroundColor: '#3b82f6',
                borderColor: '#2563eb',
                classNames: ['availability-slot'],
                extendedProps: {
                  isAvailability: true,
                  length: lengthMinutes,
                  slotId: slotId,
                  type: slotType, // Include type from saved slot
                  isSaved: true // Mark as saved slot
                }
              };
              
              availabilityEvents.push(slotEvent);
              
              // Track in createdAvailabilitySlots for collision detection and saving
              const slotData = {
                id: slotId,
                start: slotEvent.start,
                end: slotEvent.end,
                length: lengthMinutes,
                type: slotType // Include type
              };
              
              createdAvailabilitySlots.push(slotData);
              
              // Store in originalSavedSlots for change detection (deep copy)
              originalSavedSlots.push({
                id: slotId,
                start: slotEvent.start,
                end: slotEvent.end,
                length: lengthMinutes,
                type: slotType
              });
              
              // Only add to calendar if we're in availability mode
              // Events are stored in availabilityEvents array and will be shown/hidden based on toggle
              if (isAvailabilityMode) {
                calendar.addEvent(slotEvent);
              }
            } catch (e) {
              console.warn('Error loading slot:', e);
            }
          });
        }
        
        // After loading, update calendar display based on current mode
        updateCalendarEventsForMode();
        
        // Check for collisions and update colors (only if in availability mode)
        if (isAvailabilityMode) {
          updateSlotColors();
        }
        updateSaveButton(); // This will disable the button since state matches original
      }
    } catch (error) {
      console.error('Error loading availability slots:', error);
      throw error; // Re-throw so caller can handle it
    }
  }
  
  function openOverlay() {
    overlay.classList.add("is-visible");
    
    // Re-read timezone and session_length from profile when opening (in case it was updated)
    updateTimezoneFromProfile();
    startTimezoneClock();
    
    // Reset availability mode when opening
    isAvailabilityMode = false;
    if (toggleBtn) {
      toggleBtn.classList.remove("active");
    }

    if (!calendar) {
      initCalendar();
      // Load saved slots after calendar is initialized
      setTimeout(() => {
        loadSavedAvailabilitySlots().then(() => {
          // Ensure calendar shows correct events based on mode
          updateCalendarEventsForMode();
        });
      }, 100);
    } else {
      // Update calendar timezone in case it changed
      calendar.setOption('timeZone', mentorTimezone);
      calendar.setOption('selectable', isAvailabilityMode);
      calendar.setOption('editable', isAvailabilityMode);
      calendar.setOption('eventStartEditable', isAvailabilityMode);
      
      // Load saved slots (they'll be filtered by mode inside loadSavedAvailabilitySlots)
      loadSavedAvailabilitySlots().then(() => {
        // Ensure calendar shows correct events based on mode
        updateCalendarEventsForMode();
        
        calendar.render();
        setTimeout(() => {
          calendar.updateSize();
          markHourSlots();
          updateDateDisplay(); // Update date display when opening overlay
          // If current view is day or week view, scroll appropriately
          if (calendar.view.type === 'timeGridDay' || calendar.view.type === 'timeGridWeek') {
            setTimeout(() => scrollToAppropriateTime(), 150);
          }
        }, 50);
      });
    }
  }

  function closeOverlay() {
    overlay.classList.remove("is-visible");
    // Stop clock when overlay closes
    if (clockInterval) {
      clearInterval(clockInterval);
      clockInterval = null;
    }
  }

  openTriggers.forEach(btn => btn.addEventListener("click", openOverlay));
  closeTriggers.forEach(btn => btn.addEventListener("click", closeOverlay));
  
  // Handle "Change" link click - scroll to Time Zone section on profile page
  const changeLink = document.querySelector('.timezone-change-link');
  if (changeLink) {
    changeLink.addEventListener('click', function(e) {
      // Close the calendar overlay first
      closeOverlay();
    });
  }
  
  // Handle hash navigation when page loads (if coming from calendar with #timezone-section)
  if (window.location.hash === '#timezone-section') {
    setTimeout(() => {
      const timezoneSection = document.getElementById('timezone-section');
      if (timezoneSection) {
        timezoneSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }, 300);
  }

  // Function to update calendar events based on current mode
  function updateCalendarEventsForMode() {
    if (!calendar) return;
    
    // Remove all events first
    calendar.removeAllEvents();
    
    // Add events based on current mode
    if (isAvailabilityMode) {
      // Show availability slots
      availabilityEvents.forEach(event => {
        calendar.addEvent(event);
      });
    } else {
      // Sessions mode - don't show availability slots
      // TODO: Load and show actual sessions here when sessions are implemented
    }
    
    calendar.render();
  }
  
  // Toggle button functionality (Sessions / Availability)
  const toggleBtn = document.getElementById("availabilityCalendarToggle");
  if (toggleBtn) {
    // Default to "Sessions" mode (not active = sessions, active = availability)
    toggleBtn.addEventListener("click", function() {
      toggleBtn.classList.toggle("active");
      isAvailabilityMode = toggleBtn.classList.contains("active");
      
      console.log("Toggle mode:", isAvailabilityMode ? "Availability" : "Sessions");
      
      // Update calendar based on mode
      if (calendar) {
        // Enable/disable selection and editing based on mode
        calendar.setOption('selectable', isAvailabilityMode);
        calendar.setOption('editable', isAvailabilityMode);
        calendar.setOption('eventStartEditable', isAvailabilityMode);
        // Set eventDurationEditable as a function to check slot type
        calendar.setOption('eventDurationEditable', function(info) {
          if (!isAvailabilityMode) return false;
          const slotType = info.event.extendedProps?.type || 'availability_slot';
          return slotType !== 'availability_slot'; // Allow resize only for non-availability slots
        });
        
        // Update events based on mode
        updateCalendarEventsForMode();
        
        // Update colors if in availability mode
        if (isAvailabilityMode) {
          updateSlotColors();
        }
      }
    });
  }

  // Calendar navigation (prev/next/today)
  const navBtns = overlay.querySelectorAll("[data-calendar-nav]");
  navBtns.forEach(btn => {
    btn.addEventListener("click", function() {
      if (!calendar) return;
      
      const action = this.dataset.calendarNav;
      if (action === "prev") {
        calendar.prev();
      } else if (action === "next") {
        calendar.next();
      } else if (action === "today") {
        calendar.today();
      }
      
      setTimeout(() => {
        calendar.updateSize();
        updateDateDisplay(); // Update date display after navigation
      }, 50);
    });
  });

  // Close when clicking outside the modal (on backdrop/overlay)
  overlay.addEventListener("click", function(e) {
    // Only close if clicking directly on the overlay or backdrop, not on the modal content
    if (e.target === overlay || e.target.classList.contains("availability-calendar-backdrop")) {
      closeOverlay();
    }
  });

  // Prevent clicks inside the modal from closing it
  const modal = overlay.querySelector(".availability-calendar-modal");
  if (modal) {
    modal.addEventListener("click", function(e) {
      e.stopPropagation();
    });
  }

  document.addEventListener("keydown", e => {
    if (e.key === "Escape") closeOverlay();
  });

  viewBtnEls.forEach(btn => {
    btn.addEventListener("click", function() {
      const targetView = this.dataset.calendarView;

      viewBtnEls.forEach(b => b.classList.toggle("is-active", b === this));

      if (calendar) {
        calendar.changeView(targetView);
        const timezoneDisplay = getTimezoneDisplayName(mentorTimezone);
        // Don't update subtitle - keep it fixed as "Your Timezone UTC+01 [time] Change"
        // The subtitle is already set in HTML and updated by updateTimezoneDisplay()

        setTimeout(() => {
          calendar.updateSize();
          calendar.render();
          markHourSlots();
          updateDateDisplay(); // Update date display when view changes
          
          // If switching to day or week view, scroll to appropriate time
          if (targetView === "timeGridDay" || targetView === "timeGridWeek") {
            setTimeout(() => scrollToAppropriateTime(), 150);
          }
        }, 50);
      }
    });
  });

})();
</script>

