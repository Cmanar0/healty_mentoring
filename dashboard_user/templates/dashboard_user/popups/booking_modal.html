{# Booking Modal Popup #}
<div id="bookingModal" class="booking-modal-overlay">
    <div class="booking-modal-container">
        <button class="booking-close-btn" onclick="closeBookingModal()"><i class="fas fa-times"></i></button>
        
        <!-- Error State (for mentors trying to book) -->
        <div id="bookingErrorState" class="booking-error-state" style="display: none;">
            <div class="booking-error-content">
                <div class="booking-error-icon">
                    <i class="fas fa-exclamation-circle"></i>
                </div>
                <h2 class="booking-error-title">Cannot Book Session</h2>
                <p class="booking-error-message">
                    Mentors cannot book sessions with other mentors. Please use a different account.
                </p>
                <button class="booking-error-btn" onclick="closeBookingModal()">
                    <i class="fas fa-arrow-left"></i>
                    Go Back
                </button>
            </div>
        </div>
        
        <!-- Success/Confirmation State -->
        <div id="bookingSuccessState" class="booking-success-state" style="display: none;">
            <div class="booking-success-content">
                <div class="booking-success-icon">
                    <i class="fas fa-check-circle"></i>
                </div>
                <h2 class="booking-success-title">Session Booked Successfully!</h2>
                <p class="booking-success-message" id="bookingSuccessMessage">
                    A confirmation email has been sent to your email address.
                </p>
                <div id="bookingSuccessEmail" class="booking-success-email" style="display: none;">
                    <i class="fas fa-envelope"></i>
                    <span id="bookingSuccessEmailText"></span>
                </div>
                <div id="bookingSuccessInstructions" class="booking-success-instructions" style="display: none;">
                    <h3>What's Next?</h3>
                    <ol>
                        <li>Check your email for a verification link to activate your account</li>
                        <li>Complete your registration by setting up your password</li>
                        <li>Once verified, you can log in and manage your sessions</li>
                    </ol>
                </div>
                <div id="bookingSuccessActions" class="booking-success-actions" style="display: none;">
                    <button class="booking-success-btn" onclick="window.location.href='/dashboard/user/my-sessions/'">
                        <i class="fas fa-calendar"></i>
                        View My Sessions
                    </button>
                </div>
            </div>
        </div>
        
        <div class="booking-grid" id="bookingMainContent">
            <!-- Col 1: Mentor Info -->
            <div class="booking-sidebar">
                <div class="booking-mentor-mini">
                    {% if mentor_profile.profile_picture %}
                    <img src="{{ mentor_profile.profile_picture.url }}" alt="Avatar" class="booking-avatar">
                    {% else %}
                    <div class="booking-avatar-placeholder">{{ mentor_profile.first_name|first }}</div>
                    {% endif %}
                    <div>
                        <div class="booking-mentor-name">{{ mentor_profile.first_name }} {{ mentor_profile.last_name }}</div>
                        <div class="booking-session-name">1:1 Session</div>
                    </div>
                </div>
                
                <div class="booking-meta">
                    <div class="booking-meta-item">
                        <i class="fas fa-clock"></i>
                        <span>
                            {% if mentor_profile.first_session_free %}
                                {% if user.is_authenticated %}
                                    {# For logged-in users, check if it's first session #}
                                    {% if is_first_session %}
                                        {% if mentor_profile.first_session_length == mentor_profile.session_length %}
                                            {{ mentor_profile.session_length|default:"60" }} min
                                        {% else %}
                                            {{ mentor_profile.first_session_length|default:30 }} min (First Session) / {{ mentor_profile.session_length|default:60 }} min (Regular)
                                        {% endif %}
                                    {% else %}
                                        {{ mentor_profile.session_length|default:"60" }} min
                                    {% endif %}
                                {% else %}
                                    {# For non-authenticated users, always show both if lengths differ #}
                                    {% if mentor_profile.first_session_length == mentor_profile.session_length %}
                                        {{ mentor_profile.session_length|default:"60" }} min
                                    {% else %}
                                        {{ mentor_profile.first_session_length|default:30 }} min (First Session) / {{ mentor_profile.session_length|default:60 }} min (Regular)
                                    {% endif %}
                                {% endif %}
                            {% else %}
                                {{ mentor_profile.session_length|default:"60" }} min
                            {% endif %}
                        </span>
                    </div>
                    <div class="booking-meta-item">
                        <i class="fas fa-video"></i>
                        <span>Google Meet</span>
                    </div>
                    <div class="booking-meta-item">
                        <i class="fas fa-tag"></i>
                        <span>
                            {% if mentor_profile.first_session_free %}
                                {% if user.is_authenticated %}
                                    {# For logged-in users, check if it's first session #}
                                    {% if is_first_session %}
                                        $0 <span style=" color: #10b981; font-weight: 600;">(First Session Free)</span>
                                    {% else %}
                                        ${{ mentor_profile.price_per_hour|floatformat:0 }}
                                    {% endif %}
                                {% else %}
                                    {# For non-authenticated users, always show free #}
                                    $0 <span style=" color: #10b981; font-weight: 600;">(First Session Free)</span>
                                {% endif %}
                            {% else %}
                                ${{ mentor_profile.price_per_hour|floatformat:0 }}
                            {% endif %}
                        </span>
                    </div>
                </div>

                <!-- NEW: Dynamic Selection Summary -->
                <div id="bookingSummary" class="booking-selection-summary" style="display: none;">
                    <div class="summary-label">Your Selection</div>
                    <div class="summary-details">
                        <div class="summary-item">
                            <i class="far fa-calendar-alt"></i>
                            <span id="summaryDate">Select a date</span>
                        </div>
                        <div class="summary-item" id="summaryTimeRow" style="display: none;">
                            <i class="far fa-clock"></i>
                            <span id="summaryTime">Select a time</span>
                        </div>
                    </div>
                </div>
                
                <div class="booking-desc">
                    {% if mentor_profile.first_session_free %}
                        {% if user.is_authenticated %}
                            {% if is_first_session %}
                                {% if mentor_profile.first_session_length == mentor_profile.session_length %}
                                    Your first session with {{ mentor_profile.first_name }} is free! This session lasts {{ mentor_profile.session_length|default:60 }} minutes and is perfect for discussing your goals and how {{ mentor_profile.first_name }} can help you.
                                {% else %}
                                    Your first session with {{ mentor_profile.first_name }} is free! This introductory session lasts {{ mentor_profile.first_session_length|default:30 }} minutes and is perfect for discussing your goals and how {{ mentor_profile.first_name }} can help you. Regular sessions are {{ mentor_profile.session_length|default:60 }} minutes.
                                {% endif %}
                            {% else %}
                    Book a focused session to discuss your career, goals, or specific challenges.
                            {% endif %}
                        {% else %}
                            {% if mentor_profile.first_session_length == mentor_profile.session_length %}
                                Your first session with {{ mentor_profile.first_name }} is free! This session lasts {{ mentor_profile.session_length|default:60 }} minutes and is perfect for discussing your goals and how {{ mentor_profile.first_name }} can help you.
                            {% else %}
                                Your first session with {{ mentor_profile.first_name }} is free! This introductory session lasts {{ mentor_profile.first_session_length|default:30 }} minutes and is perfect for discussing your goals and how {{ mentor_profile.first_name }} can help you. Regular sessions are {{ mentor_profile.session_length|default:60 }} minutes.
                            {% endif %}
                        {% endif %}
                    {% else %}
                        Book a focused session to discuss your career, goals, or specific challenges.
                    {% endif %}
                </div>
            </div>
            
            <!-- Col 2: Calendar -->
            <div class="booking-calendar-col">
                <h3 class="booking-title">Select a Date & Time</h3>
                
                <div class="calendar-header">
                    <button class="cal-nav-btn" id="prevMonth"><i class="fas fa-chevron-left"></i></button>
                    <div class="current-month-label" id="currentMonthLabel">October 2023</div>
                    <button class="cal-nav-btn" id="nextMonth"><i class="fas fa-chevron-right"></i></button>
                </div>
                
                <div class="calendar-grid-header">
                    <div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div>
                </div>
                <div class="calendar-days" id="calendarDays">
                    <!-- JS generated -->
                </div>
            </div>
            
            <!-- Col 3: Slots -->
            <div class="booking-slots-col" id="slotsCol" style="display: none;">
                <div class="slots-header-row">
                    <h4 class="slots-date-label" id="selectedDateLabel">Thursday, Oct 12</h4>
                </div>
                <div class="slots-list" id="slotsList">
                    <!-- JS generated -->
                </div>
                <div class="slots-footer" id="slotsFooter" style="display: none;">
                    <button class="book-slot-btn" id="bookSlotBtn">
                        <i class="fas fa-calendar-check"></i>
                        <span>Book this slot</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Account Exists Modal -->
<div id="accountExistsModal" class="booking-modal-overlay" style="display: none;">
    <div class="booking-modal-container" style="max-width: 500px; padding: 40px;">
        <button class="booking-close-btn" onclick="closeAccountExistsModal()"><i class="fas fa-times"></i></button>
        
        <div style="padding: 32px;">
            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                <div style="width: 48px; height: 48px; border-radius: 50%; background: rgba(239, 68, 68, 0.1); display: flex; align-items: center; justify-content: center;">
                    <i class="fas fa-exclamation-triangle" style="color: #ef4444; font-size: 1.5rem;"></i>
                </div>
                <h2 style="font-size: 1.5rem; color: #1e293b; margin: 0;">Account Already Exists</h2>
            </div>
            
            <p style="color: #64748b; line-height: 1.6; margin-bottom: 24px;">
                An account with this email already exists. Please log in to book this session.
            </p>
            
            <div style="display: flex; gap: 12px; flex-direction: column;">
                <button type="button" class="btn btn-primary btn-full" onclick="handleLoginToBook()" style="justify-content: center;">
                    <i class="fas fa-sign-in-alt"></i>
                    <span>Login to Book This Slot</span>
                </button>
                <button type="button" class="btn btn-secondary btn-full" onclick="closeAccountExistsModal()" style="justify-content: center;">
                    <i class="fas fa-arrow-left"></i>
                    <span>Back</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Email Collection Modal (for non-logged-in users) -->
<div id="emailCollectionModal" class="booking-modal-overlay" style="display: none;">
    <div class="booking-modal-container" style="max-width: 900px; height: 600px; overflow-y: auto;">
        <button class="booking-close-btn" onclick="closeEmailCollectionModal()"><i class="fas fa-times"></i></button>
        
        <div class="booking-modal-content-wrapper">
            <form id="emailCollectionForm" style="height: 100%;">
                <div class="booking-modal-grid">
                    <!-- Left Column: Session Summary -->
                    <div class="summary-column" style="background: #f1f5f9;">
                        <div >
                            <h2 class="booking-modal-title" style="font-size: 1.75rem; color: #0f172a; margin-bottom: 4px;">Book Your Session</h2>
                            <p style="font-size: 0.9rem; color: #64748b; margin-bottom: 24px;">Review the session details below</p>
                        </div>

                        <div style="display: flex; flex-direction: column; gap: 20px;">
                            <!-- Session Recap -->
                            <div id="sessionRecap" style="padding: 24px; background: white; border-radius: 14px; border: 1px solid #e2e8f0; box-shadow: 0 1px 2px rgba(0,0,0,0.05); border-left: 4px solid #3b82f6;">
                                <span class="section-label" style="color: #3b82f6; margin-bottom: 16px; font-size: 0.8rem;">APPOINTMENT DETAILS</span>
                                <div style="display: flex; flex-direction: column; gap: 14px;">
                                    <div style="display: flex; align-items: center; gap: 14px;">
                                        <i class="far fa-calendar-alt" style="color: #64748b; font-size: 1.1rem; width: 20px;"></i>
                                        <span id="recapDate" style="font-size: 1rem; color: #1e293b; font-weight: 700;">--</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 14px;">
                                        <i class="far fa-clock" style="color: #64748b; font-size: 1.1rem; width: 20px;"></i>
                                        <span id="recapTime" style="font-size: 1rem; color: #1e293b; font-weight: 700;">--</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 14px;">
                                        <i class="fas fa-hourglass-half" style="color: #64748b; font-size: 1.1rem; width: 20px;"></i>
                                        <span id="recapLength" style="font-size: 1rem; color: #1e293b; font-weight: 700;">--</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Session Price -->
                            <div style="padding: 16px 20px; background: white; border-radius: 14px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0,0,0,0.05); margin-top: auto;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-weight: 700; color: #475569; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.02em;">Total Payable</span>
                                    <div style="text-align: right;">
                                        <div id="bookingPriceDisplay" style="font-size: 1.5rem; font-weight: 800; color: #10b981; line-height: 1;">
                                            {% if mentor_profile.first_session_free %}
                                                $0
                                            {% else %}
                                                ${{ mentor_profile.price_per_hour|floatformat:0 }}
                                            {% endif %}
                                        </div>
                                    </div>
                                </div>
                                <div id="bookingPriceNote" style="font-size: 0.8rem; color: #64748b; margin-top: 6px; font-weight: 500; display: none;">
                                    First session is free
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Right Column: User Input -->
                    <div class="input-column">
                        <div style="display: flex; flex-direction: column; gap: 20px;">
                            <span class="section-label">Complete Your Booking</span>
                            
                            <!-- Email Input -->
                            <div style="margin-top: -8px;">
                                <label style="display: block; font-weight: 700; color: #1e293b; margin-bottom: 6px; font-size: 0.9rem;">
                                    Email Address <span style="color: #ef4444;">*</span>
                                </label>
                                <input type="email" id="bookingEmailInput" class="form-input" placeholder="your@email.com" required style="width: 100%; max-width: 100%; padding: 12px 16px; border: 1px solid #e2e8f0; border-radius: 10px; font-size: 0.95rem; box-sizing: border-box;">
                                <div id="emailError" style="color: #ef4444; font-size: 0.85rem; margin-top: 4px; display: none;"></div>
                            </div>
                            
                            <!-- Note Input -->
                            <div>
                                <label style="display: block; font-weight: 700; color: #1e293b; margin-bottom: 6px; font-size: 0.9rem;">
                                    Message for Mentor (Optional)
                                </label>
                                <textarea id="bookingNoteInput" class="form-input" placeholder="What would you like to focus on?" rows="4" style="width: 100%; max-width: 100%; max-height: 200px; padding: 12px 16px; border: 1px solid #e2e8f0; border-radius: 10px; font-size: 0.95rem; resize: none; font-family: inherit; box-sizing: border-box; overflow-y: auto;"></textarea>
                            </div>

                            <div style="margin-top: 12px; padding: 16px; background: #fdf2f2; border-radius: 10px; border: 1px solid #fee2e2; display: none;" id="nonAuthBookingNotice">
                                <p style="font-size: 0.85rem; color: #991b1b; line-height: 1.5; margin: 0;">
                                    We'll send you an email to confirm your identity after booking.
                                </p>
                            </div>
                        </div>

                        <!-- Timezone Confirmation (Relocated) -->
                        <div class="timezone-section">
                            <span class="section-label" style="margin-bottom: 4px; color: #475569; font-size: 0.85rem; text-transform: none;">
                                Detected Timezone: <strong id="detectedTimezoneName" style="color: #1e293b; font-weight: 700;">Loading...</strong>
                                <p style="font-size: 0.85rem; color: #64748b; margin: 0 0 0 4px; font-weight: 500;">
                                    Make sure that the time under matches your real time.
                                </p>
                            </span>
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px; background: #f8fafc; border-radius: 12px; border: 1px solid #e2e8f0; box-shadow: 0 1px 2px rgba(0,0,0,0.05);">
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <div style="width: 40px; height: 40px; background: white; border-radius: 10px; display: flex; align-items: center; justify-content: center;">
                                        <i class="far fa-clock" style="color: #3b82f6; font-size: 1.2rem;"></i>
                                    </div>
                                    <div style="display: flex; flex-direction: column;">
                                        <span id="timezoneCurrentTime" class="timezone-current-time" style="font-size: 1.1rem; font-family: 'JetBrains Mono', 'Roboto Mono', monospace; font-variant-numeric: tabular-nums; color: #1e293b; letter-spacing: -0.02em;">--:--:-- --</span>
                                        <span id="timezoneCurrentDate" class="timezone-current-date" style="font-size: 0.8rem; color: #64748b; font-weight: 500;">--</span>
                                    </div>
                                </div>
                                <button type="button" id="correctTimeBtn" class="btn-correct-time" style="margin-left: 0; padding: 8px 14px; background: white; border-color: #cbd5e1; font-weight: 700; color: #475569;">Change my time</button>
                            </div>
                            <input type="hidden" id="bookingTimezoneValue" value="">
                        </div>
                        
                        <!-- Submit Button -->
                        <button type="submit" class="book-slot-btn" id="submitBookingBtn" style="width: 100%; height: 50px; font-size: 1.1rem; margin-top: auto; border-radius: 10px; background: #10b981; border: none; color: white; font-weight: 700; cursor: pointer; transition: all 0.2s;">
                            <i class="fas fa-calendar-check" style="margin-right: 8px;"></i>
                            <span>Confirm Booking</span>
                        </button>
                    </div>
                </div>
            </form>
        </div>
    </div>
</div>

{% include "dashboard_user/popups/time_correction_modal.html" %}

<style>
/* Modal CSS */
.booking-modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(15, 23, 42, 0.6);
    backdrop-filter: blur(4px);
    z-index: 10000;
    display: none;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}
.booking-modal-overlay.open {
    display: flex;
    opacity: 1;
}

/* Timezone Section Styles */
.timezone-section {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* Blink animation - exactly 3 blinks, slower */
@keyframes blinkThreeTimes {
    0%, 100% {
        color: #1e293b;
        background-color: transparent;
    }
    12.5%, 37.5%, 62.5% {
        color: #2563eb;
        background-color: #dbeafe;
    }
    25%, 50%, 75% {
        color: #1e293b;
        background-color: transparent;
    }
}

.timezone-blink,
.appointment-blink {
    animation: blinkThreeTimes 2.4s ease-in-out;
    animation-iteration-count: 1;
    padding: 2px 6px;
    border-radius: 4px;
    display: inline-block;
}
.timezone-label {
    display: block;
    font-weight: 600;
    color: #1e293b;
    font-size: 0.9rem;
}
.timezone-container {
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 12px;
    padding: 16px;
    transition: all 0.2s ease;
}
.timezone-clock-card {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 12px;
    padding: 12px 16px;
    background: white;
    border-radius: 10px;
    border: 1px solid #e2e8f0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}
.timezone-clock-info {
    display: flex;
    align-items: center;
    gap: 12px;
    flex: 1;
}
.timezone-clock-icon {
    color: #3b82f6;
    font-size: 1.25rem;
    background: rgba(59, 130, 246, 0.1);
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
}
.timezone-time-details {
    display: flex;
    flex-direction: column;
}
.timezone-current-time {
    font-size: 1rem;
    font-weight: 700;
    color: #1e293b;
    letter-spacing: -0.01em;
    white-space: nowrap;
}
.timezone-current-date {
    font-size: 0.8rem;
    color: #64748b;
    font-weight: 500;
}
.btn-correct-time {
    padding: 6px 12px;
    background: #f1f5f9;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    color: #475569;
    font-size: 0.75rem;
    font-weight: 600;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.2s;
    margin-left: 8px;
    max-width: 150px;
}
.btn-correct-time:hover {
    background: #e2e8f0;
    color: #1e293b;
    border-color: #cbd5e1;
}
.timezone-detected-info {
    font-size: 0.8rem;
    color: #64748b;
    padding-left: 4px;
    display: flex;
    align-items: center;
    gap: 6px;
}
.timezone-detected-info strong {
    color: #3b82f6;
    font-weight: 600;
}

.booking-modal-content-wrapper {
    padding: 0;
    min-height: 100%;
    box-sizing: border-box;
}
.booking-modal-grid {
    display: grid;
    grid-template-columns: 1fr 1.2fr;
    min-height: 600px;
    align-items: stretch;
}
.input-column {
    padding: 32px;
    display: flex;
    flex-direction: column;
    gap: 16px;
}
.summary-column {
    background: #f8fafc;
    border-right: 1px solid #e2e8f0;
    padding: 32px;
    display: flex;
    flex-direction: column;
    gap: 16px;
}
.section-label {
    font-size: 0.75rem;
    font-weight: 700;
    color: #94a3b8;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 8px;
    display: block;
}
.timezone-placeholder-text {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #94a3b8;
    font-size: 0.95rem;
    line-height: 1.5;
    text-align: center;
    padding: 0 20px;
}
.time-correction-desc {
    color: #64748b;
    margin-bottom: 28px;
    font-size: 0.95rem;
    line-height: 1.6;
}
.time-correction-form-group {
    display: flex;
    flex-direction: column;
    gap: 24px;
}
.time-input-container {
    display: flex;
    flex-direction: column;
}
.time-input-label {
    display: block;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 10px;
    font-size: 0.95rem;
}
.required-asterisk {
    color: #ef4444;
}
.time-input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
}
.modern-time-input {
    width: 100%;
    padding: 14px 16px 14px 44px;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: 600;
    color: #1e293b;
    box-sizing: border-box;
    transition: all 0.2s;
    background: #f8fafc;
}
.modern-time-input:focus {
    outline: none;
    border-color: #3b82f6;
    background: white;
    box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.1);
}
.input-icon {
    position: absolute;
    left: 16px;
    top: 50%;
    transform: translateY(-50%);
    color: #94a3b8;
    font-size: 1.1rem;
    pointer-events: none;
}
.modern-time-input:hover {
    border-color: #cbd5e1;
    background: #f1f5f9;
}
.time-input-helper {
    font-size: 0.8rem;
    color: #94a3b8;
    margin-top: 8px;
    font-style: italic;
}
.timezone-preview-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: transparent;
    padding: 0;
    border-radius: 0;
    border: none;
    overflow: hidden;
}
.preview-header {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.85rem;
    color: #1e40af;
    font-weight: 600;
    margin-bottom: 12px;
}
.timezone-options-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-height: 200px;
    overflow-y: auto;
    padding-right: 4px;
}
.timezone-options-list::-webkit-scrollbar {
    width: 6px;
}
.timezone-options-list::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.05);
    border-radius: 10px;
}
.timezone-options-list::-webkit-scrollbar-thumb {
    background: #bfdbfe;
    border-radius: 10px;
}

/* Dynamically injected timezone items */
.timezone-option-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px;
    background: white;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}
.timezone-option-item:hover {
    border-color: #3b82f6;
    transform: translateY(-1px);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
}
.timezone-option-item.selected {
    border-color: #3b82f6;
    background: #f0f7ff;
    box-shadow: 0 0 0 1px #3b82f6;
}
.timezone-option-radio {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: #3b82f6;
}
.timezone-option-content {
    flex: 1;
}
.timezone-option-name {
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 2px;
    font-size: 0.95rem;
}
.timezone-option-id {
    font-size: 0.8rem;
    color: #64748b;
    font-weight: 500;
}
.timezone-option-offset {
    font-size: 0.9rem;
    color: #3b82f6;
    font-weight: 700;
    padding: 4px 8px;
    background: white;
    border-radius: 6px;
    border: 1px solid #dbeafe;
}

.time-correction-actions {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
    margin-top: 8px;
}
.btn-cancel-correction {
    padding: 12px 24px;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 10px;
    color: #64748b;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}
.btn-cancel-correction:hover {
    background: #f8fafc;
    border-color: #cbd5e1;
    color: #1e293b;
}
.btn-confirm-correction {
    padding: 12px 24px;
    background: #3b82f6;
    border: none;
    border-radius: 10px;
    color: white;
    font-size: 0.95rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.3);
}
.btn-confirm-correction:hover:not(:disabled) {
    background: #2563eb;
    box-shadow: 0 6px 10px -1px rgba(59, 130, 246, 0.4);
    transform: translateY(-1px);
}
.btn-confirm-correction:disabled {
    background: #94a3b8;
    opacity: 0.6;
    cursor: not-allowed;
    box-shadow: none;
}

.booking-modal-container {
    background: white;
    width: 90%;
    max-width: 1000px;
    height: 600px;
    border-radius: 20px;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.booking-close-btn {
    position: absolute;
    top: 16px;
    right: 16px;
    background: rgba(15, 23, 42, 0.1); /* Subtle dark circle in light modal */
    border: 1px solid rgba(15, 23, 42, 0.1);
    color: #64748b;
    font-size: 1rem;
    cursor: pointer;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 20;
}
.booking-close-btn:hover {
    background: #ef4444;
    border-color: #ef4444;
    color: white;
    transform: rotate(90deg) scale(1.1);
    box-shadow: 0 0 15px rgba(239, 68, 68, 0.4);
}

.booking-grid {
    display: grid;
    grid-template-columns: 300px 1fr 320px; /* Fixed width for slots col to prevent jumping */
    height: 100%;
    max-height: 100%; /* Ensure grid doesn't exceed container */
}

/* Sidebar */
.booking-sidebar {
    padding: 32px;
    border-right: 1px solid #e2e8f0;
    background: #f8fafc;
}
.booking-mentor-mini {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 32px;
}
.booking-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    object-fit: cover;
}
.booking-avatar-placeholder {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: #3b82f6;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
}
.booking-mentor-name { color: #64748b; font-size: 0.9rem; font-weight: 500; }
.booking-session-name { color: #1e293b; font-size: 1.1rem; font-weight: 700; margin-top: 2px; }

.booking-meta { display: flex; flex-direction: column; gap: 12px; margin-bottom: 32px; }
.booking-meta-item { display: flex; align-items: center; gap: 10px; color: #475569; font-weight: 500; }
.booking-meta-item i { color: #94a3b8; width: 20px; text-align: center; }

.booking-desc { font-size: 0.9rem; color: #64748b; line-height: 1.6; }

/* Selection Summary */
.booking-selection-summary {
    background: #f8fafc;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 24px;
    border: 1px solid #e2e8f0;
}
.summary-label {
    text-transform: uppercase;
    font-size: 0.7rem;
    font-weight: 700;
    color: #94a3b8;
    letter-spacing: 0.05em;
    margin-bottom: 10px;
}
.summary-details {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.summary-item {
    display: flex;
    align-items: center;
    gap: 10px;
    color: #1e293b;
    font-size: 0.95rem;
    font-weight: 600;
}
.summary-item i {
    color: #3b82f6;
    width: 16px;
    font-size: 0.9rem;
}

/* Calendar */
.booking-calendar-col {
    padding: 32px;
    flex: 1;
    overflow-y: auto;
}
.booking-title { font-size: 1.5rem; color: #1e293b; margin-bottom: 24px; }

.calendar-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 24px;
}
.current-month-label { font-size: 1.1rem; font-weight: 600; color: #1e293b; }
.cal-nav-btn {
    background: transparent;
    border: 1px solid #e2e8f0;
    width: 32px; height: 32px;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
    color: #64748b;
}
.cal-nav-btn:hover { background: #f1f5f9; color: var(--mp-primary); }

.calendar-grid-header {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    text-align: center;
    font-size: 0.75rem;
    font-weight: 600;
    color: #94a3b8;
    text-transform: uppercase;
    margin-bottom: 12px;
}
.calendar-days {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    row-gap: 8px;
}
.cal-day {
    height: 44px;
    width: 44px;
    margin: 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    cursor: pointer;
    font-size: 0.95rem;
    font-weight: 500;
    color: #334155;
    transition: all 0.2s;
    position: relative;
}
.cal-day:hover:not(.empty):not(.disabled) {
    background: #eff6ff; /* Light Blue */
    color: #3b82f6;
    font-weight: 600;
}
.cal-day.selected {
    background: #3b82f6 !important;
    color: white !important;
}
.cal-day.disabled {
    color: #cbd5e1;
    cursor: default;
}
.cal-day.has-slots:not(.disabled):not(.selected) {
    background: #eff6ff; /* Light Blue tint */
    color: #3b82f6;
    font-weight: 600;
}
.cal-day.has-slots:not(.selected)::after {
    content: '';
    position: absolute;
    bottom: 6px;
    width: 4px; height: 4px;
    background: #3b82f6;
    border-radius: 50%;
}
.cal-day.selected.has-slots::after { background: white; }
.cal-day.today {
    background: #f1f5f9; /* Neutral gray for today since it's disabled */
    border: 1px solid #cbd5e1;
    font-weight: 700;
}

/* Slots Col */
.booking-slots-col {
    width: 320px;
    padding: 32px;
    border-left: 1px solid #e2e8f0;
    display: flex;
    flex-direction: column;
    height: 100%;
    max-height: 100%; /* Force height to match modal */
    min-height: 0;
    background: white;
    box-sizing: border-box;
    overflow: hidden; /* Prevent the column itself from scrolling */
}
.slots-header-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
    flex-shrink: 0; /* Prevent header from shrinking */
}
.slots-date-label {
    font-size: 1rem;
    color: #475569;
    margin: 0;
}

@keyframes slideIn {
    from { opacity: 0; transform: translateX(10px); }
    to { opacity: 1; transform: translateX(0); }
}

.slots-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0; /* Critical for scroll inside flex */
    scrollbar-width: thin; /* Firefox: thin scrollbar */
    scrollbar-color: #cbd5e1 transparent; /* Firefox: thumb and track */
}
.slots-list::-webkit-scrollbar {
    width: 4px; /* Super thin width */
}
.slots-list::-webkit-scrollbar-track {
    background: transparent;
}
.slots-list::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 10px;
}
.slots-list::-webkit-scrollbar-thumb:hover {
    background: #94a3b8;
}
.time-slot-btn {
    padding: 14px;
    border: 1px solid #3b82f6; /* Default Blue Border */
    border-radius: 12px;
    background: #eff6ff; /* Default Light Blue Background */
    color: #3b82f6; /* Default Blue Text */
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    text-align: center;
    box-sizing: border-box;
}
.time-slot-btn:hover {
    border-color: #2563eb; /* Darker Blue Border */
    background: #dbeafe; /* Light Blue Background */
    color: #2563eb; /* Darker Blue Text */
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}
.time-slot-btn.selected {
    border-color: #3b82f6;
    background: #3b82f6; /* High contrast Blue selection */
    color: white; /* White text for visibility */
    box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.3);
}
.time-slot-btn.selected:hover {
    background: #2563eb;
    border-color: #2563eb;
    color: white;
}

.slots-footer {
    padding-top: 20px;
    border-top: 1px solid #e2e8f0;
    margin-top: 20px;
    flex-shrink: 0; /* Keep footer size fixed */
}

.book-slot-btn {
    width: 100%;
    padding: 14px 20px;
    background: var(--mp-primary); /* Green button */
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 4px 6px rgba(16, 185, 129, 0.2);
}
.book-slot-btn:hover {
    background: #059669;
    box-shadow: 0 6px 12px rgba(16, 185, 129, 0.3);
}
.book-slot-btn:active {
    transform: scale(0.98);
}

/* Error State */
.booking-error-state {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    padding: 40px;
    min-height: 400px;
}

.booking-error-content {
    text-align: center;
    max-width: 400px;
    width: 100%;
}

.booking-error-icon {
    font-size: 64px;
    color: #ef4444;
    margin-bottom: 24px;
}

.booking-success-state {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    padding: 32px 40px;
    min-height: 400px;
    overflow-y: auto;
}

.booking-success-content {
    text-align: center;
    max-width: 500px;
    width: 100%;
}

.booking-success-icon {
    font-size: 56px;
    color: #10b981;
    margin-bottom: 16px;
}

.booking-success-title {
    font-size: 1.4rem;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 12px;
}

.booking-success-message {
    font-size: 0.95rem;
    color: #64748b;
    margin-bottom: 16px;
    line-height: 1.5;
}

.booking-success-email {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 10px 18px;
    background: #f1f5f9;
    border-radius: 8px;
    margin-bottom: 16px;
    font-size: 0.9rem;
    color: #475569;
}

.booking-success-email i {
    color: #3b82f6;
}

.booking-success-instructions {
    text-align: left;
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
}

.booking-success-instructions h3 {
    font-size: 0.95rem;
    font-weight: 600;
    color: #1e293b;
    margin-bottom: 10px;
}

.booking-success-instructions ol {
    margin: 0;
    padding-left: 20px;
    color: #64748b;
    font-size: 0.85rem;
    line-height: 1.6;
}

.booking-success-instructions li {
    margin-bottom: 6px;
}

.booking-success-actions {
    margin-bottom: 0;
}

.booking-success-btn {
    background: #10b981;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    transition: background-color 0.2s;
    justify-content: center;
}

.booking-success-btn:hover {
    background: #059669;
}

.booking-error-title {
    font-size: 24px;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 16px;
}

.booking-error-message {
    font-size: 16px;
    color: #64748b;
    line-height: 1.6;
    margin-bottom: 32px;
}

.booking-error-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 12px 24px;
    background: #3b82f6;
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s;
    justify-content: center;
}

.booking-error-btn:hover {
    background: #2563eb;
    transform: translateY(-1px);
    box-shadow: 0 4px 6px rgba(59, 130, 246, 0.3);
}

.booking-error-btn:active {
    transform: translateY(0);
}

/* Responsiveness for Modal */
@media (max-width: 900px) {
    .booking-grid {
        grid-template-columns: 250px 1fr;
    }
    .booking-slots-col {
        position: absolute;
        top: 0; right: 0; bottom: 0;
        background: white;
        box-shadow: -10px 0 20px rgba(0,0,0,0.1);
        z-index: 10;
    }
}
@media (max-width: 768px) {
    .booking-modal-container {
        height: 100%;
        max-height: 100%;
        width: 100%;
        border-radius: 0;
    }
    .booking-grid {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
    }
    .booking-sidebar {
        padding: 20px;
        border-right: none;
        border-bottom: 1px solid #e2e8f0;
    }
    .booking-mentor-mini { margin-bottom: 16px; }
    .booking-meta { flex-direction: row; gap: 20px; margin-bottom: 16px; font-size: 0.85rem; }
    .booking-desc { display: none; } /* Hide desc on mobile */
    .booking-slots-col {
        width: 100%;
        border-left: none;
    }
}
</style>

<!-- Data Injection for JS -->
{{ mentor_profile.one_time_slots|json_script:"one-time-slots-data" }}
{{ mentor_profile.recurring_slots|json_script:"recurring-slots-data" }}
<script id="mentor-session-length" type="application/json">{{ mentor_profile.session_length|default:60 }}</script>


<script>
    // --- Booking Logic Variables (must be declared first) ---
    // Get user authentication status from Django template
    const isUserAuthenticated = {% if user.is_authenticated %}true{% else %}false{% endif %};
    const userRole = {% if user.is_authenticated %}'{{ user.profile.role|default:"" }}'{% else %}null{% endif %};
    const mentorId = {{ mentor_profile.user.id }};
    const mentorFirstSessionFree = {% if mentor_profile.first_session_free %}true{% else %}false{% endif %};
    const mentorFirstSessionLength = {{ mentor_profile.first_session_length|default:30 }};
    const mentorSessionLength = {{ mentor_profile.session_length|default:60 }};
    const mentorPricePerHour = {{ mentor_profile.price_per_hour|default_if_none:"null" }};
    const isFirstSession = {% if user.is_authenticated %}{% if is_first_session %}true{% else %}false{% endif %}{% else %}true{% endif %}; // For non-authenticated users, always assume first session
    const firstSessionLengthDiffers = mentorFirstSessionLength !== mentorSessionLength;
    
    // User's selected timezone from profile (if authenticated)
    const userSelectedTimezone = {% if user.is_authenticated and user.profile.selected_timezone %}'{{ user.profile.selected_timezone }}'{% else %}null{% endif %};
    
    // Detected timezone (will be set on modal open)
    let detectedTimezone = null;
    let selectedTimezone = null;
    let timezoneClockInterval = null;
    let selectedTimezoneClockInterval = null;
    
    // Store email for use in success handler
    let submittedEmail = null;
    
    // --- Data & State ---
    let availabilityData;
    let sessionLengthMinutes = 60; // Default session length
    let currentDate = new Date(); // To track month view
    let selectedDate = null;
    let selectedSlot = null; // Track selected time slot
    let preservedBookingData = null; // Store booking data when account exists
    
    // --- DOM Elements ---
    let modal, currentMonthLabel, calendarDays, slotsCol, slotsList, selectedDateLabel, prevMonthBtn, nextMonthBtn, slotsFooter, bookSlotBtn;

    document.addEventListener('DOMContentLoaded', function() {
        // Initialize timezone from user profile if authenticated (before any other operations)
        if (isUserAuthenticated && userSelectedTimezone) {
            selectedTimezone = userSelectedTimezone;
            // Also set detected timezone for consistency
            try {
                detectedTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            } catch (e) {
                detectedTimezone = 'UTC';
            }
        } else {
            // For non-authenticated users, detect timezone
            try {
                detectedTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                selectedTimezone = detectedTimezone;
            } catch (e) {
                detectedTimezone = 'UTC';
                selectedTimezone = 'UTC';
            }
        }
        
        // Safe access to data script
        const oneTimeData = document.getElementById('one-time-slots-data');
        const recurringData = document.getElementById('recurring-slots-data');
        const sessionLengthEl = document.getElementById('mentor-session-length');
        
        // Get session length
        if (sessionLengthEl) {
            try {
                sessionLengthMinutes = parseInt(JSON.parse(sessionLengthEl.textContent)) || 60;
            } catch (e) {
                sessionLengthMinutes = 60;
            }
        }
        
        // Parse availability data
        let oneTimeSlots = [];
        let recurringSlots = [];
        
        if (oneTimeData) {
            try {
                oneTimeSlots = JSON.parse(oneTimeData.textContent) || [];
            } catch (e) {
                console.error('Error parsing one-time slots:', e);
            }
        }
        
        if (recurringData) {
            try {
                recurringSlots = JSON.parse(recurringData.textContent) || [];
            } catch (e) {
                console.error('Error parsing recurring slots:', e);
            }
        }
        
        // Filter one-time slots to only include future, non-booked slots
        const now = new Date();
        oneTimeSlots = oneTimeSlots.filter(slot => {
            if (!slot.start || !slot.end) return false;
            if (slot.booked === true) return false;
            
            try {
                const endDate = new Date(slot.end.replace('Z', '+00:00'));
                // Only include slots that end in the future
                return endDate > now;
            } catch (e) {
                return false;
            }
        });
        
        availabilityData = {
            one_time_slots: oneTimeSlots,
            recurring_slots: recurringSlots
        };
        
        modal = document.getElementById('bookingModal');
        currentMonthLabel = document.getElementById('currentMonthLabel');
        calendarDays = document.getElementById('calendarDays');
        slotsCol = document.getElementById('slotsCol');
        slotsList = document.getElementById('slotsList');
        selectedDateLabel = document.getElementById('selectedDateLabel');
        prevMonthBtn = document.getElementById('prevMonth');
        nextMonthBtn = document.getElementById('nextMonth');
        slotsFooter = document.getElementById('slotsFooter');
        bookSlotBtn = document.getElementById('bookSlotBtn');

        bookingSummary = document.getElementById('bookingSummary');
        summaryDate = document.getElementById('summaryDate');
        summaryTimeRow = document.getElementById('summaryTimeRow');
        summaryTime = document.getElementById('summaryTime');
        
        // --- Events ---
        if (prevMonthBtn) prevMonthBtn.onclick = () => {
            currentDate.setMonth(currentDate.getMonth() - 1);
            renderCalendar();
        };
        if (nextMonthBtn) nextMonthBtn.onclick = () => {
            currentDate.setMonth(currentDate.getMonth() + 1);
            renderCalendar();
        };
        
        // Close on click outside
        if (modal) modal.addEventListener('click', (e) => {
            if (e.target === modal) closeBookingModal();
        });
        
        // Close on Escape key - close only the topmost modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                handleEscapeKey();
            }
        });
        
        // Check for URL parameters to open booking modal with selected slot (after login redirect)
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('open_booking') === 'true') {
            const slotStart = urlParams.get('slot_start');
            const slotEnd = urlParams.get('slot_end');
            const slotId = urlParams.get('slot_id');
            const recurringId = urlParams.get('recurring_id');
            const instanceDate = urlParams.get('instance_date');
            const adjustedEnd = urlParams.get('adjusted_end');
            
            if (slotStart && slotEnd) {
                // Set selected slot BEFORE opening modal (so openBookingModal doesn't clear it)
                const startDt = new Date(slotStart);
                // Store as Date object (consistent with selectDate function)
                const dateObj = new Date(startDt.getFullYear(), startDt.getMonth(), startDt.getDate());
                selectedDate = dateObj;
                
                // Set currentDate to the month of the selected date so calendar shows correct month
                currentDate = new Date(startDt.getFullYear(), startDt.getMonth(), 1);
                
                selectedSlot = {
                    start: slotStart,
                    end: slotEnd,
                    adjustedEnd: adjustedEnd || slotEnd,
                    useAdjustedEndTime: !!adjustedEnd && adjustedEnd !== slotEnd,
                    type: slotId ? 'one_time' : 'recurring',
                    availability_slot_id: slotId,
                    recurring_id: recurringId,
                    instance_date: instanceDate
                };
                
                // Open booking modal (but don't let it reset our selected slot)
                if (!modal) return;
                modal.classList.add('open');
                document.body.style.overflow = 'hidden';
                
                // Render calendar with the correct month
                renderCalendar();
                
                // Update selected date label - use Date object for formatting
                const dateOptions = {weekday: 'long', month: 'short', day: 'numeric'};
                const formattedDate = dateObj.toLocaleDateString([], dateOptions);
                if (selectedDateLabel) {
                    selectedDateLabel.textContent = formattedDate;
                }
                
                // Show slots column and render slots (pass Date object)
                if (slotsCol) slotsCol.style.display = 'flex';
                renderSlots(dateObj);
                
                // Show footer and summary since slot is selected
                if (slotsFooter) slotsFooter.style.display = 'block';
                if (bookingSummary) bookingSummary.style.display = 'block';
                if (summaryDate) summaryDate.textContent = formattedDate;
                if (summaryTimeRow) {
                    // Format time for summary
                    const formatTime = (dateStr) => {
                        const d = new Date(dateStr);
                        let hours = d.getHours();
                        const minutes = d.getMinutes();
                        const ampm = hours >= 12 ? 'pm' : 'am';
                        hours = hours % 12;
                        hours = hours ? hours : 12;
                        const mins = minutes < 10 ? '0' + minutes : minutes;
                        return `${hours}:${mins} ${ampm}`;
                    };
                    const endDt = new Date(selectedSlot.end);
                    const timeText = `${formatTime(selectedSlot.start)} - ${formatTime(selectedSlot.end)}`;
                    if (summaryTime) summaryTime.textContent = timeText;
                    summaryTimeRow.style.display = 'flex';
                }
                
                // Highlight the selected slot after slots are rendered
                setTimeout(() => {
                    const slots = getSlotsForDate(dateObj);
                    // Find the slot that matches our selected slot
                    const matchingSlotIndex = slots.findIndex(slot => {
                        // Compare ISO strings - normalize both to ensure comparison works
                        const slotStartISO = slot.start ? new Date(slot.start).toISOString() : null;
                        const targetStartISO = new Date(slotStart).toISOString();
                        return slotStartISO === targetStartISO;
                    });
                    
                    if (matchingSlotIndex !== -1) {
                        const slotButtons = slotsList.querySelectorAll('.time-slot-btn');
                        if (slotButtons[matchingSlotIndex]) {
                            slotButtons[matchingSlotIndex].classList.add('selected');
                            slotButtons[matchingSlotIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                            // Update selectedSlot to match the slot from the list (preserves all slot data)
                            selectedSlot = slots[matchingSlotIndex];
                        }
                    }
                }, 500);
                
                // Clean up URL parameters
                const newUrl = window.location.pathname;
                window.history.replaceState({}, '', newUrl);
            } else {
                // No slot specified, just open modal normally
                openBookingModal();
            }
        }
        
        // Book slot button handler
        if (bookSlotBtn) {
            bookSlotBtn.addEventListener('click', function() {
                if (selectedSlot && selectedDate) {
                    handleBookingClick();
                }
            });
        }
        
        // Email collection form handler
        const emailCollectionForm = document.getElementById('emailCollectionForm');
        if (emailCollectionForm) {
            emailCollectionForm.addEventListener('submit', function(e) {
                e.preventDefault();
                handleEmailCollectionSubmit();
            });
        }
        
        // Time correction button
        const correctTimeBtn = document.getElementById('correctTimeBtn');
        if (correctTimeBtn) {
            correctTimeBtn.addEventListener('click', function() {
                openTimeCorrectionModal();
            });
        }
    });

    // --- Modal Logic ---
    function openBookingModal() {
        if (!modal) return; // Guard clause
        
        // Initialize timezone from user profile if authenticated
        if (isUserAuthenticated && userSelectedTimezone) {
            selectedTimezone = userSelectedTimezone;
            // Also set detected timezone for consistency
            try {
                detectedTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            } catch (e) {
                detectedTimezone = 'UTC';
            }
        } else {
            // For non-authenticated users, detect timezone
            try {
                detectedTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                selectedTimezone = detectedTimezone;
            } catch (e) {
                detectedTimezone = 'UTC';
                selectedTimezone = 'UTC';
            }
        }
        
        // Reset State on Open
        currentDate = new Date(); // Reset to current month
        selectedDate = null;      // Clear selection
        selectedSlot = null;      // Clear slot selection
        if (slotsCol) slotsCol.style.display = 'none'; // Hide slots initially
        if (slotsFooter) slotsFooter.style.display = 'none'; // Hide footer
        if (bookingSummary) bookingSummary.style.display = 'none'; // Hide summary
        
        modal.classList.add('open');
        document.body.style.overflow = 'hidden'; // Prevent background scroll
        renderCalendar();
    }

    // Handle ESC key - close only the topmost visible modal
    function handleEscapeKey() {
        // Helper function to check if modal is visible
        function isModalVisible(modalElement) {
            if (!modalElement) return false;
            const display = modalElement.style.display;
            const computedDisplay = window.getComputedStyle(modalElement).display;
            // Modal is visible if display is not 'none' (could be 'flex', '', or other)
            return display !== 'none' && computedDisplay !== 'none';
        }
        
        // Check modals in order from highest z-index to lowest
        // 1. Time Correction Modal (z-index: 10001) - highest
        const timeCorrectionModal = document.getElementById('timeCorrectionModal');
        if (isModalVisible(timeCorrectionModal)) {
            if (typeof closeTimeCorrectionModal === 'function') {
                closeTimeCorrectionModal();
            }
            return;
        }
        
        // 2. Account Exists Modal (z-index: 10000)
        const accountExistsModal = document.getElementById('accountExistsModal');
        if (isModalVisible(accountExistsModal)) {
            closeAccountExistsModal();
            return;
        }
        
        // 3. Email Collection Modal / Book Your Session (z-index: 10000)
        const emailCollectionModal = document.getElementById('emailCollectionModal');
        if (isModalVisible(emailCollectionModal)) {
            closeEmailCollectionModal();
            return;
        }
        
        // 4. Booking Modal / Select a Date & Time (z-index: 10000) - base
        if (modal && modal.classList.contains('open')) {
            closeBookingModal();
            return;
        }
    }
    
    function closeBookingModal() {
        if (!modal) return;
        modal.classList.remove('open');
        document.body.style.overflow = '';
        // State is reset on next open, but good to clear view
        selectedDate = null;
        selectedSlot = null;
        if (slotsCol) slotsCol.style.display = 'none';
        if (slotsFooter) slotsFooter.style.display = 'none';
        if (bookingSummary) bookingSummary.style.display = 'none';
        hideBookingError(); // Hide error state when closing
        hideBookingSuccess(); // Hide success state when closing
        renderCalendar();
        // Refresh the page when modal is closed
        window.location.reload();
    }
    
    function closeBookingModalFromSuccess() {
        // Close modal and refresh page when closing from success state
        if (!modal) return;
        modal.classList.remove('open');
        document.body.style.overflow = '';
        // Immediately refresh the page
        window.location.reload();
    }
    
    function showBookingError() {
        const errorState = document.getElementById('bookingErrorState');
        const mainContent = document.getElementById('bookingMainContent');
        
        if (errorState) errorState.style.display = 'flex';
        if (mainContent) mainContent.style.display = 'none';
    }
    
    function hideBookingError() {
        const errorState = document.getElementById('bookingErrorState');
        const mainContent = document.getElementById('bookingMainContent');
        
        if (errorState) errorState.style.display = 'none';
        if (mainContent) mainContent.style.display = 'grid';
    }
    
    function showBookingSuccess(email, isNewUser) {
        const mainContent = document.getElementById('bookingMainContent');
        const successState = document.getElementById('bookingSuccessState');
        const emailCollectionModal = document.getElementById('emailCollectionModal');
        
        // Hide main content and email collection modal
        if (mainContent) mainContent.style.display = 'none';
        if (emailCollectionModal) emailCollectionModal.style.display = 'none';
        
        // Show success state
        if (successState) {
            successState.style.display = 'flex';
            
            // Update success message with session date and time (using corrected timezone)
            const successMessage = document.getElementById('bookingSuccessMessage');
            if (successMessage && selectedSlot && selectedDate) {
                // Use selectedTimezone or fallback to browser default
                const tz = selectedTimezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
                
                let dateStr = '';
                let timeStr = '';
                
                // Format date in current timezone
                try {
                    const dateOptions = { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric',
                        timeZone: tz
                    };
                    const slotStart = new Date(selectedSlot.start);
                    dateStr = new Intl.DateTimeFormat('en-US', dateOptions).format(slotStart);
                } catch (e) {
                    const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                    dateStr = selectedDate.toLocaleDateString('en-US', dateOptions);
                }
                
                // Format time in current timezone
                try {
                    const timeOptions = { 
                        hour: 'numeric', 
                        minute: '2-digit', 
                        hour12: true,
                        timeZone: tz
                    };
                    const formatter = new Intl.DateTimeFormat('en-US', timeOptions);
                    const startStr = formatter.format(new Date(selectedSlot.start)).toLowerCase();
                    
                    // End time depends on whether we use adjusted (first session) or regular end
                    const actualEnd = selectedSlot.useAdjustedEndTime && selectedSlot.adjustedEnd 
                        ? new Date(selectedSlot.adjustedEnd) 
                        : new Date(selectedSlot.end);
                    
                    const endStr = formatter.format(actualEnd).toLowerCase();
                    timeStr = `${startStr} - ${endStr}`;
                } catch (e) {
                    timeStr = selectedSlot.time || '';
                }
                
                if (dateStr && timeStr) {
                    successMessage.innerHTML = `A confirmation email has been sent to your email address.<br><br><strong>Session Details:</strong><br>${dateStr}<br>${timeStr}`;
                } else {
                    successMessage.textContent = 'A confirmation email has been sent to your email address.';
                }
            } else if (successMessage) {
                successMessage.textContent = 'A confirmation email has been sent to your email address.';
            }
            
            // Set email
            const emailText = document.getElementById('bookingSuccessEmailText');
            const emailDiv = document.getElementById('bookingSuccessEmail');
            if (emailText && emailDiv && email) {
                emailText.textContent = email;
                emailDiv.style.display = 'flex';
            } else if (emailDiv) {
                emailDiv.style.display = 'none';
            }
            
            // Show instructions for new users (not registered yet)
            const instructionsDiv = document.getElementById('bookingSuccessInstructions');
            if (instructionsDiv) {
                if (isNewUser) {
                    instructionsDiv.style.display = 'block';
                } else {
                    instructionsDiv.style.display = 'none';
                }
            }
            
            // Show "View My Sessions" button for logged-in users (existing registered users)
            const actionsDiv = document.getElementById('bookingSuccessActions');
            if (actionsDiv) {
                if (isUserAuthenticated && !isNewUser) {
                    actionsDiv.style.display = 'block';
                } else {
                    actionsDiv.style.display = 'none';
                }
            }
        }
    }
    
    function hideBookingSuccess() {
        const successState = document.getElementById('bookingSuccessState');
        const mainContent = document.getElementById('bookingMainContent');
        
        if (successState) successState.style.display = 'none';
        if (mainContent) mainContent.style.display = 'grid';
    }
    
    function closeSlots() {
        if (slotsCol) slotsCol.style.display = 'none';
        if (slotsFooter) slotsFooter.style.display = 'none';
        if (bookingSummary) bookingSummary.style.display = 'none';
        selectedDate = null;
        selectedSlot = null;
        renderCalendar(); // Redraws calendar to remove 'selected' class
    }
    
    // Close on click outside
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeBookingModal();
    });    
        // --- Calendar Logic ---
    function renderCalendar() {
        if (!calendarDays) return;
        
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();

        // Update Header
        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        if (currentMonthLabel) currentMonthLabel.textContent = `${monthNames[month]} ${year}`;

        // Days calculation
        const firstDayOfMonth = new Date(year, month, 1).getDay(); // 0 (Sun) - 6 (Sat)
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        
        // Use a temp date for checking availability
        const today = new Date();
        today.setHours(0,0,0,0);

        calendarDays.innerHTML = '';

        // Empty cells for previous month padding
        for (let i = 0; i < firstDayOfMonth; i++) {
            const emptyCell = document.createElement('div');
            emptyCell.classList.add('cal-day', 'empty');
            calendarDays.appendChild(emptyCell);
        }

        // Days
        for (let day = 1; day <= daysInMonth; day++) {
            const dayEl = document.createElement('div');
            dayEl.classList.add('cal-day');
            dayEl.textContent = day;
            
            const checkDate = new Date(year, month, day);
            checkDate.setHours(0,0,0,0);

            // Disable past dates and today
            if (checkDate <= today) {
                dayEl.classList.add('disabled');
                if (checkDate.getTime() === today.getTime()) {
                    dayEl.classList.add('today');
                }
            } else {
                // Check Availability
                if (hasAvailability(checkDate)) {
                    dayEl.classList.add('has-slots');
                }
                
                dayEl.onclick = () => selectDate(checkDate, dayEl);
            }

            // Selected State
            if (selectedDate && checkDate.getTime() === selectedDate.getTime()) {
                dayEl.classList.add('selected');
            }

            calendarDays.appendChild(dayEl);
        }
    }

    // --- Slot Calculation Logic ---
    function hasAvailability(date) {
        if (!availabilityData) return false;
        
        // Use selectedTimezone or fallback
        const tz = selectedTimezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
        
        // Get the YYYY-MM-DD that this calendar day represents
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const dateStr = `${year}-${month}-${day}`;
        
        const now = new Date();
        
        // Use Intl.DateTimeFormat with a specific timezone to get the correct YYYY-MM-DD for slots
        const slotDateFormatter = new Intl.DateTimeFormat('en-CA', { 
            year: 'numeric', month: '2-digit', day: '2-digit', timeZone: tz 
        });
        
        // Check if it's "today" in the target timezone
        const nowDateStrInTz = slotDateFormatter.format(now);
        const isTodayInTz = dateStr === nowDateStrInTz;
        
        // 1. One-Time Check
        const hasOneTime = availabilityData.one_time_slots.some(slot => {
            if (!slot.start || !slot.end) return false;
            if (slot.booked === true) return false;
            
            try {
                const slotStart = new Date(slot.start.replace('Z', '+00:00'));
                const slotEnd = new Date(slot.end.replace('Z', '+00:00'));
                
                // Convert slot date to target timezone for comparison
                const slotDateStr = slotDateFormatter.format(slotStart);
                
                if (slotDateStr !== dateStr) return false;
                
                // For today, ensure the slot end is in the future
                // For future dates, any slot is fine
                if (isTodayInTz) {
                    return slotEnd > now;
                } else {
                    return slotEnd > now; // Still check future for safety
                }
            } catch (e) {
                return false;
            }
        });
        if (hasOneTime) return true;

        // 2. Recurring Check
        // Use Intl.DateTimeFormat to get the day name and day of month in the target timezone
        const dayName = new Intl.DateTimeFormat('en-US', { weekday: 'long', timeZone: tz }).format(date).toLowerCase();
        const dayOfMonth = parseInt(new Intl.DateTimeFormat('en-US', { day: 'numeric', timeZone: tz }).format(date));
        
        const hasRecurring = availabilityData.recurring_slots.some(rule => {
            if (!rule || !rule.type) return false;
            
            const skipDates = new Set(rule.skip_dates || []);
            const bookedDates = new Set(rule.booked_dates || []);
            
            // Skip if this date is in skip_dates or booked_dates
            if (skipDates.has(dateStr) || bookedDates.has(dateStr)) return false;
            
            // Check if rule applies to this date
            let matches = false;
            if (rule.type === 'daily') {
                matches = true;
            } else if (rule.type === 'weekly') {
                const weekdays = rule.weekdays || [];
                matches = weekdays.includes(dayName);
            } else if (rule.type === 'monthly') {
                const targetDayOfMonthRule = rule.day_of_month;
                if (targetDayOfMonthRule !== null && targetDayOfMonthRule !== undefined) {
                    if (dayOfMonth === targetDayOfMonthRule) {
                        matches = true;
                    } else if (targetDayOfMonthRule > 28) {
                        // Handle edge case: if slot is for day 31 but month doesn't have 31 days
                        const lastDayOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                        if (dayOfMonth === lastDayOfMonth && targetDayOfMonthRule > lastDayOfMonth) {
                            matches = true;
                        }
                    }
                }
            }
            
            if (!matches) return false;
            
            // For today, check if there are any future slots from this rule
            if (isTodayInTz && rule.start_time && rule.end_time) {
                try {
                    const [endH, endM] = rule.end_time.split(':').map(Number);
                    const windowEnd = new Date(date);
                    windowEnd.setHours(endH, endM, 0, 0);
                    return windowEnd > now;
                } catch (e) {
             return false;
                }
            }
            
            return true;
        });
        
        return hasRecurring;
    }

    function getSlotsForDate(date) {
        if (!availabilityData) return [];

        const slots = [];
        
        // Use selectedTimezone or fallback
        const tz = selectedTimezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
        
        // Get the YYYY-MM-DD that this calendar day represents
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const targetDateStr = `${year}-${month}-${day}`;
        
        // Formatter to project UTC slots into the target timezone
        const slotDateFormatter = new Intl.DateTimeFormat('en-CA', { 
            year: 'numeric', month: '2-digit', day: '2-digit', timeZone: tz 
        });
        
        // Use Intl.DateTimeFormat to get the day name and day of month in the target timezone
        const dayName = new Intl.DateTimeFormat('en-US', { weekday: 'long', timeZone: tz }).format(date).toLowerCase();
        const dayOfMonth = parseInt(new Intl.DateTimeFormat('en-US', { day: 'numeric', timeZone: tz }).format(date));
        
        const now = new Date();

        // 1. Add One-Time Slots
        availabilityData.one_time_slots.forEach(slot => {
            if (!slot.start || !slot.end) return;
            if (slot.booked === true) return;
            
            try {
                const slotStart = new Date(slot.start.replace('Z', '+00:00'));
                const slotEnd = new Date(slot.end.replace('Z', '+00:00'));
                
                // Format slot start time to YYYY-MM-DD in the target timezone
                const slotDateStr = slotDateFormatter.format(slotStart);
                
                // Only include slots for this date that end in the future
                if (slotDateStr === targetDateStr && slotEnd > now) {
                    // Generate time slots from this availability window
                    const windowSlots = generateTimeSlotsFromWindow(slotStart, slotEnd, sessionLengthMinutes);
                    
                    windowSlots.forEach(slotStartTime => {
                        const slotEndTime = new Date(slotStartTime.getTime() + sessionLengthMinutes * 60000);
                        
                        // Use Intl.DateTimeFormat for robust timezone formatting
                        const timeFormatter = new Intl.DateTimeFormat('en-US', {
                            hour: 'numeric',
                            minute: '2-digit',
                            hour12: true,
                            timeZone: tz
                        });
                        
                        const startTimeStr = timeFormatter.format(slotStartTime).toLowerCase();
                        const endTimeStr = timeFormatter.format(slotEndTime).toLowerCase();
                        
                        // Check if we need to show adjusted end time for first session
                        let displayTime = `${startTimeStr} - ${endTimeStr}`;
                        let adjustedEndTime = slotEndTime;
                        let useAdjustedEndTime = false;
                        
                        if (mentorFirstSessionFree && isFirstSession && firstSessionLengthDiffers) {
                            adjustedEndTime = new Date(slotStartTime.getTime() + mentorFirstSessionLength * 60000);
                            const adjustedEndTimeStr = timeFormatter.format(adjustedEndTime).toLowerCase();
                            displayTime = `${startTimeStr} - ${adjustedEndTimeStr}`;
                            useAdjustedEndTime = true;
                        }
                        
                        const slotEndToStore = slotEndTime;
                        
                        slots.push({
                            time: displayTime,
                            start: slotStartTime.toISOString(),
                            end: slotEndToStore.toISOString(),
                            adjustedEnd: adjustedEndTime.toISOString(),
                            useAdjustedEndTime: useAdjustedEndTime,
                            raw: slot, 
                            type: 'one_time',
                            availability_slot_id: slot.id || null // For one-time slots
                        });
                    });
                }
            } catch (e) {
                console.error('Error processing one-time slot:', e);
             }
        });

        // 2. Generate Recurring Slots
        availabilityData.recurring_slots.forEach(rule => {
            if (!rule || !rule.type) return;
            
            const skipDates = new Set(rule.skip_dates || []);
            const bookedDates = new Set(rule.booked_dates || []);
            
            // Skip if this date is in skip_dates or booked_dates
            if (skipDates.has(targetDateStr) || bookedDates.has(targetDateStr)) return;
            
            let matches = false;
            
            if (rule.type === 'daily') {
                matches = true;
            } else if (rule.type === 'weekly') {
                const weekdays = rule.weekdays || [];
                matches = weekdays.includes(dayName);
            } else if (rule.type === 'monthly') {
                const targetDayOfMonthRule = rule.day_of_month;
                if (targetDayOfMonthRule !== null && targetDayOfMonthRule !== undefined) {
                    if (dayOfMonth === targetDayOfMonthRule) {
                        matches = true;
                    } else if (targetDayOfMonthRule > 28) {
                        // Handle edge case: if slot is for day 31 but month doesn't have 31 days
                        const lastDayOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                        if (dayOfMonth === lastDayOfMonth && targetDayOfMonthRule > lastDayOfMonth) {
                            matches = true;
                        }
                    }
                }
            }
            
            if (matches && rule.start_time && rule.end_time) {
                try {
                    // Parse start and end times
                    const [startH, startM] = rule.start_time.split(':').map(Number);
                    const [endH, endM] = rule.end_time.split(':').map(Number);
                    
                    // Create datetime objects for this specific date
                    const windowStart = new Date(date);
                    windowStart.setHours(startH, startM, 0, 0);
                    
                    const windowEnd = new Date(date);
                    windowEnd.setHours(endH, endM, 0, 0);
                    
                    // Only include if the window end is in the future
                    if (windowEnd > now) {
                        const windowSlots = generateTimeSlotsFromWindow(windowStart, windowEnd, sessionLengthMinutes);
                        windowSlots.forEach(slotStart => {
                            const slotEnd = new Date(slotStart.getTime() + sessionLengthMinutes * 60000);
                            
                            // Use Intl.DateTimeFormat for robust timezone formatting
                            const tz = selectedTimezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
                            const timeFormatter = new Intl.DateTimeFormat('en-US', {
                                hour: 'numeric',
                                minute: '2-digit',
                                hour12: true,
                                timeZone: tz
                            });
                            
                            const startTimeStr = timeFormatter.format(slotStart).toLowerCase();
                            const endTimeStr = timeFormatter.format(slotEnd).toLowerCase();
                            
                            // Check if we need to show adjusted end time for first session
                            let displayTime = `${startTimeStr} - ${endTimeStr}`;
                            let adjustedEndTime = slotEnd;
                            let useAdjustedEndTime = false;
                            
                            if (mentorFirstSessionFree && isFirstSession && firstSessionLengthDiffers) {
                                adjustedEndTime = new Date(slotStart.getTime() + mentorFirstSessionLength * 60000);
                                const adjustedEndTimeStr = timeFormatter.format(adjustedEndTime).toLowerCase();
                                displayTime = `${startTimeStr} - ${adjustedEndTimeStr}`;
                                useAdjustedEndTime = true;
                            }
                            
                            // Create a unique key for deduplication based on the actual start time
                            const startTimeKey = slotStart.getTime(); // Use timestamp for uniqueness
                            
                            // Get date string for recurring slots (YYYY-MM-DD)
                            const slotDateStr = `${slotStart.getFullYear()}-${String(slotStart.getMonth() + 1).padStart(2, '0')}-${String(slotStart.getDate()).padStart(2, '0')}`;
                            
                            slots.push({ 
                                time: displayTime, 
                                raw: rule, 
                                type: 'recurring',
                                start: slotStart.toISOString(),
                                end: slotEnd.toISOString(),
                                adjustedEnd: useAdjustedEndTime ? adjustedEndTime.toISOString() : null,
                                useAdjustedEndTime: useAdjustedEndTime,
                                _startTimeKey: startTimeKey, // Internal key for deduplication
                                recurring_id: rule.id || null, // For recurring slots
                                instance_date: slotDateStr // Date string (YYYY-MM-DD format)
                            });
                        });
                    }
                } catch (e) {
                    console.error('Error processing recurring slot:', e);
                }
            }
        });

        // Sort by start time and remove duplicates based on actual start timestamp
        const uniqueSlots = [];
        const seenStartTimes = new Set();
        
        slots.sort((a, b) => {
            // Sort by actual start time (timestamp)
            const timeA = a._startTimeKey || (a.start ? new Date(a.start).getTime() : 0);
            const timeB = b._startTimeKey || (b.start ? new Date(b.start).getTime() : 0);
            return timeA - timeB;
        }).forEach(slot => {
            // Use the timestamp for deduplication (most reliable)
            const startTimeKey = slot._startTimeKey || (slot.start ? new Date(slot.start).getTime() : null);
            if (startTimeKey !== null && !seenStartTimes.has(startTimeKey)) {
                seenStartTimes.add(startTimeKey);
                // Remove the internal key before returning
                delete slot._startTimeKey;
                uniqueSlots.push(slot);
            }
        });
        
        return uniqueSlots;
    }
    
    // Helper function to generate time slots from an availability window
    function generateTimeSlotsFromWindow(windowStart, windowEnd, slotLengthMinutes) {
        const slots = [];
        const now = new Date();
        
        let currentTime = new Date(windowStart);
        
        while (currentTime < windowEnd) {
            const slotEnd = new Date(currentTime.getTime() + slotLengthMinutes * 60000);
            
            if (slotEnd <= windowEnd && slotEnd > now) {
                // Return the actual Date object for robust formatting later
                slots.push(new Date(currentTime));
            }
            
            currentTime = new Date(currentTime.getTime() + slotLengthMinutes * 60000);
        }
        
        return slots;
    }

    function selectDate(date, dayEl) {
        selectedDate = date;
        selectedSlot = null; // Clear slot selection when date changes
        renderCalendar(); // Refresh calendar to show selected date
        
        // Show Slots
        if (slotsCol) slotsCol.style.display = 'flex';
        const dateOptions = {weekday: 'long', month: 'short', day: 'numeric'};
        const formattedDate = date.toLocaleDateString([], dateOptions);
        if (selectedDateLabel) selectedDateLabel.textContent = formattedDate;
        
        // Update Sidebar Summary
        if (bookingSummary) bookingSummary.style.display = 'block';
        if (summaryDate) summaryDate.textContent = formattedDate;
        if (summaryTimeRow) summaryTimeRow.style.display = 'none'; // Hide time until slot selected
        
        renderSlots(date);
    }

    function renderSlots(date) {
        const slots = getSlotsForDate(date);
        if (slotsList) {
            slotsList.innerHTML = '';
            
            if (slots.length === 0) {
                slotsList.innerHTML = '<div style="color: #94a3b8; font-style: italic;">No available slots.</div>';
                if (slotsFooter) slotsFooter.style.display = 'none';
            } else {
                slots.forEach((slot, index) => {
                    const btn = document.createElement('button');
                    btn.classList.add('time-slot-btn');
                    // Use textContent since we're no longer using HTML (no crossed-out text)
                    btn.textContent = slot.time;
                    btn.dataset.slotIndex = index;
                    btn.onclick = () => {
                        // Remove selected class from all buttons
                        slotsList.querySelectorAll('.time-slot-btn').forEach(b => b.classList.remove('selected'));
                        // Add selected class to clicked button
                        btn.classList.add('selected');
                        selectedSlot = slot;
                        
                        // Show book button
                        if (slotsFooter) slotsFooter.style.display = 'block';

                        // Update Sidebar Summary Time
                        if (summaryTimeRow) summaryTimeRow.style.display = 'flex';
                        if (summaryTime) summaryTime.textContent = slot.time;
                    };
                    slotsList.appendChild(btn);
                });
                // Hide footer initially (will show when slot is selected)
                if (slotsFooter) slotsFooter.style.display = 'none';
            }
        }
    }
    
    // --- Booking Logic Functions ---
    function handleBookingClick() {
        if (!selectedSlot || !selectedDate) {
            return;
        }
        
        // Check authentication
        if (isUserAuthenticated) {
            if (userRole === 'mentor') {
                // Show error state in modal for mentors
                showBookingError();
                return;
            } else if (userRole === 'user') {
                // Logged-in user - proceed directly to booking
                submitBooking();
                return;
            }
        }
        
        // Not logged in - show email collection modal
        openEmailCollectionModal();
    }
    
    // Helper functions for time formatting
    function formatTime(date, timezone) {
        try {
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: timezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            });
            return formatter.format(date);
        } catch (e) {
            return 'Unable to format time';
        }
    }
    
    function formatDate(date, timezone) {
        try {
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: timezone,
                weekday: 'short',
                month: 'short',
                day: 'numeric'
            });
            return formatter.format(date);
        } catch (e) {
            return 'Unable to format date';
        }
    }
    
    function updateTimezoneClock(timezone, timeEl, dateEl) {
        if (!timezone || !timeEl) return;
        
        const now = new Date();
        const timeStr = formatTime(now, timezone);
        if (timeEl) timeEl.textContent = timeStr;
        
        if (dateEl) {
            const dateStr = formatDate(now, timezone);
            dateEl.textContent = dateStr;
        }
    }
    
    function startTimezoneClock(timezone) {
        // Clear any existing interval
        if (timezoneClockInterval) {
            clearInterval(timezoneClockInterval);
        }
        
        const timeEl = document.getElementById('timezoneCurrentTime');
        const dateEl = document.getElementById('timezoneCurrentDate');
        
        // Update immediately
        updateTimezoneClock(timezone, timeEl, dateEl);
        
        // Update every second
        timezoneClockInterval = setInterval(() => {
            updateTimezoneClock(timezone, timeEl, dateEl);
        }, 1000);
    }
    
    function startSelectedTimezoneClock(timezone) {
        // Clear any existing interval
        if (selectedTimezoneClockInterval) {
            clearInterval(selectedTimezoneClockInterval);
        }
        
        const timeEl = document.getElementById('selectedTimezoneCurrentTime');
        const dateEl = document.getElementById('selectedTimezoneCurrentDate');
        const clockDisplay = document.getElementById('selectedTimezoneClockDisplay');
        
        if (!timezone || !timeEl) {
            if (clockDisplay) clockDisplay.style.display = 'none';
            return;
        }
        
        if (clockDisplay) clockDisplay.style.display = 'block';
        
        // Update immediately
        updateTimezoneClock(timezone, timeEl, dateEl);
        
        // Update every second
        selectedTimezoneClockInterval = setInterval(() => {
            updateTimezoneClock(timezone, timeEl, dateEl);
        }, 1000);
    }
    
    function stopTimezoneClocks() {
        if (timezoneClockInterval) {
            clearInterval(timezoneClockInterval);
            timezoneClockInterval = null;
        }
        if (selectedTimezoneClockInterval) {
            clearInterval(selectedTimezoneClockInterval);
            selectedTimezoneClockInterval = null;
        }
    }
    
    function openEmailCollectionModal() {
        const emailModal = document.getElementById('emailCollectionModal');
        if (!emailModal) return;
        
        // Check if we already have a corrected timezone from previous interaction
        const bookingTimezoneValue = document.getElementById('bookingTimezoneValue');
        let timezoneToUse = null;
        
        // Detect timezone
        try {
            detectedTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            
            // Use corrected timezone if available, otherwise use detected
            if (bookingTimezoneValue && bookingTimezoneValue.value) {
                timezoneToUse = bookingTimezoneValue.value;
                selectedTimezone = timezoneToUse;
            } else {
                timezoneToUse = detectedTimezone;
                selectedTimezone = detectedTimezone;
                // Set hidden timezone value to detected if not already set
                if (bookingTimezoneValue) {
                    bookingTimezoneValue.value = detectedTimezone;
                }
            }
            
            // Update timezone display using TIMEZONE_OPTIONS if available
            const detectedTimezoneName = document.getElementById('detectedTimezoneName');
            if (detectedTimezoneName) {
                let tzDisplay = timezoneToUse;
                let offset = '';
                
                // Try to use TIMEZONE_OPTIONS from timezone-checker.js
                if (window.TIMEZONE_OPTIONS && window.TIMEZONE_OPTIONS.length > 0) {
                    const tzObj = window.TIMEZONE_OPTIONS.find(tz => tz.id === timezoneToUse);
                    if (tzObj) {
                        tzDisplay = tzObj.name;
                        // Get current offset (handles DST)
                        const now = new Date();
                        const formatter = new Intl.DateTimeFormat('en', {
                            timeZone: timezoneToUse,
                            timeZoneName: 'longOffset'
                        });
                        const parts = formatter.formatToParts(now);
                        const offsetPart = parts.find(p => p.type === 'timeZoneName');
                        offset = offsetPart ? offsetPart.value : '';
                    }
                } else {
                    // Fallback: format manually
                    const tzParts = timezoneToUse.split('/');
                    const tzCity = tzParts[tzParts.length - 1] || timezoneToUse;
                    tzDisplay = tzCity.replace(/_/g, ' ');
                    
                    const now = new Date();
                    const formatter = new Intl.DateTimeFormat('en', {
                        timeZone: timezoneToUse,
                        timeZoneName: 'longOffset'
                    });
                    const parts = formatter.formatToParts(now);
                    const offsetPart = parts.find(p => p.type === 'timeZoneName');
                    offset = offsetPart ? offsetPart.value : '';
                }
                
                detectedTimezoneName.textContent = offset ? `${tzDisplay} (${offset})` : tzDisplay;
            }
            
            // Start live clock with the timezone we're using (corrected or detected)
            startTimezoneClock(timezoneToUse);
        } catch (e) {
            console.error('Error detecting timezone:', e);
            detectedTimezone = 'UTC';
            selectedTimezone = 'UTC';
            startTimezoneClock('UTC');
        }
        
        // Calculate and display price
        updatePriceDisplay();
        
        // Update session recap
        updateSessionRecap();
        
        // Reset form
        const emailForm = document.getElementById('emailCollectionForm');
        if (emailForm) emailForm.reset();
        const emailError = document.getElementById('emailError');
        if (emailError) {
            emailError.style.display = 'none';
            emailError.textContent = '';
        }
        
        // Show modal
        emailModal.style.display = 'flex';
        setTimeout(() => {
            emailModal.style.opacity = '1';
        }, 10);
        
        // Focus email input
        const emailInput = document.getElementById('bookingEmailInput');
        if (emailInput) emailInput.focus();
    }
    
    function closeEmailCollectionModal() {
        const emailModal = document.getElementById('emailCollectionModal');
        if (!emailModal) return;
        
        // Stop clocks
        stopTimezoneClocks();
        
        emailModal.style.opacity = '0';
        setTimeout(() => {
            emailModal.style.display = 'none';
        }, 300);
    }
    
    function showAccountExistsModal() {
        const modal = document.getElementById('accountExistsModal');
        if (!modal) return;
        
        modal.style.display = 'flex';
        setTimeout(() => {
            modal.style.opacity = '1';
        }, 10);
    }
    
    function closeAccountExistsModal() {
        const modal = document.getElementById('accountExistsModal');
        if (!modal) return;
        
        modal.style.opacity = '0';
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    }
    
    // Close account exists modal on outside click
    document.addEventListener('DOMContentLoaded', function() {
        const accountExistsModal = document.getElementById('accountExistsModal');
        if (accountExistsModal) {
            accountExistsModal.addEventListener('click', function(e) {
                if (e.target === accountExistsModal) {
                    closeAccountExistsModal();
                }
            });
        }
    });
    
    function handleBackToBooking() {
        // Close account exists modal only
        // Keep the Book Your Session modal (emailCollectionModal) open
        closeAccountExistsModal();
        
        // Ensure main booking modal content is visible
        const mainContent = document.getElementById('bookingMainContent');
        if (mainContent) {
            mainContent.style.display = 'grid';
        }
        
        // Hide success state if visible
        const successState = document.getElementById('bookingSuccessState');
        if (successState) {
            successState.style.display = 'none';
        }
        
        // Restore preserved booking data for email/note (but clear slot selection so user can choose a different day)
        if (preservedBookingData) {
            // Store email and note for when they select a slot again
            // But don't restore the selected slot - let them choose a new day
            const emailInput = document.getElementById('bookingEmailInput');
            const noteInput = document.getElementById('bookingNoteInput');
            
            if (emailInput) emailInput.value = preservedBookingData.email || '';
            if (noteInput) noteInput.value = preservedBookingData.note || '';
            
            // Clear slot selection so user can choose a different day
            selectedDate = null;
            selectedSlot = null;
            
            // Hide slots column and footer
            if (slotsCol) slotsCol.style.display = 'none';
            if (slotsFooter) slotsFooter.style.display = 'none';
            if (bookingSummary) bookingSummary.style.display = 'none';
            if (selectedDateLabel) selectedDateLabel.textContent = 'Select a date';
        }
        
        // Render calendar to show available days
        renderCalendar();
    }
    
    function handleLoginToBook() {
        // Build login URL with booking parameters
        if (!preservedBookingData) return;
        
        const params = new URLSearchParams({
            'next': window.location.pathname,
            'booking': 'true',
            'mentor_id': preservedBookingData.mentor_id,
            'start_datetime': preservedBookingData.start_datetime,
            'end_datetime': preservedBookingData.end_datetime,
            'availability_slot_id': preservedBookingData.availability_slot_id || '',
            'recurring_id': preservedBookingData.recurring_id || '',
            'instance_date': preservedBookingData.instance_date || '',
            'adjusted_end_datetime': preservedBookingData.adjusted_end_datetime || '',
            'note': preservedBookingData.note || ''
        });
        
        // Redirect to login
        window.location.href = '/accounts/login/?' + params.toString();
    }
    
    function updatePriceDisplay() {
        const priceDisplay = document.getElementById('bookingPriceDisplay');
        const priceNote = document.getElementById('bookingPriceNote');
        
        if (!priceDisplay) return;
        
        // Check if it's first session (for logged-in users) or always true for non-authenticated
        const isFirstSessionCheck = isUserAuthenticated ? isFirstSession : true;
        
        if (mentorFirstSessionFree && isFirstSessionCheck) {
            priceDisplay.textContent = '$0';
            if (priceNote) {
                priceNote.style.display = 'block';
                priceNote.textContent = 'This is your first session with this mentor';
            }
        } else {
            const price = mentorPricePerHour || 0;
            priceDisplay.textContent = `$${price}`;
            if (priceNote) {
                priceNote.style.display = 'none';
            }
        }
    }
    
    function updateSessionRecap() {
        if (!selectedSlot || !selectedDate) {
            const recapDate = document.getElementById('recapDate');
            const recapTime = document.getElementById('recapTime');
            const recapLength = document.getElementById('recapLength');
            if (recapDate) recapDate.textContent = '--';
            if (recapTime) recapTime.textContent = '--';
            if (recapLength) recapLength.textContent = '--';
            return;
        }
        
        const recapDate = document.getElementById('recapDate');
        const recapTime = document.getElementById('recapTime');
        const recapLength = document.getElementById('recapLength');
        
        if (!recapDate || !recapTime || !recapLength) return;
        
        // Use selectedTimezone or fallback to browser default
        const tz = selectedTimezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
        
        // Format date in current timezone
        try {
            const dateOptions = { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                timeZone: tz
            };
            const slotStart = new Date(selectedSlot.start);
            recapDate.textContent = new Intl.DateTimeFormat('en-US', dateOptions).format(slotStart);
        } catch (e) {
            console.error('Error formatting recap date:', e);
            const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            recapDate.textContent = selectedDate.toLocaleDateString('en-US', dateOptions);
        }
        
        // Format time in current timezone
        try {
            const timeOptions = { 
                hour: 'numeric', 
                minute: '2-digit', 
                hour12: true,
                timeZone: tz
            };
            const formatter = new Intl.DateTimeFormat('en-US', timeOptions);
            const startStr = formatter.format(new Date(selectedSlot.start)).toLowerCase();
            
            // End time depends on whether we use adjusted (first session) or regular end
            const actualEnd = selectedSlot.useAdjustedEndTime && selectedSlot.adjustedEnd 
                ? new Date(selectedSlot.adjustedEnd) 
                : new Date(selectedSlot.end);
                
            const endStr = formatter.format(actualEnd).toLowerCase();
            recapTime.textContent = `${startStr} - ${endStr}`;
        } catch (e) {
            console.error('Error formatting recap time:', e);
            recapTime.textContent = selectedSlot.time || '--';
        }
        
        // Visual Feedback: Blink 3 times (slower animation)
        [recapDate, recapTime].forEach(el => {
            if (el) {
                el.classList.remove('appointment-blink');
                // Force reflow to restart animation
                void el.offsetWidth;
                el.classList.add('appointment-blink');
            }
        });

        // Determine session length based on first session free logic
        const isFirstSessionCheck = isUserAuthenticated ? isFirstSession : true;
        let sessionLengthMinutes = mentorSessionLength;
        let lengthDisplay = `${mentorSessionLength} minutes`;
        
        if (mentorFirstSessionFree && isFirstSessionCheck) {
            // First session free is enabled and it's the first session
            if (firstSessionLengthDiffers) {
                // Lengths differ - show first session length
                sessionLengthMinutes = mentorFirstSessionLength;
                lengthDisplay = `${mentorFirstSessionLength} minutes (First Session)`;
            } else {
                // Lengths are the same - just show regular length
                sessionLengthMinutes = mentorSessionLength;
                lengthDisplay = `${mentorSessionLength} minutes`;
            }
        } else {
            // Not first session or first session free disabled - use regular session length or calculated duration
            try {
                const startDate = new Date(selectedSlot.start);
                const endDate = selectedSlot.useAdjustedEndTime && selectedSlot.adjustedEnd 
                    ? new Date(selectedSlot.adjustedEnd) 
                    : new Date(selectedSlot.end);
                const diffMs = endDate - startDate;
                const diffMin = Math.round(diffMs / 60000);
                lengthDisplay = `${diffMin} minutes`;
            } catch (e) {
                lengthDisplay = `${mentorSessionLength} minutes`;
            }
        }
        
        recapLength.textContent = lengthDisplay;
    }
    
    function handleEmailCollectionSubmit() {
        const emailInput = document.getElementById('bookingEmailInput');
        const noteInput = document.getElementById('bookingNoteInput');
        const bookingTimezoneValue = document.getElementById('bookingTimezoneValue');
        const emailError = document.getElementById('emailError');
        const submitBtn = document.getElementById('submitBookingBtn');
        
        if (!emailInput || !submitBtn) return;
        
        const email = emailInput.value.trim();
        
        // Validate email
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!email || !emailRegex.test(email)) {
            if (emailError) {
                emailError.textContent = 'Please enter a valid email address';
                emailError.style.display = 'block';
            }
            return;
        }
        
        // Get timezone - use selected timezone if set, otherwise use detected
        let timezone = detectedTimezone || 'UTC';
        if (bookingTimezoneValue && bookingTimezoneValue.value) {
            timezone = bookingTimezoneValue.value;
        } else if (selectedTimezone) {
            timezone = selectedTimezone;
        }
        
        const note = noteInput ? noteInput.value.trim() : '';
        
        // Disable button
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>Booking...</span>';
        
        // Hide error
        if (emailError) {
            emailError.style.display = 'none';
        }
        
        // Submit booking
        submitBooking(email, note, timezone);
    }
    
    function submitBooking(email = null, note = null, timezone = null) {
        if (!selectedSlot || !selectedDate) {
            return;
        }
        
        // Store email for success handler (will be used if backend doesn't return it)
        submittedEmail = email;
        
        // Prepare payload
        const payload = {
            mentor_id: mentorId,
            start_datetime: selectedSlot.start,
            end_datetime: selectedSlot.end,
            is_logged_in: isUserAuthenticated
        };
        
        // Add adjusted end datetime if first session length differs
        if (selectedSlot.useAdjustedEndTime && selectedSlot.adjustedEnd) {
            payload.adjusted_end_datetime = selectedSlot.adjustedEnd;
        }
        
        // Add availability slot info
        if (selectedSlot.type === 'one_time' && selectedSlot.availability_slot_id) {
            payload.availability_slot_id = selectedSlot.availability_slot_id;
        } else if (selectedSlot.type === 'recurring' && selectedSlot.recurring_id && selectedSlot.instance_date) {
            payload.recurring_id = selectedSlot.recurring_id;
            payload.instance_date = selectedSlot.instance_date;
        }
        
        // Add email/note/timezone if not logged in
        if (!isUserAuthenticated) {
            if (email) payload.email = email;
            if (note) payload.note = note;
            if (timezone) payload.timezone = timezone;
        }
        
        // Get CSRF token
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        const csrftoken = getCookie('csrftoken');
        
        // Make API call
        fetch('{% url "general:dashboard_user:book_session" %}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify(payload)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Close email collection modal if open
                closeEmailCollectionModal();
                
                // Show success state in booking modal
                // For logged-in users, email should come from backend; for non-logged-in, use submittedEmail
                const successEmail = data.email || (isUserAuthenticated ? null : submittedEmail) || '';
                const isNewUser = data.is_new_user || false;
                showBookingSuccess(successEmail, isNewUser);
                
                // Re-enable button (in case it was disabled)
                const submitBtn = document.getElementById('submitBookingBtn');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="fas fa-calendar-check"></i> <span>Book Session</span>';
                }
            } else {
                // Handle account exists error specially
                if (data.error === 'account_exists' && data.preserved_data) {
                    // Store preserved booking data
                    preservedBookingData = data.preserved_data;
                    
                    // Close email collection modal
                    closeEmailCollectionModal();
                    
                    // Show account exists modal
                    showAccountExistsModal();
                    
                    // Re-enable button
                    const submitBtn = document.getElementById('submitBookingBtn');
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = '<i class="fas fa-calendar-check"></i> <span>Book Session</span>';
                    }
                } else {
                    // Show regular error
                    const errorMsg = data.error || data.message || 'Failed to book session. Please try again.';
                    if (typeof showNotification !== 'undefined') {
                        showNotification(errorMsg, 'error');
                    } else {
                        alert(errorMsg);
                    }
                    
                    // Re-enable button
                    const submitBtn = document.getElementById('submitBookingBtn');
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = '<i class="fas fa-calendar-check"></i> <span>Book Session</span>';
                    }
                }
            }
        })
        .catch(error => {
            console.error('Booking error:', error);
            const errorMsg = 'An error occurred while booking. Please try again.';
            if (typeof showNotification !== 'undefined') {
                showNotification(errorMsg, 'error');
            } else {
                alert(errorMsg);
            }
            
            // Re-enable button
            const submitBtn = document.getElementById('submitBookingBtn');
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.innerHTML = '<i class="fas fa-calendar-check"></i> <span>Book Session</span>';
            }
        });
    }
    
    // Initialize timezone autocomplete for email collection modal
    function initializeBookingTimezoneAutocomplete() {
        const timezoneInput = document.getElementById('bookingTimezoneInput');
        const timezoneValue = document.getElementById('bookingTimezoneValue');
        const timezoneSuggestions = document.getElementById('bookingTimezoneSuggestions');
        
        if (!timezoneInput || !timezoneValue || !timezoneSuggestions) return;
        
        // Use TIMEZONE_OPTIONS from timezone-checker.js if available
        const timezones = window.TIMEZONE_OPTIONS || [];
        
        if (timezones.length === 0) {
            // Fallback: build timezone list
            let ids = [];
            try {
                if (typeof Intl.supportedValuesOf === 'function') {
                    ids = Intl.supportedValuesOf('timeZone');
                }
            } catch (e) {
                ids = ['UTC', 'America/New_York', 'Europe/London', 'Asia/Tokyo', 'Australia/Sydney'];
            }
            
            // Simple timezone list for autocomplete
            timezones = ids.map(id => ({
                id: id,
                name: id.split('/').pop().replace(/_/g, ' ')
            }));
        }
        
        if (timezones.length === 0) {
            console.warn('TIMEZONE_OPTIONS not available, waiting for timezone-checker.js to load...');
            // Wait a bit and try again
            setTimeout(initializeBookingTimezoneAutocomplete, 500);
            return;
        }
        
        // Use the same autocomplete function from timezone-checker.js if available
        if (typeof window.initializeTimezoneAutocomplete === 'function') {
            window.initializeTimezoneAutocomplete(
                timezoneInput,
                timezoneValue,
                timezoneSuggestions,
                timezones,
                function(selectedTzObj) {
                    // When timezone is selected
                    selectedTimezone = selectedTzObj.id;
                    timezoneValue.value = selectedTzObj.id;
                    
                    // Update and start clock for selected timezone
                    startSelectedTimezoneClock(selectedTzObj.id);
                }
            );
        } else {
            // Fallback: simple autocomplete implementation
            function filterTimezones(query) {
                if (!query || query.trim() === '') {
                    return timezones.slice(0, 20); // Show first 20 if empty
                }
                const lowerQuery = query.toLowerCase();
                return timezones.filter(tz => 
                    (tz.name && tz.name.toLowerCase().includes(lowerQuery)) ||
                    (tz.region && tz.region.toLowerCase().includes(lowerQuery)) ||
                    (tz.id && tz.id.toLowerCase().includes(lowerQuery)) ||
                    (tz.offset && tz.offset.toLowerCase().includes(lowerQuery))
                ).slice(0, 20);
            }
            
            function displaySuggestions(suggestions) {
                if (suggestions.length === 0) {
                    timezoneSuggestions.style.display = 'none';
                    return;
                }
                
                timezoneSuggestions.innerHTML = '';
                suggestions.forEach(tz => {
                    const item = document.createElement('div');
                    item.className = 'suggestion-item';
                    item.style.cssText = 'cursor: pointer; padding: 12px 16px; border-bottom: 1px solid #e2e8f0; transition: background 0.2s;';
                    item.innerHTML = `<div style="font-weight: 600; color: #1e293b;">${tz.name || tz.id}</div><div style="font-size: 0.85rem; color: #64748b;">${tz.offset || ''}</div>`;
                    item.addEventListener('mouseenter', function() {
                        this.style.background = '#f1f5f9';
                    });
                    item.addEventListener('mouseleave', function() {
                        this.style.background = 'transparent';
                    });
                    item.addEventListener('click', function() {
                        timezoneInput.value = (tz.name || tz.id) + (tz.offset ? ' (' + tz.offset + ')' : '');
                        timezoneValue.value = tz.id;
                        timezoneSuggestions.style.display = 'none';
                        selectedTimezone = tz.id;
                        
                        // Update and start clock for selected timezone
                        startSelectedTimezoneClock(tz.id);
                    });
                    timezoneSuggestions.appendChild(item);
                });
                
                timezoneSuggestions.style.display = 'block';
            }
            
            timezoneInput.addEventListener('input', function() {
                const query = this.value.trim();
                displaySuggestions(filterTimezones(query));
            });
            
            timezoneInput.addEventListener('focus', function() {
                const query = this.value.trim();
                displaySuggestions(filterTimezones(query));
            });
            
            // Close on outside click
            document.addEventListener('click', function(e) {
                if (timezoneInput && !timezoneInput.contains(e.target) && 
                    timezoneSuggestions && !timezoneSuggestions.contains(e.target)) {
                    timezoneSuggestions.style.display = 'none';
                }
            });
        }
    }

    function confirmTimeCorrection() {
        const confirmBtn = document.getElementById('confirmTimeCorrectionBtn');
        
        if (!selectedTimezoneFromTime) {
            alert('Please select a timezone from the list');
            return;
        }
        
        // Disable button
        if (confirmBtn) {
            confirmBtn.disabled = true;
            confirmBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Applying...';
        }
        
        // Find the selected timezone object from the built list
        const timezones = buildTimezoneList();
        const selectedTz = timezones.find(tz => tz.id === selectedTimezoneFromTime);
        
        if (!selectedTz) {
            alert('Error: Could not find selected timezone');
            if (confirmBtn) {
                confirmBtn.disabled = false;
                confirmBtn.innerHTML = 'Use this Timezone';
            }
            return;
        }
        
        // Update the booking form
        const bookingTimezoneValue = document.getElementById('bookingTimezoneValue');
        const detectedTimezoneName = document.getElementById('detectedTimezoneName');
        const detectedTimezoneDisplay = document.getElementById('detectedTimezoneDisplay');
        
        if (bookingTimezoneValue) {
            bookingTimezoneValue.value = selectedTz.id;
            selectedTimezone = selectedTz.id;
        }
        
        if (detectedTimezoneName) {
            detectedTimezoneName.textContent = `${selectedTz.name} (${selectedTz.offset})`;
        }
        
        if (detectedTimezoneDisplay) {
            detectedTimezoneDisplay.innerHTML = `Set to: <strong>${selectedTz.name} (${selectedTz.offset})</strong>`;
        }
        
        // Update and restart clocks
        if (typeof startTimezoneClock === 'function') {
            startTimezoneClock(selectedTz.id);
        }
        if (typeof startSelectedTimezoneClock === 'function') {
            startSelectedTimezoneClock(selectedTz.id);
        }
        
        // Refresh Booking UI components
        // 1. Refresh Calendar days (to update visibility/dots if they rely on local 'now')
        if (typeof renderCalendar === 'function') {
            try {
                renderCalendar();
            } catch (e) {
                console.error('Error rendering calendar:', e);
            }
        }
        
        // 2. Refresh Slots for the selected date
        if (selectedDate && typeof renderSlots === 'function') {
            try {
                renderSlots(selectedDate);
            } catch (e) {
                console.error('Error rendering slots:', e);
            }
        }
        
        // 3. Refresh Session Recap (the appointment details mentioned by the user)
        if (typeof updateSessionRecap === 'function') {
            try {
                updateSessionRecap();
            } catch (e) {
                console.error('Error updating session recap:', e);
            }
        }
        
        // Close modal
        closeTimeCorrectionModal();
        
        // Re-enable button after a short delay to prevent flickers
        setTimeout(() => {
            if (confirmBtn) {
                confirmBtn.disabled = false;
                confirmBtn.innerHTML = 'Use this Timezone';
            }
        }, 300);
    }
    </script>

