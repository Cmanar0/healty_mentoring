{% load static %}

{# Entry-point popup template. Include this from a page via: {% include "dashboard_mentor/calendar_mentor/calendar.html" %} #}

<div id="mentorCalendarOverlay" class="mentor-calendar-overlay" aria-hidden="true">
  <div class="mentor-calendar-backdrop" data-mentor-calendar-close></div>

  <div class="mentor-calendar-modal" role="dialog" aria-modal="true" aria-label="Calendar">
    <header class="mentor-calendar-header">
      <div class="mentor-calendar-date-group">
        <h2 id="mentorCalendarDateDisplay">Loading...</h2>
      </div>

      <div class="mentor-calendar-controls">
        <div class="mentor-calendar-nav">
          <button class="calendar-nav-btn" data-calendar-nav="prev" aria-label="Previous">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <button class="calendar-nav-btn" data-calendar-nav="today" aria-label="Today">Today</button>
          <button class="calendar-nav-btn" data-calendar-nav="next" aria-label="Next">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>

        <div class="mentor-calendar-view-toggle">
          <button class="view-toggle-btn" data-calendar-view="timeGridDay">Day</button>
          <button class="view-toggle-btn is-active" data-calendar-view="timeGridWeek">Week</button>
          <button class="view-toggle-btn" data-calendar-view="dayGridMonth">Month</button>
        </div>

        <div class="mentor-calendar-mode-toggle" aria-label="Mode toggle">
          <button type="button" id="mentorCalendarModeSessions" class="mode-toggle-btn is-active" data-mode="sessions">
            Sessions
          </button>
          <button type="button" id="mentorCalendarModeAvailability" class="mode-toggle-btn" data-mode="availability">
            Availability
          </button>
        </div>

        <button type="button" id="mentorCalendarSaveBtn" class="mentor-calendar-save-btn" aria-label="Save availability" aria-busy="false">
          <span class="btn-label">Save</span>
          <span class="btn-spinner" aria-hidden="true"></span>
        </button>

        <button type="button" class="mentor-calendar-close" data-mentor-calendar-close aria-label="Close">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </header>

    <div class="mentor-calendar-body">
      <div id="mentorCalendarRoot" class="mentor-calendar-root"></div>
    </div>
  </div>
</div>

{% include "dashboard_mentor/calendar_mentor/Session_slot.html" %}
{% include "dashboard_mentor/calendar_mentor/Availability_Slot.html" %}
{% include "dashboard_mentor/calendar_mentor/availability_settings.html" %}
{% include "dashboard_mentor/calendar_mentor/availability_switch_mode_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/session_switch_mode_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/session_settings.html" %}
{% include "dashboard_mentor/calendar_mentor/schedule_session_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/unsaved_changes_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/recurring_delete_popup.html" %}
{% include "dashboard_mentor/calendar_mentor/recurring_move_popup.html" %}
{% include "dashboard_mentor/components/collision_resolution_popup.html" %}

<style>
  /* --- Overlay --- */
  .mentor-calendar-overlay {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(15, 23, 42, 0.6);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    z-index: 9999;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
  }
  .mentor-calendar-overlay.is-visible {
    opacity: 1;
    visibility: visible;
  }
  .mentor-calendar-backdrop {
    position: absolute;
    inset: 0;
  }

  /* --- Modal --- */
  .mentor-calendar-modal {
    background: #ffffff;
    width: 95%;
    max-width: 1400px;
    height: 90vh;
    border-radius: 24px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 
      0 25px 50px -12px rgba(0, 0, 0, 0.25),
      0 0 0 1px rgba(0, 0, 0, 0.05);
    transform: translateY(20px);
    transition: transform 0.3s ease, opacity 0.3s ease;
    opacity: 0;
  }
  .mentor-calendar-overlay.is-visible .mentor-calendar-modal {
    transform: translateY(0);
    opacity: 1;
  }

  /* --- Header --- */
  .mentor-calendar-header {
    padding: 20px 32px;
    background: #ffffff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 24px;
    border-bottom: 1px solid #f1f5f9;
  }

  /* Date Display (Left) */
  .mentor-calendar-date-group h2 {
    margin: 0;
    font-size: 1.5rem;
    font-weight: 700;
    color: #0f172a;
    letter-spacing: -0.025em;
    line-height: 1.2;
    min-width: 200px; /* Prevent jumping */
  }

  /* Controls Group (Right) */
  .mentor-calendar-controls {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  /* Nav Buttons */
  .mentor-calendar-nav {
    display: flex;
    align-items: center;
    gap: 4px;
    background: #f8fafc;
    padding: 4px;
    border-radius: 12px;
    border: 1px solid #e2e8f0;
  }

  .calendar-nav-btn {
    border: none;
    background: transparent;
    width: 32px;
    height: 32px;
    border-radius: 8px;
    cursor: pointer;
    color: #64748b;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    padding: 0;
  }

  .calendar-nav-btn[data-calendar-nav="today"] {
    width: auto;
    padding: 0 12px;
    font-size: 0.875rem;
    font-weight: 600;
    color: #475569;
  }

  .calendar-nav-btn:hover {
    background: #ffffff;
    color: #0f172a;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
  }

  /* View Toggle (Segmented Control) */
  .mentor-calendar-view-toggle {
    min-width: 245px;
    display: flex;
    align-items: center;
    background: #f1f5f9;
    border-radius: 10px;
    padding: 4px;
    gap: 5px;
    border: 1px solid #e2e8f0;
  }

  .view-toggle-btn {
    padding: 6px 16px;
    border: none;
    cursor: pointer;
    border-radius: 8px;
    background: transparent;
    color: #64748b;
    font-size: 0.875rem;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  .view-toggle-btn:hover:not(.is-active) {
    color: #334155;
    background: rgba(0,0,0,0.03);
  }

  .view-toggle-btn.is-active {
    background: #334156;
    color: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    font-weight: 600;
  }

  /* Sessions / Availability toggle */
  .mentor-calendar-mode-toggle {
    display: flex;
    align-items: center;
    background: #f1f5f9;
    border-radius: 10px;
    padding: 4px;
    border: 1px solid #e2e8f0;
    gap: 4px;
  }
  .mode-toggle-btn {
    padding: 6px 14px;
    border: none;
    cursor: pointer;
    border-radius: 8px;
    background: transparent;
    color: #64748b;
    font-size: 0.875rem;
    font-weight: 600;
    transition: all 0.2s ease;
    white-space: nowrap;
  }
  .mode-toggle-btn:hover:not(.is-active) {
    color: #334155;
    background: rgba(0,0,0,0.03);
  }
  .mode-toggle-btn.is-active[data-mode="sessions"] {
    background: #10b981; /* green */
    color: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }
  .mode-toggle-btn.is-active[data-mode="availability"] {
    background: #3b82f6; /* blue */
    color: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  /* Save button */
  .mentor-calendar-save-btn {
    height: 40px;
    padding: 0 14px;
    border-radius: 10px;
    border: 1px solid #e2e8f0;
    background: #0f172a;
    color: #ffffff;
    font-size: 0.875rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 96px; /* prevent width shift when loading spinner shows */
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
  .mentor-calendar-save-btn:hover {
    background: #111827;
  }
  .mentor-calendar-save-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .mentor-calendar-save-btn .btn-spinner {
    display: none;
    width: 16px;
    height: 16px;
    border-radius: 999px;
    border: 2px solid rgba(255, 255, 255, 0.35);
    border-top-color: currentColor;
    animation: mentor-save-spin 0.8s linear infinite;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  .mentor-calendar-save-btn.is-loading {
    cursor: wait;
  }
  .mentor-calendar-save-btn.is-loading .btn-label {
    visibility: hidden;
  }
  .mentor-calendar-save-btn.is-loading .btn-spinner {
    display: inline-block;
  }

  @keyframes mentor-save-spin {
    to { transform: translate(-50%, -50%) rotate(360deg); }
  }

  /* Close Button */
  .mentor-calendar-close {
    border: none;
    background: transparent;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    color: #94a3b8;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    margin-left: 8px;
  }

  .mentor-calendar-close:hover {
    background: #fee2e2;
    color: #ef4444;
    transform: rotate(90deg);
  }

  /* --- Body --- */
  .mentor-calendar-body {
    flex: 1;
    min-height: 0;
    background: #f8fafc;
    position: relative;
    padding: 0;
  }

  .mentor-calendar-root {
    height: 100%;
    background: #ffffff;
  }

  /* --- FullCalendar Overrides (Matching Availability Popup) --- */
  .mentor-calendar-root {
    font-family: inherit;
    --fc-border-color: #cbd5e1;
    --fc-page-bg-color: #ffffff;
    --fc-neutral-bg-color: #f8fafc;
    --fc-today-bg-color: #fefce8;
    --fc-now-indicator-color: #ef4444;
    /* Ensure slots have consistent rounding everywhere (wrapper + inner) */
    --mentor-calendar-slot-radius: 10px;
  }

  /* Headers */
  .mentor-calendar-root .fc-theme-standard th {
    border: 1px solid var(--fc-border-color);
    background: #f8fafc;
    padding: 12px 0;
  }

  .mentor-calendar-root .fc-col-header-cell-cushion {
    color: #64748b;
    font-weight: 600;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  /* Time Labels */
  .mentor-calendar-root .fc-timegrid-axis-cushion,
  .mentor-calendar-root .fc-timegrid-slot-label-cushion {
    color: #64748b;
    font-size: 0.75rem;
    font-weight: 500;
  }

  /* Strictly enforce 1px borders everywhere to match popup */
  .mentor-calendar-root .fc-theme-standard td, 
  .mentor-calendar-root .fc-theme-standard th,
  .mentor-calendar-root .fc-scrollgrid,
  .mentor-calendar-root .fc-timegrid-col,
  .mentor-calendar-root .fc-daygrid-day-frame {
    border: 1px solid var(--fc-border-color) !important;
  }

  /* Prevent double borders in month view */
  .mentor-calendar-root .fc-daygrid-day-frame {
    border: none !important; 
  }
  .mentor-calendar-root .fc-daygrid-day {
    border: 1px solid var(--fc-border-color) !important;
  }

  /* TimeGrid "drop rows" (FullCalendar time slots)
     - slotDuration controls how many rows per hour
     - snapDuration controls drag/drop snapping
  */
  .mentor-calendar-root .fc-timegrid-slot,
  .mentor-calendar-root .fc-timegrid-slot table,
  .mentor-calendar-root .fc-timegrid-slot tr,
  .mentor-calendar-root .fc-timegrid-slot td,
  .mentor-calendar-root .fc-timegrid-slot-lane,
  .mentor-calendar-root .fc-timegrid-slot-lane table,
  .mentor-calendar-root .fc-timegrid-slot-lane tr,
  .mentor-calendar-root .fc-timegrid-slot-lane td {
    height: 9px !important;       /* 5-min row height */
    min-height: 9px !important;
    max-height: 9px !important;
    line-height: 9px !important;
  }

  .mentor-calendar-root table.fc-timegrid-slots tr td {
    padding: 0 !important;
  }

  /* Hide horizontal borders for 5-min rows (we keep strong hour lines instead) */
  .mentor-calendar-root .fc-timegrid-slot {
    border-top: 1px solid #cbd5e12b !important;
    border-bottom: none !important;
  }
  
  /* Class we'll add via JS for strong hour lines */
  .mentor-calendar-root .fc-hour-slot {
    border-top: 1px solid var(--fc-border-color) !important;
  }

  /* --- Dynamic Slot Styling based on Mode --- */

  /* Base Event Styles (handled by FullCalendar inline styles usually, but we set overrides) */
  .mentor-calendar-root .fc-event,
  .mentor-calendar-root .fc-timegrid-event,
  .mentor-calendar-root .fc-daygrid-event {
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    border-width: 2px !important;
    border-style: solid !important;
    border-radius: var(--mentor-calendar-slot-radius) !important;
    overflow: hidden; /* keep slot content fully inside the event */
  }

  /* Inner slot content should match the event wrapper radius */
  .mentor-calendar-root .mentor-calendar-slot {
    height: 100% !important;
    border-radius: var(--mentor-calendar-slot-radius);
    box-sizing: border-box;
  }

  /* When a slot dropdown is open, lift the event above neighbors */
  .mentor-calendar-root .fc-event.is-dropdown-open,
  .mentor-calendar-root .fc-timegrid-event.is-dropdown-open,
  .mentor-calendar-root .fc-daygrid-event.is-dropdown-open {
    /* FullCalendar may set z-index inline; force override */
    z-index: 20000 !important;
  }

  /* 
     Mode: SESSIONS (Default) 
     - Session Slots (Green): Normal
     - Availability Slots (Grey): Disabled/Ghost
  */
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability {
    background-color: #f1f5f9 !important; /* Slate-100 */
    border-color: #cbd5e1 !important;     /* Slate-300 */
    opacity: 0.8;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .fc-event-main,
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .fc-event-time,
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .fc-event-title, 
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability [data-slot-time] {
    color: #94a3b8 !important; /* Slate-400 */
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-slot-title {
    color: #94a3b8 !important; /* Slate-400 */
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-slot-delete {
    display: none !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-slot-duration {
    color: #94a3b8 !important; /* Slate-400 */
    opacity: 0.8 !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-recurrence-trigger {
    background: #f1f5f9 !important; /* Slate-100 */
    border-color: #cbd5e1 !important; /* Slate-300 */
    color: #94a3b8 !important; /* Slate-400 */
    pointer-events: none !important; /* Lock dropdown */
    box-shadow: none !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .event-type-availability .mentor-calendar-recurrence-chevron {
    opacity: 0.5 !important;
  }

  /* 
     Mode: AVAILABILITY 
     - Session Slots (Grey): Disabled/Ghost
     - Availability Slots (Blue): Normal
  */
  .mentor-calendar-root.is-mode-availability .event-type-session {
    background-color: #f1f5f9 !important; /* Slate-100 */
    border-color: #cbd5e1 !important;     /* Slate-300 */
    opacity: 0.8;
  }
  .mentor-calendar-root.is-mode-availability .event-type-session .fc-event-main,
  .mentor-calendar-root.is-mode-availability .event-type-session .fc-event-time,
  .mentor-calendar-root.is-mode-availability .event-type-session .fc-event-title,
  .mentor-calendar-root.is-mode-availability .event-type-session [data-slot-time] {
    color: #94a3b8 !important; /* Slate-400 */
  }
  .mentor-calendar-root.is-mode-availability .event-type-session .mentor-calendar-slot-title {
    color: #94a3b8 !important; /* Slate-400 */
  }

  /* --- Collision styling (red) --- */
  .mentor-calendar-root .fc-event.is-collision,
  .mentor-calendar-root .fc-timegrid-event.is-collision,
  .mentor-calendar-root .fc-daygrid-event.is-collision {
    background-color: #ef4444 !important; /* red-500 */
    border-color: #b91c1c !important;     /* red-700 */
    opacity: 1 !important;
  }
  .mentor-calendar-root .fc-event.is-collision .fc-event-main,
  .mentor-calendar-root .fc-event.is-collision .fc-event-time,
  .mentor-calendar-root .fc-event.is-collision .fc-event-title,
  .mentor-calendar-root .fc-event.is-collision [data-slot-time],
  .mentor-calendar-root .fc-event.is-collision .mentor-calendar-slot-title {
    color: #ffffff !important;
  }

  /* Sessions mode: availability hover is light + clickable */
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability {
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1) !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover {
    background-color: #eff6ff !important; /* Blue-50 */
    border-color: #60a5fa !important;     /* Blue-400 */
    transform: translateY(-2px) scale(1.01);
    box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.15), 0 4px 6px -4px rgba(59, 130, 246, 0.1);
    z-index: 50 !important;
  }
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover .mentor-calendar-slot,
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover .mentor-calendar-slot-title,
  .mentor-calendar-root:not(.is-mode-availability) .fc-event.event-type-availability:hover [data-slot-time] {
    color: #1e3a8a !important; /* Blue-900 */
  }

  /* Blink notification for invalid recurring drag (cross-day) */
  .mentor-calendar-root .fc-event.recurring-blink {
    animation: mentorRecurringBlink 0.22s ease-in-out 0s 3;
  }
  @keyframes mentorRecurringBlink {
    0%, 100% { filter: none; }
    50% { filter: brightness(1.35) saturate(0.95); }
  }

</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.css">
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/locales-all.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fullcalendar/interaction@6.1.10/index.global.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@fullcalendar/luxon3@6.1.10/index.global.min.js"></script>

<script>
(function() {
  const overlay = document.getElementById('mentorCalendarOverlay');
  const root = document.getElementById('mentorCalendarRoot');
  const dateDisplay = document.getElementById('mentorCalendarDateDisplay');
  const saveBtn = document.getElementById('mentorCalendarSaveBtn');
  const modeSessionsBtn = document.getElementById('mentorCalendarModeSessions');
  const modeAvailabilityBtn = document.getElementById('mentorCalendarModeAvailability');
  const sessionSlotTpl = document.getElementById('mentorCalendarSessionSlotTemplate');
  const availabilitySlotTpl = document.getElementById('mentorCalendarAvailabilitySlotTemplate');

  // Availability settings popup (opens on dblclick availability slot)
  const availabilitySettingsOverlay = document.getElementById('mentorAvailabilitySettingsOverlay');
  const availabilitySettingsDateInput = document.getElementById('availabilitySettingsDate');
  const availabilitySettingsTimeInput = document.getElementById('availabilitySettingsTime');
  const availabilitySettingsDurationMinutesEl = document.getElementById('availabilitySettingsDurationMinutes');
  const availabilitySettingsSaveBtn = document.getElementById('availabilitySettingsSaveBtn');
  const availabilitySwitchOverlay = document.getElementById('mentorAvailabilitySwitchModeOverlay');
  const availabilitySwitchToAvailabilityBtn = document.getElementById('availabilitySwitchToAvailabilityBtn');
  const sessionSwitchOverlay = document.getElementById('mentorSessionSwitchModeOverlay');
  const sessionSwitchToSessionsBtn = document.getElementById('sessionSwitchToSessionsBtn');
  const sessionSettingsOverlay = document.getElementById('mentorSessionSettingsOverlay');
  const sessionSettingsDateInput = document.getElementById('sessionSettingsDate');
  const sessionSettingsTimeInput = document.getElementById('sessionSettingsTime');
  const sessionSettingsApplyBtn = document.getElementById('sessionSettingsApplyBtn');
  const scheduleSessionOverlay = document.getElementById('mentorScheduleSessionOverlay');
  const scheduleSessionEmailInput = document.getElementById('scheduleSessionEmailInput');
  const scheduleSessionSendBtn = document.getElementById('scheduleSessionSendBtn');
  const unsavedChangesOverlay = document.getElementById('mentorCalendarUnsavedChangesOverlay');
  const unsavedChangesDiscardBtn = document.getElementById('unsavedChangesDiscardBtn');
  const recurringDeleteOverlay = document.getElementById('mentorRecurringDeleteOverlay');
  const recurringDeleteOneBtn = document.getElementById('recurringDeleteOneBtn');
  const recurringDeleteAllBtn = document.getElementById('recurringDeleteAllBtn');
  const recurringMoveOverlay = document.getElementById('mentorRecurringMoveOverlay');
  const recurringMoveOneBtn = document.getElementById('recurringMoveOneBtn');
  const recurringMoveAllBtn = document.getElementById('recurringMoveAllBtn');
  
  if (!overlay || !root) return;

  let calendar = null;
  let availabilitySettingsEventId = null;
  let availabilitySwitchEventId = null;
  let availabilitySwitchOpenSettingsAfterSwitch = false;
  let sessionSwitchEventId = null;
  let sessionSwitchOpenSettingsAfterSwitch = false;
  let sessionSettingsEventId = null;
  let scheduleSessionEventId = null;
  let pendingRecurringDelete = null; // { eventId, recurringId, instanceDate }
  let pendingRecurringMove = null;   // { recurringId, instanceDate, newStartIso, newEndIso }

  // Timezone source of truth: mentorprofile.selected_timezone (fallback: detected_timezone)
  function resolveMentorTimezone() {
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const data = JSON.parse(dataEl.textContent);
        const selected = (data.selected_timezone || '').trim();
        const detected = (data.detected_timezone || '').trim();
        const tz = selected || detected || 'UTC';
        // Only accept IANA IDs or UTC
        if (tz === 'UTC' || tz.includes('/')) return tz;
      }
    } catch (e) {
      console.warn('[MentorCalendar] Could not parse userProfileData for timezone:', e);
    }
    return 'UTC';
  }

  // Slot length source of truth: mentorprofile.session_length (minutes)
  function resolveMentorSessionLengthMinutes() {
    try {
      const dataEl = document.getElementById('userProfileData');
      if (dataEl && dataEl.textContent) {
        const data = JSON.parse(dataEl.textContent);
        const raw = data?.session_length;
        const minutes = Number.parseInt(raw, 10);
        if (Number.isFinite(minutes) && minutes > 0 && minutes <= 24 * 60) return minutes;
      }
    } catch (e) {
      console.warn('[MentorCalendar] Could not parse userProfileData for session_length:', e);
    }
    return 60;
  }

  // Calendar timezone variable (used by FullCalendar init + save grouping)
  let timezone_variable = resolveMentorTimezone();

  // --- Availability settings popup helpers ---
  function setAvailabilitySettingsVisible(isVisible) {
    if (!availabilitySettingsOverlay) return;
    availabilitySettingsOverlay.classList.toggle('is-visible', !!isVisible);
    availabilitySettingsOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeAvailabilitySettings() {
    availabilitySettingsEventId = null;
    setAvailabilitySettingsVisible(false);
  }

  function openAvailabilitySettingsForEvent(fcEvent) {
    if (!availabilitySettingsOverlay || !fcEvent) return;
    if (!availabilitySettingsDateInput || !availabilitySettingsTimeInput) return;

    availabilitySettingsEventId = fcEvent.id || null;

    // Duration comes from mentor profile session_length
    const durationMinutes = resolveMentorSessionLengthMinutes();
    if (availabilitySettingsDurationMinutesEl) {
      availabilitySettingsDurationMinutesEl.textContent = String(durationMinutes);
    }

    // Populate start date/time in the calendar timezone
    try {
      if (window.luxon && window.luxon.DateTime && fcEvent.start) {
        const dt = window.luxon.DateTime.fromJSDate(fcEvent.start).setZone(timezone_variable);
        availabilitySettingsDateInput.value = dt.toISODate();      // YYYY-MM-DD
        availabilitySettingsTimeInput.value = dt.toFormat('HH:mm'); // 24h time
      }
    } catch (e) {
      console.warn('[MentorCalendar] Could not prefill availability settings:', e);
    }

    setAvailabilitySettingsVisible(true);
  }

  function applyAvailabilitySettings() {
    if (!calendar) return;
    if (!availabilitySettingsEventId) return;
    if (!availabilitySettingsDateInput || !availabilitySettingsTimeInput) return;

    const ev = calendar.getEventById(availabilitySettingsEventId);
    if (!ev) {
      closeAvailabilitySettings();
      return;
    }

    const dateStr = (availabilitySettingsDateInput.value || '').trim();
    const timeStr = (availabilitySettingsTimeInput.value || '').trim();
    if (!dateStr || !timeStr) {
      if (typeof showNotification === 'function') {
        showNotification('Please choose a date and time.', 'error');
      } else {
        alert('Please choose a date and time.');
      }
      return;
    }

    if (!(window.luxon && window.luxon.DateTime)) {
      console.warn('[MentorCalendar] Luxon is required for availability settings editing.');
      return;
    }

    const durationMinutes = resolveMentorSessionLengthMinutes();
    const dt = window.luxon.DateTime.fromISO(`${dateStr}T${timeStr}`, { zone: timezone_variable });
    if (!dt.isValid) {
      if (typeof showNotification === 'function') {
        showNotification('Invalid date/time.', 'error');
      } else {
        alert('Invalid date/time.');
      }
      return;
    }

    // If this is a recurring instance, update the recurring rule (not just this single rendered instance)
    if (ev.extendedProps?.isRecurringInstance && ev.extendedProps?.recurringId) {
      const recurringId = ev.extendedProps.recurringId;
      const rule = recurringAvailabilityRules.get(recurringId);
      if (rule) {
        rule.start_date = dateStr;
        rule.start_time = timeStr;
        rule.end_time = dt.plus({ minutes: durationMinutes }).toFormat('HH:mm');
        rule.anchor_date = dateStr;
        if (rule.type === 'weekly') {
          const wd = weekdayNameFromIsoDate(dateStr);
          rule.weekdays = wd ? [wd] : (rule.weekdays || []);
          rule.day_of_month = null;
        } else if (rule.type === 'monthly') {
          rule.day_of_month = dt.day;
          rule.weekdays = [];
        }
        recurringAvailabilityRules.set(recurringId, rule);
        markDirty('availability');
        renderRecurringInstancesForCurrentView();
        recomputeCollisions();
        closeAvailabilitySettings();
        return;
      }
    }

    // One-time slot: update this event directly
    const startJs = dt.toJSDate();
    const endJs = dt.plus({ minutes: durationMinutes }).toJSDate();

    ev.setStart(startJs);
    ev.setEnd(endJs);

    markDirty('availability');
    recomputeCollisions();
    closeAvailabilitySettings();
  }

  // --- Switch-to-availability-mode popup helpers ---
  function setAvailabilitySwitchVisible(isVisible) {
    if (!availabilitySwitchOverlay) return;
    availabilitySwitchOverlay.classList.toggle('is-visible', !!isVisible);
    availabilitySwitchOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeAvailabilitySwitchPopup() {
    availabilitySwitchEventId = null;
    setAvailabilitySwitchVisible(false);
  }

  function openAvailabilitySwitchPopupForEventId(eventId, openSettingsAfterSwitch) {
    if (!availabilitySwitchOverlay) return;
    availabilitySwitchEventId = eventId || null;
    availabilitySwitchOpenSettingsAfterSwitch = !!openSettingsAfterSwitch;
    setAvailabilitySwitchVisible(true);
  }

  function switchToAvailabilityModeAndOpenSettings() {
    if (!calendar) return;
    const id = availabilitySwitchEventId;
    const shouldOpenSettings = !!availabilitySwitchOpenSettingsAfterSwitch;
    closeAvailabilitySwitchPopup();
    if (!id) return;

    setMode(true);
    const ev = calendar.getEventById(id);
    if (ev && shouldOpenSettings) openAvailabilitySettingsForEvent(ev);
  }

  // --- Session settings popup helpers ---
  function setSessionSettingsVisible(isVisible) {
    if (!sessionSettingsOverlay) return;
    sessionSettingsOverlay.classList.toggle('is-visible', !!isVisible);
    sessionSettingsOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeSessionSettings() {
    sessionSettingsEventId = null;
    setSessionSettingsVisible(false);
  }

  function openSessionSettingsForEvent(fcEvent) {
    if (!sessionSettingsOverlay || !fcEvent) return;
    if (!sessionSettingsDateInput || !sessionSettingsTimeInput) return;

    sessionSettingsEventId = fcEvent.id || null;

    try {
      if (window.luxon && window.luxon.DateTime && fcEvent.start) {
        const dt = window.luxon.DateTime.fromJSDate(fcEvent.start).setZone(timezone_variable);
        sessionSettingsDateInput.value = dt.toISODate();
        sessionSettingsTimeInput.value = dt.toFormat('HH:mm');
      }
    } catch (e) {
      console.warn('[MentorCalendar] Could not prefill session settings:', e);
    }

    setSessionSettingsVisible(true);
  }

  function applySessionSettings() {
    if (!calendar) return;
    if (!sessionSettingsEventId) return;
    if (!sessionSettingsDateInput || !sessionSettingsTimeInput) return;

    const ev = calendar.getEventById(sessionSettingsEventId);
    if (!ev) {
      closeSessionSettings();
      return;
    }

    const dateStr = (sessionSettingsDateInput.value || '').trim();
    const timeStr = (sessionSettingsTimeInput.value || '').trim();
    if (!dateStr || !timeStr) {
      if (typeof showNotification === 'function') {
        showNotification('Please choose a date and time.', 'error');
      } else {
        alert('Please choose a date and time.');
      }
      return;
    }

    if (!(window.luxon && window.luxon.DateTime)) {
      console.warn('[MentorCalendar] Luxon is required for session settings editing.');
      return;
    }

    const dt = window.luxon.DateTime.fromISO(`${dateStr}T${timeStr}`, { zone: timezone_variable });
    if (!dt.isValid) {
      if (typeof showNotification === 'function') {
        showNotification('Invalid date/time.', 'error');
      } else {
        alert('Invalid date/time.');
      }
      return;
    }

    // Keep existing duration
    const prevStart = ev.start;
    const prevEnd = ev.end;
    const durationMs = (prevStart && prevEnd) ? (prevEnd.getTime() - prevStart.getTime()) : (resolveMentorSessionLengthMinutes() * 60 * 1000);

    const startJs = dt.toJSDate();
    const endJs = new Date(startJs.getTime() + Math.max(0, durationMs));

    ev.setStart(startJs);
    ev.setEnd(endJs);

    markDirty('session');
    recomputeCollisions();
    closeSessionSettings();
  }

  // --- Schedule session popup helpers ---
  function setScheduleSessionVisible(isVisible) {
    if (!scheduleSessionOverlay) return;
    scheduleSessionOverlay.classList.toggle('is-visible', !!isVisible);
    scheduleSessionOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeScheduleSessionPopup() {
    scheduleSessionEventId = null;
    if (scheduleSessionEmailInput) scheduleSessionEmailInput.value = '';
    setScheduleSessionVisible(false);
  }

  function openScheduleSessionPopupForEvent(fcEvent) {
    if (!scheduleSessionOverlay || !fcEvent) return;
    scheduleSessionEventId = fcEvent.id || null;
    setScheduleSessionVisible(true);
    if (scheduleSessionEmailInput) {
      scheduleSessionEmailInput.focus();
      scheduleSessionEmailInput.select?.();
    }
  }

  function sendScheduleSessionEmail() {
    const email = (scheduleSessionEmailInput?.value || '').trim();
    if (!email) {
      if (typeof showNotification === 'function') showNotification('Please enter an email.', 'error');
      else alert('Please enter an email.');
      return;
    }
    const ev = calendar && scheduleSessionEventId ? calendar.getEventById(scheduleSessionEventId) : null;
    console.log('[MentorCalendar] schedule session send', {
      email,
      eventId: scheduleSessionEventId,
      startIso: ev?.start ? ev.start.toISOString() : null,
      endIso: ev?.end ? ev.end.toISOString() : null
    });
    closeScheduleSessionPopup();
  }

  // --- Switch-to-sessions-mode popup helpers ---
  function setSessionSwitchVisible(isVisible) {
    if (!sessionSwitchOverlay) return;
    sessionSwitchOverlay.classList.toggle('is-visible', !!isVisible);
    sessionSwitchOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeSessionSwitchPopup() {
    sessionSwitchEventId = null;
    sessionSwitchOpenSettingsAfterSwitch = false;
    setSessionSwitchVisible(false);
  }

  function openSessionSwitchPopupForEventId(eventId, openSettingsAfterSwitch) {
    if (!sessionSwitchOverlay) return;
    sessionSwitchEventId = eventId || null;
    sessionSwitchOpenSettingsAfterSwitch = !!openSettingsAfterSwitch;
    setSessionSwitchVisible(true);
  }

  function switchToSessionsMode() {
    const id = sessionSwitchEventId;
    const shouldOpenSettings = !!sessionSwitchOpenSettingsAfterSwitch;
    closeSessionSwitchPopup();
    setMode(false);
    if (shouldOpenSettings && calendar && id) {
      const ev = calendar.getEventById(id);
      if (ev) openSessionSettingsForEvent(ev);
    }
  }

  // Track dates which originally had availability (for deletion support)
  let originalAvailabilityDates = new Set();

  // Distinguish single click vs double click on availability slots (Sessions mode)
  // Single click opens "Schedule session" popup, but we wait briefly to see if it's a double-click.
  let __availabilityClickTimer = null;
  let __availabilityClickEventId = null;

  // Recurring availability rules (source of truth, persisted to mentor_profile.recurring_slots)
  // Map<recurringId, rule>
  // rule: { id, type: 'daily'|'weekly'|'monthly', start_date, start_time, end_time, weekdays?, day_of_month?, skip_dates?, booked_dates?, slot_type }
  let recurringAvailabilityRules = new Map();
  // Track full-series deletions so backend removes them from recurring_slots
  let deletedRecurringRules = new Map(); // Map<recurringId, ruleSnapshot>

  // If the user tries to drag a recurring occurrence in a blocked view (month),
  // we'll blink the whole series to hint it's recurring.
  let lastBlockedRecurringDrag = null; // { recurringId: string, atMs: number }

  function generateClientId(prefix) {
    const rand = Math.random().toString(36).slice(2, 10);
    return `${prefix || 'id'}_${Date.now()}_${rand}`;
  }

  function blinkRecurringSeries(recurringId) {
    if (!root || !recurringId) return;
    const els = root.querySelectorAll(`.fc-event[data-recurring-id="${CSS.escape(recurringId)}"]`);
    els.forEach((el) => {
      el.classList.remove('recurring-blink');
      // restart animation
      // eslint-disable-next-line no-unused-expressions
      void el.offsetWidth;
      el.classList.add('recurring-blink');
      el.addEventListener('animationend', () => el.classList.remove('recurring-blink'), { once: true });
    });
  }

  function getLocalDateKeyFromJsDate(dateObj) {
    try {
      if (window.luxon && window.luxon.DateTime && dateObj instanceof Date) {
        return window.luxon.DateTime.fromJSDate(dateObj).setZone(timezone_variable).toISODate();
      }
    } catch (e) {}
    return dateObj instanceof Date ? dateObj.toISOString().split('T')[0] : '';
  }

  function getLocalTimeHHmmFromJsDate(dateObj) {
    try {
      if (window.luxon && window.luxon.DateTime && dateObj instanceof Date) {
        return window.luxon.DateTime.fromJSDate(dateObj).setZone(timezone_variable).toFormat('HH:mm');
      }
    } catch (e) {}
    return '';
  }

  function weekdayNameFromIsoDate(isoDate) {
    try {
      if (window.luxon && window.luxon.DateTime) {
        const dt = window.luxon.DateTime.fromISO(isoDate, { zone: timezone_variable });
        const names = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];
        // Luxon: 1=Monday..7=Sunday
        return names[Math.max(0, Math.min(6, dt.weekday - 1))];
      }
    } catch (e) {}
    return '';
  }

  function computeAnchorDateForRecurringRule(rule) {
    // Used only for saving weekly/monthly rules (backend derives weekdays/day_of_month from provided date)
    try {
      if (!(window.luxon && window.luxon.DateTime)) return null;
      const now = window.luxon.DateTime.now().setZone(timezone_variable).startOf('day');
      if (!rule || !rule.type) return now.toISODate();
      if (rule.type === 'daily') return now.toISODate();
      if (rule.type === 'weekly') {
        const target = Array.isArray(rule.weekdays) && rule.weekdays.length ? rule.weekdays[0] : null;
        if (!target) return now.toISODate();
        for (let i = 0; i < 14; i++) {
          const d = now.plus({ days: i });
          if (weekdayNameFromIsoDate(d.toISODate()) === target) return d.toISODate();
        }
        return now.toISODate();
      }
      if (rule.type === 'monthly') {
        const dom = Number(rule.day_of_month);
        if (!Number.isFinite(dom) || dom < 1) return now.toISODate();
        // choose current month if possible, else next month
        const candidateMonths = [0, 1];
        for (const addMonths of candidateMonths) {
          const m = now.plus({ months: addMonths });
          const daysInMonth = m.daysInMonth;
          const day = dom > daysInMonth ? daysInMonth : dom;
          const d = m.set({ day });
          if (d >= now) return d.toISODate();
        }
        return now.toISODate();
      }
    } catch (e) {}
    return null;
  }

  function clearRecurringInstanceEvents() {
    if (!calendar) return;
    calendar.getEvents().forEach(ev => {
      if (ev.extendedProps?.isRecurringInstance) ev.remove();
    });
  }

  function renderRecurringInstancesForCurrentView() {
    if (!calendar) return;
    if (!(window.luxon && window.luxon.DateTime)) return;
    clearRecurringInstanceEvents();

    const view = calendar.view;
    const start = view?.activeStart;
    const end = view?.activeEnd;
    if (!(start instanceof Date) || !(end instanceof Date)) return;

    const startDay = window.luxon.DateTime.fromJSDate(start).setZone(timezone_variable).startOf('day');
    const endDay = window.luxon.DateTime.fromJSDate(end).setZone(timezone_variable).startOf('day');
    const days = Math.max(0, Math.round(endDay.diff(startDay, 'days').days));

    recurringAvailabilityRules.forEach((rule) => {
      if (!rule || !rule.id || !rule.type) return;
      const skip = new Set(rule.skip_dates || []);
      const booked = new Set(rule.booked_dates || []);
      const startDate = String(rule.start_date || '');

      for (let i = 0; i < days; i++) {
        const d = startDay.plus({ days: i });
        const dateStr = d.toISODate();
        if (startDate && dateStr < startDate) continue;
        if (skip.has(dateStr) || booked.has(dateStr)) continue;

        let matches = false;
        if (rule.type === 'daily') {
          matches = true;
        } else if (rule.type === 'weekly') {
          const wd = weekdayNameFromIsoDate(dateStr);
          matches = Array.isArray(rule.weekdays) ? rule.weekdays.includes(wd) : false;
        } else if (rule.type === 'monthly') {
          const dom = Number(rule.day_of_month);
          if (Number.isFinite(dom) && dom > 0) {
            // Match exact day, or if dom > daysInMonth, match last day (backend behavior)
            const daysInMonth = d.daysInMonth;
            const targetDay = dom > daysInMonth ? daysInMonth : dom;
            matches = d.day === targetDay;
          }
        }
        if (!matches) continue;

        const startDt = window.luxon.DateTime.fromISO(`${dateStr}T${rule.start_time}`, { zone: timezone_variable });
        const endDt = window.luxon.DateTime.fromISO(`${dateStr}T${rule.end_time}`, { zone: timezone_variable });
        if (!startDt.isValid || !endDt.isValid) continue;
        if (endDt <= startDt) continue;

        const instanceId = `${rule.id}__${dateStr}`;
        calendar.addEvent({
          id: instanceId,
          start: startDt.toJSDate(),
          end: endDt.toJSDate(),
          allDay: false,
          backgroundColor: '#3b82f6',
          borderColor: '#2563eb',
          textColor: '#ffffff',
          classNames: ['event-type-availability', 'event-type-availability-recurring'],
          editable: true,
          extendedProps: {
            slotMode: 'availability',
            type: 'availability_slot',
            isRecurringInstance: true,
            recurringId: rule.id,
            instanceDate: dateStr,
            recurrence: rule.type
          }
        });
      }
    });

    // Recurring instances are real events. Some FullCalendar builds mount event DOM asynchronously,
    // so schedule collision recompute right after paint to ensure red styling applies immediately.
    try {
      window.requestAnimationFrame(() => recomputeCollisions());
    } catch (e) {
      setTimeout(() => recomputeCollisions(), 0);
    }
  }

  const GET_AVAILABILITY_URL = "{% url 'general:dashboard_mentor:get_availability' %}";
  const SAVE_AVAILABILITY_URL = "{% url 'general:dashboard_mentor:save_availability' %}";

  // Save button enablement:
  // - availability changes: persisted by Save
  // - session changes: not persisted yet, but should still enable Save (per your rule)
  let dirtyAvailability = false;
  let dirtySession = false;

  function updateSaveButtonState() {
    if (!saveBtn) return;
    const isDirty = dirtyAvailability || dirtySession;
    saveBtn.disabled = !isDirty;
  }

  function setSaveButtonLoading(isLoading) {
    if (!saveBtn) return;
    const next = !!isLoading;
    saveBtn.classList.toggle('is-loading', next);
    saveBtn.setAttribute('aria-busy', next ? 'true' : 'false');
    if (next) saveBtn.disabled = true;
  }

  function markDirty(slotMode) {
    if (slotMode === 'availability') dirtyAvailability = true;
    else if (slotMode === 'session') dirtySession = true;
    else dirtyAvailability = true; // conservative fallback
    updateSaveButtonState();
  }

  function clearDirtyAvailability() {
    dirtyAvailability = false;
    updateSaveButtonState();
  }

  function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    return null;
  }

  function getLocalDateKeyFromUtcIso(isoUtc) {
    try {
      if (window.luxon && window.luxon.DateTime) {
        return window.luxon.DateTime.fromISO(isoUtc, { zone: 'utc' })
          .setZone(timezone_variable)
          .toISODate();
      }
    } catch (e) {}
    // Fallback: UTC date
    return String(isoUtc).split('T')[0];
  }

  async function loadSavedAvailability() {
    if (!calendar) return;
    try {
      const res = await fetch(GET_AVAILABILITY_URL, { headers: { 'Accept': 'application/json' } });
      const data = await res.json();
      if (!data.success) {
        console.warn('[MentorCalendar] get_availability failed:', data);
        return;
      }

      // Remove only availability events; keep session events created client-side (ignored for save)
      calendar.getEvents().forEach(ev => {
        if (ev.extendedProps?.slotMode === 'availability') ev.remove();
      });

      originalAvailabilityDates = new Set();
      recurringAvailabilityRules = new Map();
      deletedRecurringRules = new Map();
      // Ensure recurrence UI selections reflect persisted recurring rules
      window.MentorCalendarRecurrenceSelections = window.MentorCalendarRecurrenceSelections || {};

      const slots = Array.isArray(data.one_time_slots) ? data.one_time_slots : [];
      slots.forEach(slot => {
        // Ignore non-availability for now
        if (slot.type && slot.type !== 'availability_slot') return;

        if (!slot.start || !slot.end) return;
        const startIso = slot.start;
        const endIso = slot.end;

        // Track local date keys for deletion support
        originalAvailabilityDates.add(getLocalDateKeyFromUtcIso(startIso));

        calendar.addEvent({
          id: slot.id || ('availability_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8)),
          start: startIso,
          end: endIso,
          allDay: false,
          backgroundColor: '#3b82f6',
          borderColor: '#2563eb',
          textColor: '#ffffff',
          classNames: ['event-type-availability'], // Added class
          // Allow drag start in Sessions mode so we can show the switch popup on drop.
          // The move will be reverted in eventDrop if not in Availability mode.
          editable: true,
          extendedProps: { slotMode: 'availability', type: 'availability_slot' }
        });
      });

      // Load recurring rules (raw JSON) and render occurrences for the current view
      const recurring = Array.isArray(data.recurring_slots) ? data.recurring_slots : [];
      recurring.forEach((rule) => {
        const id = String(rule?.id || '');
        const type = String(rule?.type || '');
        if (!id || !type) return;
        const start_time = String(rule?.start_time || '');
        const end_time = String(rule?.end_time || '');
        if (!start_time || !end_time) return;

        const start_date = String(rule?.start_date || '') || (rule?.created_at ? String(rule.created_at).split('T')[0] : '') || getLocalDateKeyFromUtcIso(new Date().toISOString());

        const normalized = {
          id,
          type, // daily|weekly|monthly
          slot_type: rule?.slot_type || 'availability_slot',
          start_date,
          start_time,
          end_time,
          weekdays: Array.isArray(rule?.weekdays) ? rule.weekdays : [],
          day_of_month: rule?.day_of_month ?? null,
          skip_dates: Array.isArray(rule?.skip_dates) ? rule.skip_dates : [],
          booked_dates: Array.isArray(rule?.booked_dates) ? rule.booked_dates : [],
          created_at: rule?.created_at || null
        };
        normalized.anchor_date = start_date;
        recurringAvailabilityRules.set(id, normalized);
        window.MentorCalendarRecurrenceSelections[id] = type;
      });
      renderRecurringInstancesForCurrentView();

      console.log('[MentorCalendar] loaded availability slots:', slots.length);
      recomputeCollisions();
      // Loaded state matches DB for availability
      clearDirtyAvailability();
    } catch (e) {
      console.error('[MentorCalendar] error loading availability:', e);
    }
  }

  // --- Collision detection (availability only) ---
  const COLLISION_HORIZON_DAYS = 90;
  let openedFromSessionLengthChange = false;

  window.setOpenedFromSessionLengthChange = function(value) {
    openedFromSessionLengthChange = !!value;
  };
  window.getOpenedFromSessionLengthChange = function() {
    return !!openedFromSessionLengthChange;
  };

  function computeAvailabilityCollisionsInHorizon() {
    if (!(window.luxon && window.luxon.DateTime) || !calendar) return [];

    const DateTime = window.luxon.DateTime;
    const todayLocal = DateTime.now().setZone(timezone_variable).startOf('day');
    const endLocal = todayLocal.plus({ days: COLLISION_HORIZON_DAYS }).startOf('day'); // exclusive

    const occurrencesByDate = new Map(); // dateStr -> occurrence[]
    const ensureBucket = (dateStr) => {
      if (!occurrencesByDate.has(dateStr)) occurrencesByDate.set(dateStr, []);
      return occurrencesByDate.get(dateStr);
    };

    // One-time availability events already in the calendar (exclude rendered recurring instances)
    calendar.getEvents().forEach((ev) => {
      if (ev.extendedProps?.slotMode !== 'availability') return;
      if (ev.extendedProps?.isRecurringInstance) return;
      if (!ev.start || !ev.end) return;

      const startDt = DateTime.fromJSDate(ev.start).setZone(timezone_variable);
      const endDt = DateTime.fromJSDate(ev.end).setZone(timezone_variable);
      if (!startDt.isValid || !endDt.isValid || endDt <= startDt) return;

      const day = startDt.startOf('day');
      if (day < todayLocal || day >= endLocal) return;

      const dateStr = day.toISODate();
      ensureBucket(dateStr).push({
        kind: 'one_time',
        id: String(ev.id || ''),
        startDt,
        endDt
      });
    });

    // Recurring rules expanded in-horizon (do not render)
    const matchesRuleOnDate = (ruleObj, dateStr, dayDt) => {
      if (!ruleObj || !ruleObj.type) return false;
      if (ruleObj.start_date && dateStr < ruleObj.start_date) return false;
      if (Array.isArray(ruleObj.skip_dates) && ruleObj.skip_dates.includes(dateStr)) return false;

      if (ruleObj.type === 'daily') return true;
      if (ruleObj.type === 'weekly') {
        const wd = weekdayNameFromIsoDate(dateStr);
        return Array.isArray(ruleObj.weekdays) ? ruleObj.weekdays.includes(wd) : false;
      }
      if (ruleObj.type === 'monthly') {
        const dom = Number(ruleObj.day_of_month);
        if (!Number.isFinite(dom) || dom < 1) return false;
        const daysInMonth = dayDt.daysInMonth;
        const targetDay = dom > daysInMonth ? daysInMonth : dom;
        return dayDt.day === targetDay;
      }
      return false;
    };

    recurringAvailabilityRules.forEach((rule) => {
      if (!rule || !rule.id || !rule.type) return;
      const startTime = String(rule.start_time || '');
      const endTime = String(rule.end_time || '');
      if (!startTime || !endTime) return;

      let cursor = todayLocal;
      if (rule.start_date) {
        const rs = DateTime.fromISO(String(rule.start_date), { zone: timezone_variable }).startOf('day');
        if (rs.isValid && cursor < rs) cursor = rs;
      }

      while (cursor < endLocal) {
        const dateStr = cursor.toISODate();
        if (matchesRuleOnDate(rule, dateStr, cursor)) {
          const startDt = DateTime.fromISO(`${dateStr}T${startTime}`, { zone: timezone_variable });
          const endDt = DateTime.fromISO(`${dateStr}T${endTime}`, { zone: timezone_variable });
          if (startDt.isValid && endDt.isValid && endDt > startDt) {
            ensureBucket(dateStr).push({
              kind: 'rec_occ',
              recurringId: String(rule.id),
              instanceDate: dateStr,
              startDt,
              endDt
            });
          }
        }
        cursor = cursor.plus({ days: 1 });
      }
    });

    const overlaps = (a, b) => a.startDt < b.endDt && b.startDt < a.endDt;

    const oneOne = [];
    const oneRec = [];
    const recRecMap = new Map(); // pairKey -> collision

    occurrencesByDate.forEach((list, dateStr) => {
      if (!Array.isArray(list) || list.length < 2) return;
      const sorted = list.slice().sort((x, y) => x.startDt.toMillis() - y.startDt.toMillis());

      for (let i = 0; i < sorted.length; i++) {
        for (let j = i + 1; j < sorted.length; j++) {
          const a = sorted[i];
          const b = sorted[j];
          if (!overlaps(a, b)) continue;

          // one-time vs one-time
          if (a.kind === 'one_time' && b.kind === 'one_time') {
            const ids = [a.id, b.id].sort();
            oneOne.push({
              type: 'one_one',
              key: `one_one|${dateStr}|${ids[0]}|${ids[1]}`,
              slot1: { id: a.id, start: a.startDt.toISO(), end: a.endDt.toISO(), kind: 'one_time' },
              slot2: { id: b.id, start: b.startDt.toISO(), end: b.endDt.toISO(), kind: 'one_time' }
            });
            continue;
          }

          // one-time vs recurring occurrence
          if ((a.kind === 'one_time' && b.kind === 'rec_occ') || (a.kind === 'rec_occ' && b.kind === 'one_time')) {
            const one = (a.kind === 'one_time') ? a : b;
            const rec = (a.kind === 'rec_occ') ? a : b;
            oneRec.push({
              type: 'one_rec',
              key: `one_rec|${dateStr}|${one.id}|${rec.recurringId}`,
              slot1: { id: one.id, start: one.startDt.toISO(), end: one.endDt.toISO(), kind: 'one_time' },
              slot2: { id: rec.recurringId, start: rec.startDt.toISO(), end: rec.endDt.toISO(), kind: 'rec_occ', recurringId: rec.recurringId, instanceDate: rec.instanceDate }
            });
            continue;
          }

          // recurring occurrence vs recurring occurrence (aggregate)
          if (a.kind === 'rec_occ' && b.kind === 'rec_occ') {
            const ridA = String(a.recurringId);
            const ridB = String(b.recurringId);
            if (!ridA || !ridB || ridA === ridB) continue;
            const pair = [ridA, ridB].sort();
            const pairKey = `rec_rec|${pair[0]}|${pair[1]}`;
            const existing = recRecMap.get(pairKey);
            const candidateStart = (a.startDt < b.startDt ? a.startDt : b.startDt);
            if (!existing || candidateStart.toMillis() < Date.parse(existing.slot1.start || existing.slot2.start || '')) {
              recRecMap.set(pairKey, {
                type: 'rec_rec',
                key: pairKey,
                slot1: { id: pair[0], start: a.startDt.toISO(), end: a.endDt.toISO(), kind: 'rec_occ', recurringId: pair[0], instanceDate: dateStr },
                slot2: { id: pair[1], start: b.startDt.toISO(), end: b.endDt.toISO(), kind: 'rec_occ', recurringId: pair[1], instanceDate: dateStr }
              });
            }
          }
        }
      }
    });

    const recRec = Array.from(recRecMap.values());
    const all = oneOne.concat(oneRec, recRec);
    all.sort((x, y) => {
      const xs = Date.parse(x?.slot1?.start || '') || 0;
      const ys = Date.parse(y?.slot1?.start || '') || 0;
      return xs - ys;
    });
    return all;
  }

  function hasAvailabilityCollisionsInHorizon() {
    return computeAvailabilityCollisionsInHorizon().length > 0;
  }

  window.getCalendarCollisions = function() {
    return computeAvailabilityCollisionsInHorizon();
  };

  window.navigateToCollisionInCalendarByCollision = function(collision) {
    if (!calendar || !(window.luxon && window.luxon.DateTime)) return;
    try {
      // Ensure Availability mode for resolution UX
      setMode(true);
      const startIso = collision?.slot1?.start || collision?.slot2?.start;
      if (!startIso) return;
      const dt = window.luxon.DateTime.fromISO(String(startIso)).setZone(timezone_variable);
      if (!dt.isValid) return;

      calendar.changeView('timeGridDay');
      calendar.gotoDate(dt.toJSDate());
      setTimeout(() => {
        try {
          calendar.scrollToTime(dt.toFormat('HH:mm:ss'));
        } catch (e) {}
        // Blink involved series to make recurrence obvious
        if (collision?.type === 'rec_rec') {
          if (collision?.slot1?.id) blinkRecurringSeries(String(collision.slot1.id));
          if (collision?.slot2?.id) blinkRecurringSeries(String(collision.slot2.id));
        } else if (collision?.type === 'one_rec') {
          const rid = collision?.slot2?.recurringId || collision?.slot2?.id;
          if (rid) blinkRecurringSeries(String(rid));
        }
      }, 150);
    } catch (e) {
      console.warn('[MentorCalendar] navigateToCollisionInCalendarByCollision failed:', e);
    }
  };

  window.deleteAllCollidingAvailabilitySlots = async function(collisionList, opts) {
    if (!calendar) return;
    const collisions = Array.isArray(collisionList) ? collisionList : [];
    const oneTimeIdsToDelete = new Set();
    const recurringIdsToDelete = new Set();

    collisions.forEach((c) => {
      const type = c?.type;
      const a = c?.slot1 || {};
      const b = c?.slot2 || {};

      if (type === 'one_one') {
        if (a.id) oneTimeIdsToDelete.add(String(a.id));
        if (b.id) oneTimeIdsToDelete.add(String(b.id));
      } else if (type === 'one_rec') {
        // delete only the one-time slot
        if (a.kind === 'one_time' && a.id) oneTimeIdsToDelete.add(String(a.id));
        else if (b.kind === 'one_time' && b.id) oneTimeIdsToDelete.add(String(b.id));
      } else if (type === 'rec_rec') {
        if (a.id) recurringIdsToDelete.add(String(a.id));
        if (b.id) recurringIdsToDelete.add(String(b.id));
      }
    });

    // Delete one-time slots (events)
    oneTimeIdsToDelete.forEach((id) => {
      const ev = calendar.getEventById(id);
      if (ev) ev.remove();
      try {
        if (window.MentorCalendarRecurrenceSelections) delete window.MentorCalendarRecurrenceSelections[id];
      } catch (e) {}
    });

    // Delete recurring series completely (both rules, plus rendered instances)
    recurringIdsToDelete.forEach((rid) => {
      const existing = recurringAvailabilityRules.get(rid);
      if (existing) deletedRecurringRules.set(rid, existing);
      recurringAvailabilityRules.delete(rid);
      try {
        if (window.MentorCalendarRecurrenceSelections) delete window.MentorCalendarRecurrenceSelections[rid];
      } catch (e) {}
      // Remove any rendered instances in current view
      calendar.getEvents().forEach((ev) => {
        if (ev.extendedProps?.recurringId === rid || String(ev.id || '').startsWith(rid + '__')) {
          ev.remove();
        }
      });
    });

    if (oneTimeIdsToDelete.size > 0 || recurringIdsToDelete.size > 0) {
      markDirty('availability');
      renderRecurringInstancesForCurrentView();
      recomputeCollisions();
      // Persist immediately (matches old "delete all" behavior)
      await saveAvailabilityToBackend();
    }
  };

  async function saveAvailabilityToBackend() {
    if (!calendar) return;

    // Block save if there are availability collisions in horizon
    const collisions = computeAvailabilityCollisionsInHorizon();
    if (collisions.length > 0) {
      if (typeof window.openCollisionResolutionPopup === 'function') {
        window.openCollisionResolutionPopup(false);
      }
      if (typeof showNotification === 'function') {
        showNotification('Please resolve collisions before saving.', 'warning');
      }
      return;
    }

    setSaveButtonLoading(true);

    try {
      const availabilityEvents = calendar.getEvents().filter(ev =>
        ev.extendedProps?.slotMode === 'availability' && !ev.extendedProps?.isRecurringInstance
      );

      const oneTimePayload = availabilityEvents.map(ev => {
        const startIso = ev.start ? ev.start.toISOString() : null;
        const endIso = ev.end ? ev.end.toISOString() : null;
        if (!startIso || !endIso) return null;

        const dateKey = getLocalDateKeyFromUtcIso(startIso);
        const length = Math.max(0, Math.round((Date.parse(endIso) - Date.parse(startIso)) / 60000));

        const item = {
          id: ev.id,
          type: 'availability_slot',
          date: dateKey,
          start_iso: startIso,
          end_iso: endIso,
          length: length
        };

        // If this event is a conversion from recurring -> one-time, include recurring_slot_id
        if (ev.extendedProps?.recurringSlotId) {
          item.recurring_slot_id = ev.extendedProps.recurringSlotId;
        }
        return item;
      }).filter(Boolean);

      // Recurring rules payload (one item per rule)
      const recurringPayload = Array.from(recurringAvailabilityRules.values()).map((rule) => {
        if (!rule || !rule.id || !rule.type) return null;
        const startDate = rule.start_date || rule.anchor_date || computeAnchorDateForRecurringRule(rule) || getLocalDateKeyFromUtcIso(new Date().toISOString());
        return {
          // Backend uses recurring_slot_id as the source-of-truth ID
          recurring_slot_id: rule.id,
          is_recurring: true,
          recurrence_rule: rule.type, // daily|weekly|monthly
          slot_type: rule.slot_type || 'availability_slot',
          date: startDate,
          start_date: startDate,
          start: rule.start_time,
          end: rule.end_time,
          skip_dates: Array.isArray(rule.skip_dates) ? rule.skip_dates : [],
          booked_dates: Array.isArray(rule.booked_dates) ? rule.booked_dates : []
        };
      }).filter(Boolean);

      // Deleted recurring series (delete_all): backend will remove by id
      const deleteSeriesPayload = Array.from(deletedRecurringRules.values()).map((rule) => {
        if (!rule || !rule.id) return null;
        const startDate = rule.start_date || getLocalDateKeyFromUtcIso(new Date().toISOString());
        return {
          recurring_slot_id: rule.id,
          is_recurring: true,
          recurrence_rule: rule.type || 'weekly',
          delete_all: true,
          date: startDate,
          start_date: startDate,
          start: rule.start_time || '09:00',
          end: rule.end_time || '10:00'
        };
      }).filter(Boolean);

      const availabilityPayload = oneTimePayload.concat(recurringPayload, deleteSeriesPayload);

      // edited_dates must include previous dates too, for deletion behavior
      const editedDates = new Set(originalAvailabilityDates);
      oneTimePayload.forEach(item => editedDates.add(item.date));

      const editedDatesArr = Array.from(editedDates);
      const selectedDate = editedDatesArr[0] || getLocalDateKeyFromUtcIso(new Date().toISOString());

      const csrf = getCookie('csrftoken');
      if (!csrf) {
        console.warn('[MentorCalendar] Missing csrftoken cookie');
      }

      const res = await fetch(SAVE_AVAILABILITY_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': csrf || ''
        },
        body: JSON.stringify({
          availability: availabilityPayload,
          selected_date: selectedDate,
          edited_dates: editedDatesArr
        })
      });
      const data = await res.json();
      if (!data.success) {
        console.warn('[MentorCalendar] save_availability failed:', data);
        return;
      }

      console.log('[MentorCalendar] saved availability:', {
        oneTime: oneTimePayload.length,
        recurring: recurringPayload.length,
        deletedRecurring: deleteSeriesPayload.length
      });
      await loadSavedAvailability();
      if (typeof showNotification === 'function') {
        showNotification('Saved successfully.', 'success');
      }
      // After a successful save, disable the Save button again.
      dirtyAvailability = false;
      dirtySession = false;
    } catch (e) {
      console.error('[MentorCalendar] error saving availability:', e);
    } finally {
      setSaveButtonLoading(false);
      updateSaveButtonState();
    }
  }

  // Mode toggle (for now: only boolean + logs)
  // false = Sessions (green), true = Availability (blue)
  let isAvailabilityMode = false;

  function rangesOverlap(aStart, aEnd, bStart, bEnd) {
    if (!aStart || !aEnd || !bStart || !bEnd) return false;
    const a0 = aStart.getTime();
    const a1 = aEnd.getTime();
    const b0 = bStart.getTime();
    const b1 = bEnd.getTime();
    // Strict overlap (touching at boundary is NOT a collision)
    return a0 < b1 && b0 < a1;
  }

  function recomputeCollisions() {
    if (!calendar) return;

    const activeMode = isAvailabilityMode ? 'availability' : 'session';
    const allEvents = calendar.getEvents();
    const activeEvents = allEvents.filter(ev => ev.extendedProps?.slotMode === activeMode);

    const collisionIds = new Set();

    for (let i = 0; i < activeEvents.length; i++) {
      const a = activeEvents[i];
      const aStart = a.start;
      const aEnd = a.end;
      if (!aStart || !aEnd) continue;

      for (let j = 0; j < allEvents.length; j++) {
        const b = allEvents[j];
        if (!b || b.id === a.id) continue;
        const bStart = b.start;
        const bEnd = b.end;
        if (!bStart || !bEnd) continue;

        if (rangesOverlap(aStart, aEnd, bStart, bEnd)) {
          // Always mark the active-mode event red if it overlaps ANY other event.
          collisionIds.add(a.id);
          // If the other event is ALSO active-mode, it should be marked red too.
          if (b.extendedProps?.slotMode === activeMode) collisionIds.add(b.id);
        }
      }
    }

    let changed = false;
    allEvents.forEach(ev => {
      // Only events for the currently selected mode can be flagged red.
      const shouldFlag = (ev.extendedProps?.slotMode === activeMode) && collisionIds.has(ev.id);
      const currentFlag = !!ev.extendedProps?.hasCollision;
      if (currentFlag !== shouldFlag) {
        ev.setExtendedProp('hasCollision', shouldFlag);
        changed = true;
      }
    });

    // Some FullCalendar builds don't re-run `eventClassNames` when extendedProps change.
    // To ensure collisions appear red immediately, toggle the DOM class directly.
    try {
      if (root) {
        const els = root.querySelectorAll('.fc-event[data-event-id]');
        els.forEach((el) => {
          const id = String(el.dataset.eventId || '');
          if (!id) return;
          const ev = calendar.getEventById(id);
          if (!ev) return;
          const shouldFlag = (ev.extendedProps?.slotMode === activeMode) && collisionIds.has(id);
          el.classList.toggle('is-collision', !!shouldFlag);
        });
      }
    } catch (e) {
      // Never let collision rendering break navigation.
      console.warn('[MentorCalendar] collision DOM update failed:', e);
    }
  }

  function renderModeToggle() {
    if (!modeSessionsBtn || !modeAvailabilityBtn) return;
    modeSessionsBtn.classList.toggle('is-active', !isAvailabilityMode);
    modeAvailabilityBtn.classList.toggle('is-active', isAvailabilityMode);
  }

  function setMode(nextIsAvailability) {
    isAvailabilityMode = !!nextIsAvailability;
    renderModeToggle();
    
    // Toggle class on root for CSS styling
    if (root) {
      if (isAvailabilityMode) {
        root.classList.add('is-mode-availability');
      } else {
        root.classList.remove('is-mode-availability');
      }
    }

    // Update editability of all existing events
    if (calendar) {
      calendar.getEvents().forEach(ev => {
        const slotMode = ev.extendedProps?.slotMode;
        let shouldBeEditable = false;
        
        if (slotMode === 'availability') {
          // Allow drag start in Sessions mode so we can show the switch popup on drop.
          // The move will be reverted if not in Availability mode.
          shouldBeEditable = true;
        } else if (slotMode === 'session') {
          // Allow drag start in Availability mode so we can show the switch popup on drop.
          // The move/resize will be reverted if not in Sessions mode.
          shouldBeEditable = true;
        } else {
          shouldBeEditable = false;
        }
        
        // Use setProp to update the 'editable' property
        ev.setProp('editable', shouldBeEditable);
      });
    }

    console.log('[MentorCalendar] isAvailabilityMode =', isAvailabilityMode);
    recomputeCollisions();
  }

  function initCalendar(initialView, initialDate) {
    if (calendar) return;
    if (!window.FullCalendar || !window.FullCalendar.Calendar) {
      console.error('[MentorCalendar] FullCalendar not loaded');
      return;
    }
    if (!window.FullCalendarLuxon3) {
      console.warn('[MentorCalendar] FullCalendarLuxon3 plugin not loaded. Named IANA timeZone values may behave like local time.');
    }
    if (!window.FullCalendarInteraction) {
      console.warn('[MentorCalendar] FullCalendarInteraction plugin not loaded. Drag/drop and dateClick may not work.');
    }

    calendar = new FullCalendar.Calendar(root, {
      plugins: [
        ...(window.FullCalendarLuxon3 ? [window.FullCalendarLuxon3] : []),
        ...(window.FullCalendarInteraction ? [window.FullCalendarInteraction] : [])
      ],
      timeZone: timezone_variable,
      initialView: initialView || 'timeGridWeek',
      initialDate: initialDate || undefined,
      height: '100%',
      nowIndicator: true,
      headerToolbar: false, // Custom header
      allDaySlot: false,
      editable: true, // enables drag+resize (fine-grained control below)
      eventStartEditable: true, // allow dragging for both slot types
      eventDurationEditable: function(info) {
        // Only Session slots can be resized
        return info.event.extendedProps?.slotMode === 'session';
      },
      eventResizableFromStart: function(info) {
        // Only Session slots can be resized (from either edge)
        return info.event.extendedProps?.slotMode === 'session';
      },
      eventAllow: function(dropInfo, draggedEvent) {
        // For recurring availability instances:
        // - allow moving across days in timeGrid views (we'll prompt for "this one" vs "all future")
        // - disallow dragging in Month view (dayGridMonth) for clarity
        try {
          if (draggedEvent?.extendedProps?.isRecurringInstance) {
            const viewType = calendar?.view?.type;
            if (viewType === 'dayGridMonth') {
              lastBlockedRecurringDrag = { recurringId: String(draggedEvent.extendedProps.recurringId || ''), atMs: Date.now() };
              return false;
            }
          }
        } catch (e) {}
        return true;
      },
      eventClassNames: function(arg) {
        return arg.event.extendedProps?.hasCollision ? ['is-collision'] : [];
      },

      eventDidMount: function(info) {
        // Double-click slots -> open settings (or prompt to switch modes)
        try {
          const mode = info.event?.extendedProps?.slotMode;
          if (!info.el) return;
          // Used by collision DOM updates (some builds don't rerender classes reliably)
          info.el.dataset.eventId = String(info.event?.id || '');

          // Tag recurring instances so we can style the whole series (blink)
          if (info.event?.extendedProps?.isRecurringInstance && info.event?.extendedProps?.recurringId) {
            info.el.dataset.recurringId = String(info.event.extendedProps.recurringId);
            if (info.event.extendedProps.instanceDate) info.el.dataset.instanceDate = String(info.event.extendedProps.instanceDate);
          }

          // Availability slot: in Sessions mode, single click schedules session (debounced).
          if (mode === 'availability') {
            info.el.addEventListener('click', (e) => {
              // Only for Sessions mode
              if (isAvailabilityMode) return;

              // If a previous timer is pending, clear it (we'll overwrite with this click)
              if (__availabilityClickTimer) {
                clearTimeout(__availabilityClickTimer);
                __availabilityClickTimer = null;
              }
              __availabilityClickEventId = info.event.id;

              // Wait a bit to see if this becomes a double-click
              __availabilityClickTimer = window.setTimeout(() => {
                __availabilityClickTimer = null;
                __availabilityClickEventId = null;
                openScheduleSessionPopupForEvent(info.event);
              }, 220);

              e.preventDefault();
              e.stopPropagation();
            });
          }

          info.el.addEventListener('dblclick', (e) => {
            // Cancel any pending single-click schedule action for this availability event
            if (mode === 'availability' && __availabilityClickTimer && __availabilityClickEventId === info.event.id) {
              clearTimeout(__availabilityClickTimer);
              __availabilityClickTimer = null;
              __availabilityClickEventId = null;
            }

            e.preventDefault();
            e.stopPropagation();
            if (mode === 'availability') {
              if (!isAvailabilityMode) {
                openAvailabilitySwitchPopupForEventId(info.event.id, true);
                return;
              }
              openAvailabilitySettingsForEvent(info.event);
              return;
            }

            if (mode === 'session') {
              if (isAvailabilityMode) {
                openSessionSwitchPopupForEventId(info.event.id, true);
                return;
              }
              openSessionSettingsForEvent(info.event);
            }
          });
        } catch (e) {
          // non-fatal
          console.warn('[MentorCalendar] eventDidMount dblclick bind failed:', e);
        }
      },
      eventDragStop: function(info) {
        // If we just blocked a recurring drag (e.g., Month view), blink the series.
        try {
          if (info?.event?.extendedProps?.isRecurringInstance) {
            const rid = String(info.event.extendedProps.recurringId || '');
            if (lastBlockedRecurringDrag && lastBlockedRecurringDrag.recurringId === rid) {
              const dt = Date.now() - (lastBlockedRecurringDrag.atMs || 0);
              // only trigger near the time the block happened (avoid stale)
              if (dt >= 0 && dt < 800) {
                blinkRecurringSeries(rid);
              }
              lastBlockedRecurringDrag = null;
            }
          }
        } catch (e) {}
      },
      slotDuration: '00:05:00',
      snapDuration: '00:05:00',
      slotLabelInterval: '01:00:00',
      
      // Events
      datesSet: function(info) {
        updateDateTitle(info.view.title);
        updateActiveViewButton(info.view.type);
        styleGridLines();
        renderRecurringInstancesForCurrentView();
      },
      eventDrop: function(info) {
        const mode = info.event.extendedProps?.slotMode;
        // Recurring instances: confirm move (one occurrence vs all).
        if (mode === 'availability' && info.event.extendedProps?.isRecurringInstance && isAvailabilityMode) {
          const recurringId = info.event.extendedProps?.recurringId;
          const instanceDate = info.event.extendedProps?.instanceDate || getLocalDateKeyFromJsDate(info.event.start);
          const newStartIso = info.event.start ? info.event.start.toISOString() : null;
          const newEndIso = info.event.end ? info.event.end.toISOString() : null;
          info.revert(); // keep UI stable until user chooses
          if (recurringId && instanceDate && newStartIso && newEndIso) {
            pendingRecurringMove = { recurringId, instanceDate, newStartIso, newEndIso };
            // Button label: if we're going to materialize dates between today and instanceDate,
            // make it explicit this affects only future slots.
            try {
              if (window.luxon && window.luxon.DateTime) {
                const rule = recurringAvailabilityRules.get(recurringId);
                const todayLocal = window.luxon.DateTime.now().setZone(timezone_variable).startOf('day');
                const effectiveStart = rule?.start_date
                  ? window.luxon.DateTime.fromISO(String(rule.start_date), { zone: timezone_variable }).startOf('day')
                  : todayLocal;
                const windowStart = (effectiveStart.isValid && effectiveStart > todayLocal) ? effectiveStart : todayLocal;
                const instanceDay = window.luxon.DateTime.fromISO(String(instanceDate), { zone: timezone_variable }).startOf('day');
                const shouldMaterialize = windowStart.isValid && instanceDay.isValid && windowStart < instanceDay;
                setRecurringMoveAllButtonLabel(shouldMaterialize ? 'All future slots' : 'All');
              } else {
                setRecurringMoveAllButtonLabel('All');
              }
            } catch (e) {
              setRecurringMoveAllButtonLabel('All');
            }
            setRecurringMoveVisible(true);
          }
          return;
        }
        // Dragging availability in Sessions mode: revert and prompt to switch
        if (mode === 'availability' && !isAvailabilityMode) {
          info.revert();
          openAvailabilitySwitchPopupForEventId(info.event.id, false);
          return;
        }
        // Dragging session in Availability mode: revert and prompt to switch
        if (mode === 'session' && isAvailabilityMode) {
          info.revert();
          openSessionSwitchPopupForEventId(info.event.id, false);
          return;
        }
        console.log('[MentorCalendar] eventDrop', {
          mode,
          id: info.event.id,
          startIso: info.event.start ? info.event.start.toISOString() : null,
          endIso: info.event.end ? info.event.end.toISOString() : null,
          timeZone: timezone_variable
        });
        markDirty(mode);
        recomputeCollisions();
      },
      // eventClick is intentionally unused for availability slots because we debounce
      // single-click vs double-click inside eventDidMount.
      eventResize: function(info) {
        const mode = info.event.extendedProps?.slotMode;
        if (mode !== 'session') {
          // Safety: availability should never resize
          info.revert();
          console.log('[MentorCalendar] prevented resize for non-session slot', { id: info.event.id, mode });
          return;
        }
        // Resizing session in Availability mode: revert and prompt to switch
        if (isAvailabilityMode) {
          info.revert();
          openSessionSwitchPopupForEventId(info.event.id, false);
          return;
        }
        console.log('[MentorCalendar] eventResize', {
          mode,
          id: info.event.id,
          startIso: info.event.start ? info.event.start.toISOString() : null,
          endIso: info.event.end ? info.event.end.toISOString() : null,
          timeZone: timezone_variable
        });
        markDirty('session');
        recomputeCollisions();
      },
      dateClick: function(info) {
        // One-click slot creation only in Day/Week timeGrid views
        const viewType = info.view?.type;
        if (viewType !== 'timeGridDay' && viewType !== 'timeGridWeek') return;

        const mode = isAvailabilityMode ? 'availability' : 'session';
        // Use mentor profile session_length (minutes) for slot length
        const durationMinutes = resolveMentorSessionLengthMinutes();

        const startIso = info.date.toISOString();
        const endIso = new Date(info.date.getTime() + durationMinutes * 60 * 1000).toISOString();

        calendar.addEvent({
          id: mode + '_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8),
          start: startIso,
          end: endIso,
          allDay: false,
          backgroundColor: mode === 'availability' ? '#3b82f6' : '#10b981',
          borderColor: mode === 'availability' ? '#2563eb' : '#059669',
          textColor: '#ffffff',
          classNames: [mode === 'availability' ? 'event-type-availability' : 'event-type-session'], // Added class
          editable: true, // Always editable on creation (since it matches current mode)
          extendedProps: { slotMode: mode }
        });

        console.log('[MentorCalendar] created slot', { mode, startIso, endIso, isAvailabilityMode });
        markDirty(mode);
        recomputeCollisions();
      },
      eventContent: function(arg) {
        const mode = arg.event.extendedProps?.slotMode || 'availability';
        const tpl = mode === 'session' ? sessionSlotTpl : availabilitySlotTpl;
        if (!tpl || !tpl.content) return true;

        const startStr = calendar.formatDate(arg.event.start, { hour: 'numeric', minute: '2-digit', hour12: true });
        const endStr = calendar.formatDate(arg.event.end, { hour: 'numeric', minute: '2-digit', hour12: true });

        const node = tpl.content.firstElementChild.cloneNode(true);
        const timeEl = node.querySelector('[data-slot-time]');
        if (timeEl) timeEl.textContent = `${startStr}  ${endStr}`;

        // "Props" passed to the slot component (keeps calendar.html light)
        const props = {
          slotMode: mode,
          isAvailabilityMode,
          timezone: timezone_variable,
          eventId: arg.event.id,
          recurringId: arg.event.extendedProps?.recurringId || null,
          instanceDate: arg.event.extendedProps?.instanceDate || null,
          startIso: arg.event.start ? arg.event.start.toISOString() : null,
          endIso: arg.event.end ? arg.event.end.toISOString() : null
        };

        if (mode === 'session') {
          window.MentorCalendarSlotComponents?.SessionSlot?.mount?.(node, props);
        } else {
          window.MentorCalendarSlotComponents?.AvailabilitySlot?.mount?.(node, props);
        }

        return { domNodes: [node] };
      },
      windowResize: function() {
        calendar.updateSize();
        styleGridLines();
      }
    });

    calendar.render();
    
    // Initial style application
    setTimeout(styleGridLines, 50);
    console.log('[MentorCalendar] Active timeZone:', calendar.getOption('timeZone'));
    // Save starts disabled until the user makes a change
    updateSaveButtonState();
    recomputeCollisions();
  }

  // Internal API for slot components (client-only changes; DB persistence happens on Save)
  window.MentorCalendarInternal = window.MentorCalendarInternal || {};

  // Called by AvailabilitySlot recurrence dropdown
  window.MentorCalendarInternal.setRecurrenceForEvent = function(payload) {
    if (!calendar) return;
    const eventId = payload?.eventId || '';
    const recurringId = payload?.recurringId || '';
    const value = payload?.value || 'none';

    // Existing recurring instance: update recurring rule type
    if (recurringId && recurringAvailabilityRules.has(recurringId)) {
      const rule = recurringAvailabilityRules.get(recurringId);
      if (!rule) return;

      if (value === 'none') {
        // Convert series -> one-time slot for the clicked instance
        const instanceEv = calendar.getEventById(eventId);
        if (instanceEv && instanceEv.start && instanceEv.end) {
          const startIso = instanceEv.start.toISOString();
          const endIso = instanceEv.end.toISOString();
          const newId = recurringId; // preserve ID across conversion
          recurringAvailabilityRules.delete(recurringId);
          clearRecurringInstanceEvents();
          calendar.addEvent({
            id: newId,
            start: startIso,
            end: endIso,
            allDay: false,
            backgroundColor: '#3b82f6',
            borderColor: '#2563eb',
            textColor: '#ffffff',
            classNames: ['event-type-availability'],
            editable: true,
            // Tell backend this is a conversion from recurring -> one-time
            extendedProps: { slotMode: 'availability', type: 'availability_slot', recurringSlotId: recurringId }
          });
          markDirty('availability');
          renderRecurringInstancesForCurrentView();
        }
        return;
      }

      // Switch recurring pattern (keep times)
      rule.type = value;
      // Update weekday/day_of_month anchor based on the instance date (best UX)
      const instanceDate = payload?.instanceDate || rule.anchor_date || rule.start_date || getLocalDateKeyFromUtcIso(new Date().toISOString());
      rule.anchor_date = instanceDate;
      if (!rule.start_date) rule.start_date = instanceDate;
      if (value === 'weekly') {
        const wd = weekdayNameFromIsoDate(instanceDate);
        rule.weekdays = wd ? [wd] : (rule.weekdays || []);
        rule.day_of_month = null;
      } else if (value === 'monthly') {
        try {
          if (window.luxon && window.luxon.DateTime) {
            const dt = window.luxon.DateTime.fromISO(instanceDate, { zone: timezone_variable });
            rule.day_of_month = dt.isValid ? dt.day : rule.day_of_month;
            rule.weekdays = [];
          }
        } catch (e) {}
      } else if (value === 'daily') {
        rule.weekdays = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];
        rule.day_of_month = null;
      }
      recurringAvailabilityRules.set(recurringId, rule);
      markDirty('availability');
      renderRecurringInstancesForCurrentView();
      return;
    }

    // One-time availability event: if recurrence != none, turn it into a recurring rule
    if (eventId && value !== 'none') {
      const ev = calendar.getEventById(eventId);
      if (!ev || !ev.start || !ev.end) return;
      const dateStr = getLocalDateKeyFromJsDate(ev.start);
      const startTime = getLocalTimeHHmmFromJsDate(ev.start);
      const endTime = getLocalTimeHHmmFromJsDate(ev.end);
      if (!dateStr || !startTime || !endTime) return;

      const rule = {
        id: eventId,
        type: value,
        slot_type: 'availability_slot',
        start_date: dateStr,
        start_time: startTime,
        end_time: endTime,
        skip_dates: [],
        booked_dates: [],
        anchor_date: dateStr
      };
      if (value === 'weekly') {
        const wd = weekdayNameFromIsoDate(dateStr);
        rule.weekdays = wd ? [wd] : [];
      } else if (value === 'monthly') {
        try {
          if (window.luxon && window.luxon.DateTime) {
            const dt = window.luxon.DateTime.fromJSDate(ev.start).setZone(timezone_variable);
            rule.day_of_month = dt.day;
          }
        } catch (e) {}
      } else if (value === 'daily') {
        rule.weekdays = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];
      }

      recurringAvailabilityRules.set(eventId, rule);
      // Remove the one-time event to avoid duplicates (series will render occurrences)
      ev.remove();
      markDirty('availability');
      renderRecurringInstancesForCurrentView();
    }
  };

  window.MentorCalendarInternal.removeEventById = function(eventId) {
    if (!calendar || !eventId) return;
    const ev = calendar.getEventById(eventId);
    if (!ev) return;
    const slotMode = ev.extendedProps?.slotMode;
    console.log('[MentorCalendar] removing event (client-only):', {
      id: ev.id,
      slotMode: slotMode
    });
    
    // Recurring availability instance: ask whether to delete one vs all
    if (slotMode === 'availability' && ev.extendedProps?.isRecurringInstance && ev.extendedProps?.recurringId) {
      const recurringId = ev.extendedProps.recurringId;
      const instanceDate = ev.extendedProps.instanceDate || getLocalDateKeyFromJsDate(ev.start);
      openRecurringDeletePopup({ eventId: ev.id, recurringId, instanceDate });
      return;
    }

    // Reminder: removing availability is client-only until user clicks Save
    if (slotMode === 'availability' && typeof showNotification === 'function') {
      showNotification("Don't forget to save the changes.", 'note');
    }
    
    markDirty(slotMode);
    ev.remove();
    recomputeCollisions();
  };

  function updateDateTitle(title) {
    if (dateDisplay) {
      dateDisplay.textContent = title;
    }
  }

  function updateActiveViewButton(viewType) {
    document.querySelectorAll('.view-toggle-btn').forEach(btn => {
      btn.classList.toggle('is-active', btn.dataset.calendarView === viewType);
    });
  }

  // --- Custom Styling Logic similar to Availability Popup ---
  function styleGridLines() {
    // 1. Mark hour slots for solid borders
    const slots = root.querySelectorAll('tr');
    slots.forEach(slot => {
        // FullCalendar 6 uses data-time on slot rows, or we check structure
        // Simple heuristic: if it has a label or is top of hour
        const labelCell = slot.querySelector('.fc-timegrid-slot-label');
        if (labelCell && labelCell.getAttribute('data-time')) {
           const time = labelCell.getAttribute('data-time');
           if (time.endsWith(':00:00')) {
             slot.classList.add('fc-hour-slot');
             // Also target the sibling td which is the actual lane
             const lane = slot.querySelector('.fc-timegrid-slot-lane');
             if(lane) lane.classList.add('fc-hour-slot');
           }
        }
    });

    // Fallback if needed, but the above usually works well in FC v6
    // Extra pass for rows that might be missed by simple label check
    const timeSlots = root.querySelectorAll('.fc-timegrid-slot-lane');
    timeSlots.forEach((slot, i) => {
       // Assuming 15min slots per tr, index 0 is first. 
       // We can simply trust the label checking above for now.
    });
  }


  function destroyCalendar() {
    if (!calendar) return;
    try {
      calendar.destroy();
    } finally {
      calendar = null;
      root.innerHTML = '';
    }
  }

  function open(triggerEl) {
    overlay.classList.add('is-visible');
    overlay.setAttribute('aria-hidden', 'false');
    
    // Optional: allow opener to force initial mode.
    // Supported values: 'sessions' | 'availability'
    const requestedMode = (triggerEl && triggerEl.dataset && triggerEl.dataset.mentorCalendarInitialMode) ? String(triggerEl.dataset.mentorCalendarInitialMode) : '';
    if (requestedMode === 'sessions') setMode(false);
    if (requestedMode === 'availability') setMode(true);

    // Small delay to ensure transitions work and DOM is ready
    setTimeout(() => {
        // Re-resolve timezone from profile on each open (in case it changed)
        timezone_variable = resolveMentorTimezone();
        renderModeToggle();
        initCalendar();
        if (calendar) calendar.updateSize();
        loadSavedAvailability();
    }, 50);
  }

  // Auto-open (used for session-length-change collision recovery flow)
  try {
    const params = new URLSearchParams(window.location.search || '');
    if (params.get('open_calendar') === 'true') {
      openedFromSessionLengthChange = true;
      // Ensure Availability mode when opening for collision resolution
      const trigger = document.querySelector('[data-open-mentor-calendar]') || null;
      if (trigger && trigger.dataset) trigger.dataset.mentorCalendarInitialMode = 'availability';
      open(trigger);
      // Once events load, show collision popup if collisions exist
      setTimeout(() => {
        try {
          if (hasAvailabilityCollisionsInHorizon() && typeof window.openCollisionResolutionPopup === 'function') {
            window.openCollisionResolutionPopup(true);
          }
        } catch (e) {}
      }, 1200);
    }
  } catch (e) {}

  function setUnsavedChangesVisible(isVisible) {
    if (!unsavedChangesOverlay) return;
    unsavedChangesOverlay.classList.toggle('is-visible', !!isVisible);
    unsavedChangesOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function closeUnsavedChangesPopup() {
    setUnsavedChangesVisible(false);
  }

  function hasUnsavedCalendarChanges() {
    // Contract per your rule: Save enabled => unsaved changes exist
    if (saveBtn && saveBtn.disabled === false) return true;
    return !!(dirtyAvailability || dirtySession);
  }

  function closeNow() {
    // Always close the settings popup too (if open)
    if (availabilitySettingsOverlay && availabilitySettingsOverlay.classList.contains('is-visible')) {
      closeAvailabilitySettings();
    }
    if (availabilitySwitchOverlay && availabilitySwitchOverlay.classList.contains('is-visible')) {
      closeAvailabilitySwitchPopup();
    }
    if (sessionSwitchOverlay && sessionSwitchOverlay.classList.contains('is-visible')) {
      closeSessionSwitchPopup();
    }
    if (sessionSettingsOverlay && sessionSettingsOverlay.classList.contains('is-visible')) {
      closeSessionSettings();
    }
    if (scheduleSessionOverlay && scheduleSessionOverlay.classList.contains('is-visible')) {
      closeScheduleSessionPopup();
    }
    if (unsavedChangesOverlay && unsavedChangesOverlay.classList.contains('is-visible')) {
      closeUnsavedChangesPopup();
    }
    if (recurringDeleteOverlay && recurringDeleteOverlay.classList.contains('is-visible')) {
      setRecurringDeleteVisible(false);
      pendingRecurringDelete = null;
    }
    overlay.classList.remove('is-visible');
    overlay.setAttribute('aria-hidden', 'true');
    // Destroy calendar so it reconstructs cleanly on next open
    destroyCalendar();
    // Reset save state (fresh on next open)
    dirtyAvailability = false;
    dirtySession = false;
    updateSaveButtonState();
  }

  function attemptClose() {
    // If session length increased and DB now contains collisions, we should not allow closing
    // without addressing collisions (user can still choose "Delete all colliding slots").
    if (openedFromSessionLengthChange && hasAvailabilityCollisionsInHorizon()) {
      if (typeof window.openCollisionResolutionPopup === 'function') {
        window.openCollisionResolutionPopup(true); // locked popup behavior handled by the popup itself
      }
      return;
    }

    // If there are unsaved changes, ask for confirmation first
    if (hasUnsavedCalendarChanges()) {
      setUnsavedChangesVisible(true);
      return;
    }
    closeNow();
  }

  // --- Event Listeners ---

  // Navigation Buttons
  overlay.querySelectorAll('[data-calendar-nav]').forEach(btn => {
    btn.addEventListener('click', () => {
      if (!calendar) return;
      const action = btn.dataset.calendarNav;
      if (action === 'prev') calendar.prev();
      if (action === 'next') calendar.next();
      if (action === 'today') calendar.today();
    });
  });

  // View Toggle Buttons
  overlay.querySelectorAll('[data-calendar-view]').forEach(btn => {
    btn.addEventListener('click', () => {
      if (!calendar) return;
      calendar.changeView(btn.dataset.calendarView);
    });
  });

  // Mode toggle buttons (boolean only, no behavior yet)
  if (modeSessionsBtn) {
    modeSessionsBtn.addEventListener('click', () => setMode(false));
  }
  if (modeAvailabilityBtn) {
    modeAvailabilityBtn.addEventListener('click', () => setMode(true));
  }

  // Save availability button
  if (saveBtn) {
    saveBtn.addEventListener('click', () => {
      console.log('[MentorCalendar] Save clicked. Saving availability only (sessions ignored).');
      saveAvailabilityToBackend();
    });
  }

  // Availability settings popup handlers
  if (availabilitySettingsOverlay) {
    availabilitySettingsOverlay.querySelectorAll('[data-availability-settings-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySettings();
      });
    });
    availabilitySettingsOverlay.querySelectorAll('[data-availability-settings-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySettings();
      });
    });
  }
  if (availabilitySettingsSaveBtn) {
    availabilitySettingsSaveBtn.addEventListener('click', (e) => {
      e.preventDefault();
      applyAvailabilitySettings();
    });
  }

  // Switch-to-availability-mode popup handlers
  if (availabilitySwitchOverlay) {
    availabilitySwitchOverlay.querySelectorAll('[data-availability-switch-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySwitchPopup();
      });
    });
    availabilitySwitchOverlay.querySelectorAll('[data-availability-switch-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeAvailabilitySwitchPopup();
      });
    });
  }
  if (availabilitySwitchToAvailabilityBtn) {
    availabilitySwitchToAvailabilityBtn.addEventListener('click', (e) => {
      e.preventDefault();
      switchToAvailabilityModeAndOpenSettings();
    });
  }

  // Switch-to-sessions-mode popup handlers
  if (sessionSwitchOverlay) {
    sessionSwitchOverlay.querySelectorAll('[data-session-switch-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSwitchPopup();
      });
    });
    sessionSwitchOverlay.querySelectorAll('[data-session-switch-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSwitchPopup();
      });
    });
  }
  if (sessionSwitchToSessionsBtn) {
    sessionSwitchToSessionsBtn.addEventListener('click', (e) => {
      e.preventDefault();
      switchToSessionsMode();
    });
  }

  // Session settings popup handlers
  if (sessionSettingsOverlay) {
    sessionSettingsOverlay.querySelectorAll('[data-session-settings-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSettings();
      });
    });
    sessionSettingsOverlay.querySelectorAll('[data-session-settings-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeSessionSettings();
      });
    });
  }
  if (sessionSettingsApplyBtn) {
    sessionSettingsApplyBtn.addEventListener('click', (e) => {
      e.preventDefault();
      applySessionSettings();
    });
  }

  // Schedule session popup handlers
  if (scheduleSessionOverlay) {
    scheduleSessionOverlay.querySelectorAll('[data-schedule-session-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeScheduleSessionPopup();
      });
    });
  }
  if (scheduleSessionSendBtn) {
    scheduleSessionSendBtn.addEventListener('click', (e) => {
      e.preventDefault();
      sendScheduleSessionEmail();
    });
  }

  // Close handlers
  overlay.querySelectorAll('[data-mentor-calendar-close]').forEach(el => {
    el.addEventListener('click', attemptClose);
  });
  
  document.addEventListener('keydown', (e) => {
    if (e.key !== 'Escape') return;
    if (!overlay.classList.contains('is-visible')) return;

    // Priority: close settings popups first, then switch popups, then the calendar popup.
    if (availabilitySettingsOverlay && availabilitySettingsOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeAvailabilitySettings();
      return;
    }
    if (sessionSettingsOverlay && sessionSettingsOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeSessionSettings();
      return;
    }
    if (scheduleSessionOverlay && scheduleSessionOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeScheduleSessionPopup();
      return;
    }
    if (recurringMoveOverlay && recurringMoveOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      cancelRecurringMove();
      return;
    }
    if (recurringDeleteOverlay && recurringDeleteOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      setRecurringDeleteVisible(false);
      pendingRecurringDelete = null;
      return;
    }
    if (unsavedChangesOverlay && unsavedChangesOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeUnsavedChangesPopup();
      return;
    }
    if (availabilitySwitchOverlay && availabilitySwitchOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeAvailabilitySwitchPopup();
      return;
    }
    if (sessionSwitchOverlay && sessionSwitchOverlay.classList.contains('is-visible')) {
      e.preventDefault();
      closeSessionSwitchPopup();
      return;
    }
    attemptClose();
  });

  // Unsaved changes popup handlers
  if (unsavedChangesOverlay) {
    unsavedChangesOverlay.querySelectorAll('[data-unsaved-changes-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeUnsavedChangesPopup();
      });
    });
    unsavedChangesOverlay.querySelectorAll('[data-unsaved-changes-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        closeUnsavedChangesPopup();
      });
    });
  }
  if (unsavedChangesDiscardBtn) {
    unsavedChangesDiscardBtn.addEventListener('click', (e) => {
      e.preventDefault();
      closeNow();
    });
  }

  // Recurring delete popup helpers/handlers
  function setRecurringDeleteVisible(isVisible) {
    if (!recurringDeleteOverlay) return;
    recurringDeleteOverlay.classList.toggle('is-visible', !!isVisible);
    recurringDeleteOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function openRecurringDeletePopup(payload) {
    pendingRecurringDelete = payload || null;
    setRecurringDeleteVisible(true);
  }

  function deleteRecurringOccurrenceOnly() {
    const p = pendingRecurringDelete;
    if (!p || !calendar) {
      setRecurringDeleteVisible(false);
      pendingRecurringDelete = null;
      return;
    }
    const rule = recurringAvailabilityRules.get(p.recurringId);
    if (rule && p.instanceDate) {
      rule.skip_dates = Array.isArray(rule.skip_dates) ? rule.skip_dates : [];
      if (!rule.skip_dates.includes(p.instanceDate)) rule.skip_dates.push(p.instanceDate);
      recurringAvailabilityRules.set(p.recurringId, rule);
    }
    const ev = calendar.getEventById(p.eventId);
    if (ev) ev.remove();
    markDirty('availability');
    renderRecurringInstancesForCurrentView();
    recomputeCollisions();
    setRecurringDeleteVisible(false);
    pendingRecurringDelete = null;
  }

  function deleteRecurringSeries() {
    const p = pendingRecurringDelete;
    if (!p || !calendar) {
      setRecurringDeleteVisible(false);
      pendingRecurringDelete = null;
      return;
    }
    const existing = recurringAvailabilityRules.get(p.recurringId);
    if (existing) deletedRecurringRules.set(p.recurringId, existing);
    recurringAvailabilityRules.delete(p.recurringId);
    if (window.MentorCalendarRecurrenceSelections) delete window.MentorCalendarRecurrenceSelections[p.recurringId];

    // Remove all rendered instances for this recurringId
    calendar.getEvents().forEach(ev => {
      if (ev.extendedProps?.recurringId === p.recurringId || String(ev.id || '').startsWith(p.recurringId + '__')) {
        ev.remove();
      }
    });

    markDirty('availability');
    renderRecurringInstancesForCurrentView();
    recomputeCollisions();
    setRecurringDeleteVisible(false);
    pendingRecurringDelete = null;
  }

  if (recurringDeleteOverlay) {
    recurringDeleteOverlay.querySelectorAll('[data-recurring-delete-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        setRecurringDeleteVisible(false);
        pendingRecurringDelete = null;
      });
    });
    recurringDeleteOverlay.querySelectorAll('[data-recurring-delete-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        setRecurringDeleteVisible(false);
        pendingRecurringDelete = null;
      });
    });
  }
  if (recurringDeleteOneBtn) {
    recurringDeleteOneBtn.addEventListener('click', (e) => {
      e.preventDefault();
      deleteRecurringOccurrenceOnly();
    });
  }
  if (recurringDeleteAllBtn) {
    recurringDeleteAllBtn.addEventListener('click', (e) => {
      e.preventDefault();
      deleteRecurringSeries();
    });
  }

  // Recurring move popup helpers/handlers
  function setRecurringMoveVisible(isVisible) {
    if (!recurringMoveOverlay) return;
    recurringMoveOverlay.classList.toggle('is-visible', !!isVisible);
    recurringMoveOverlay.setAttribute('aria-hidden', isVisible ? 'false' : 'true');
  }

  function setRecurringMoveAllButtonLabel(label) {
    if (!recurringMoveAllBtn) return;
    recurringMoveAllBtn.textContent = label || 'All';
  }

  function cancelRecurringMove() {
    pendingRecurringMove = null;
    setRecurringMoveAllButtonLabel('All');
    setRecurringMoveVisible(false);
  }

  function applyRecurringMoveAll() {
    const p = pendingRecurringMove;
    if (!p) return cancelRecurringMove();
    const rule = recurringAvailabilityRules.get(p.recurringId);
    if (!rule || !(window.luxon && window.luxon.DateTime)) return cancelRecurringMove();

    const newStart = window.luxon.DateTime.fromISO(p.newStartIso, { zone: 'utc' }).setZone(timezone_variable);
    const newEnd = window.luxon.DateTime.fromISO(p.newEndIso, { zone: 'utc' }).setZone(timezone_variable);
    if (!newStart.isValid || !newEnd.isValid || newEnd <= newStart) return cancelRecurringMove();

    // Change all future slots:
    // - Materialize occurrences from TODAY (mentor timezone) up to the split point (exclusive) into one-time slots
    //   Split point:
    //   - if moving the occurrence later into the future: use the OLD occurrence date (instanceDate) (so we don't fill the gap)
    //   - otherwise: use the NEW start date (drag target)
    // - Update the recurring rule to start at the new date/time
    // - Reset skip_dates (and we ignore booked_dates per your direction)
    const todayLocal = window.luxon.DateTime.now().setZone(timezone_variable).startOf('day');
    const newStartDate = newStart.toISODate(); // local date of the dragged occurrence
    const newStartDay = window.luxon.DateTime.fromISO(newStartDate, { zone: timezone_variable }).startOf('day');
    const oldInstanceDay = p.instanceDate
      ? window.luxon.DateTime.fromISO(String(p.instanceDate), { zone: timezone_variable }).startOf('day')
      : null;

    // Helper: does rule match a given date?
    const matchesRuleOnDate = (ruleObj, dateStr) => {
      if (!ruleObj || !ruleObj.type) return false;
      if (ruleObj.start_date && dateStr < ruleObj.start_date) return false;
      if (Array.isArray(ruleObj.skip_dates) && ruleObj.skip_dates.includes(dateStr)) return false;

      if (ruleObj.type === 'daily') return true;
      if (ruleObj.type === 'weekly') {
        const wd = weekdayNameFromIsoDate(dateStr);
        return Array.isArray(ruleObj.weekdays) ? ruleObj.weekdays.includes(wd) : false;
      }
      if (ruleObj.type === 'monthly') {
        const dom = Number(ruleObj.day_of_month);
        if (!Number.isFinite(dom) || dom < 1) return false;
        const d = window.luxon.DateTime.fromISO(dateStr, { zone: timezone_variable });
        if (!d.isValid) return false;
        const daysInMonth = d.daysInMonth;
        const targetDay = dom > daysInMonth ? daysInMonth : dom;
        return d.day === targetDay;
      }
      return false;
    };

    // Materialize from max(today, rule.start_date) to newStartDate (exclusive)
    let cursor = todayLocal;
    if (rule.start_date) {
      const rs = window.luxon.DateTime.fromISO(String(rule.start_date), { zone: timezone_variable }).startOf('day');
      if (rs.isValid && cursor < rs) cursor = rs;
    }
    // If moved later (newStartDay > oldInstanceDay), end at oldInstanceDay (exclusive).
    // Otherwise end at newStartDay (exclusive).
    let endExclusive = newStartDay;
    if (oldInstanceDay && oldInstanceDay.isValid && newStartDay.isValid && newStartDay > oldInstanceDay) {
      endExclusive = oldInstanceDay;
    }

    while (cursor < endExclusive) {
      const dStr = cursor.toISODate();
      if (matchesRuleOnDate(rule, dStr)) {
        const startDt = window.luxon.DateTime.fromISO(`${dStr}T${rule.start_time}`, { zone: timezone_variable });
        const endDt = window.luxon.DateTime.fromISO(`${dStr}T${rule.end_time}`, { zone: timezone_variable });
        if (startDt.isValid && endDt.isValid && endDt > startDt) {
          const newId = generateClientId('availability');
          calendar.addEvent({
            id: newId,
            start: startDt.toJSDate(),
            end: endDt.toJSDate(),
            allDay: false,
            backgroundColor: '#3b82f6',
            borderColor: '#2563eb',
            textColor: '#ffffff',
            classNames: ['event-type-availability'],
            editable: true,
            extendedProps: { slotMode: 'availability', type: 'availability_slot' }
          });
        }
      }
      cursor = cursor.plus({ days: 1 });
    }

    // Update recurring rule forward from the dragged occurrence (new date + time)
    rule.start_date = newStartDate;
    rule.start_time = newStart.toFormat('HH:mm');
    rule.end_time = newEnd.toFormat('HH:mm');
    rule.skip_dates = [];

    // If the move changed the day, update weekly/monthly pattern accordingly
    if (rule.type === 'weekly') {
      const wd = weekdayNameFromIsoDate(newStartDate);
      rule.weekdays = wd ? [wd] : (rule.weekdays || []);
      rule.day_of_month = null;
    } else if (rule.type === 'monthly') {
      rule.day_of_month = newStart.day;
      rule.weekdays = [];
    }

    recurringAvailabilityRules.set(p.recurringId, rule);
    markDirty('availability');
    renderRecurringInstancesForCurrentView();
    recomputeCollisions();
    cancelRecurringMove();
  }

  function applyRecurringMoveOne() {
    const p = pendingRecurringMove;
    if (!p || !calendar) return cancelRecurringMove();

    // 1) Skip original occurrence date in the series
    const rule = recurringAvailabilityRules.get(p.recurringId);
    if (rule && p.instanceDate) {
      rule.skip_dates = Array.isArray(rule.skip_dates) ? rule.skip_dates : [];
      if (!rule.skip_dates.includes(p.instanceDate)) rule.skip_dates.push(p.instanceDate);
      recurringAvailabilityRules.set(p.recurringId, rule);
    }

    // 2) Add a new one-time availability slot at the new position
    const newId = generateClientId('availability');
    calendar.addEvent({
      id: newId,
      start: p.newStartIso,
      end: p.newEndIso,
      allDay: false,
      backgroundColor: '#3b82f6',
      borderColor: '#2563eb',
      textColor: '#ffffff',
      classNames: ['event-type-availability'],
      editable: true,
      extendedProps: { slotMode: 'availability', type: 'availability_slot' }
    });

    markDirty('availability');
    renderRecurringInstancesForCurrentView();
    recomputeCollisions();
    cancelRecurringMove();
  }

  if (recurringMoveOverlay) {
    recurringMoveOverlay.querySelectorAll('[data-recurring-move-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        cancelRecurringMove();
      });
    });
    recurringMoveOverlay.querySelectorAll('[data-recurring-move-cancel]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        cancelRecurringMove();
      });
    });
  }
  if (recurringMoveOneBtn) {
    recurringMoveOneBtn.addEventListener('click', (e) => {
      e.preventDefault();
      applyRecurringMoveOne();
    });
  }
  if (recurringMoveAllBtn) {
    recurringMoveAllBtn.addEventListener('click', (e) => {
      e.preventDefault();
      applyRecurringMoveAll();
    });
  }

  // Public API
  window.MentorCalendar = { open, close };

  document.querySelectorAll('[data-open-mentor-calendar]').forEach(el => {
    el.addEventListener('click', (e) => {
      e.preventDefault();
      open(el);
    });
  });
})();
</script>
