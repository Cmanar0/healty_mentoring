{# Booking Modal Popup #}
<div id="bookingModal" class="booking-modal-overlay">
    <div class="booking-modal-container">
        <button class="booking-close-btn" onclick="closeBookingModal()"><i class="fas fa-times"></i></button>
        
        <!-- Error State (for mentors trying to book) -->
        <div id="bookingErrorState" class="booking-error-state" style="display: none;">
            <div class="booking-error-content">
                <div class="booking-error-icon">
                    <i class="fas fa-exclamation-circle"></i>
                </div>
                <h2 class="booking-error-title">Cannot Book Session</h2>
                <p class="booking-error-message">
                    Mentors cannot book sessions with other mentors. Please use a different account.
                </p>
                <button class="booking-error-btn" onclick="closeBookingModal()">
                    <i class="fas fa-arrow-left"></i>
                    Go Back
                </button>
            </div>
        </div>
        
        <div class="booking-grid" id="bookingMainContent">
            <!-- Col 1: Mentor Info -->
            <div class="booking-sidebar">
                <div class="booking-mentor-mini">
                    {% if mentor_profile.profile_picture %}
                    <img src="{{ mentor_profile.profile_picture.url }}" alt="Avatar" class="booking-avatar">
                    {% else %}
                    <div class="booking-avatar-placeholder">{{ mentor_profile.first_name|first }}</div>
                    {% endif %}
                    <div>
                        <div class="booking-mentor-name">{{ mentor_profile.first_name }} {{ mentor_profile.last_name }}</div>
                        <div class="booking-session-name">1:1 Session</div>
                    </div>
                </div>
                
                <div class="booking-meta">
                    <div class="booking-meta-item">
                        <i class="fas fa-clock"></i>
                        <span>
                            {% if mentor_profile.first_session_free %}
                                {{ mentor_profile.first_session_length|default:30 }} min (First Session) / {{ mentor_profile.session_length|default:60 }} min (Regular)
                            {% else %}
                                {{ mentor_profile.session_length|default:"60" }} min
                            {% endif %}
                        </span>
                    </div>
                    <div class="booking-meta-item">
                        <i class="fas fa-video"></i>
                        <span>Google Meet</span>
                    </div>
                    <div class="booking-meta-item">
                        <i class="fas fa-tag"></i>
                        <span>
                            {% if mentor_profile.first_session_free %}
                                $0 <span style=" color: #10b981; font-weight: 600;">(First Session Free)</span>
                            {% else %}
                                ${{ mentor_profile.price_per_hour|floatformat:0 }}
                            {% endif %}
                        </span>
                    </div>
                </div>

                <!-- NEW: Dynamic Selection Summary -->
                <div id="bookingSummary" class="booking-selection-summary" style="display: none;">
                    <div class="summary-label">Your Selection</div>
                    <div class="summary-details">
                        <div class="summary-item">
                            <i class="far fa-calendar-alt"></i>
                            <span id="summaryDate">Select a date</span>
                        </div>
                        <div class="summary-item" id="summaryTimeRow" style="display: none;">
                            <i class="far fa-clock"></i>
                            <span id="summaryTime">Select a time</span>
                        </div>
                    </div>
                </div>
                
                <div class="booking-desc">
                    {% if mentor_profile.first_session_free %}
                        Your first session with {{ mentor_profile.first_name }} is free! This introductory session lasts {{ mentor_profile.first_session_length|default:30 }} minutes and is perfect for discussing your goals and how {{ mentor_profile.first_name }} can help you. Regular sessions are {{ mentor_profile.session_length|default:60 }} minutes.
                    {% else %}
                        Book a focused session to discuss your career, goals, or specific challenges.
                    {% endif %}
                </div>
            </div>
            
            <!-- Col 2: Calendar -->
            <div class="booking-calendar-col">
                <h3 class="booking-title">Select a Date & Time</h3>
                
                <div class="calendar-header">
                    <button class="cal-nav-btn" id="prevMonth"><i class="fas fa-chevron-left"></i></button>
                    <div class="current-month-label" id="currentMonthLabel">October 2023</div>
                    <button class="cal-nav-btn" id="nextMonth"><i class="fas fa-chevron-right"></i></button>
                </div>
                
                <div class="calendar-grid-header">
                    <div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div>
                </div>
                <div class="calendar-days" id="calendarDays">
                    <!-- JS generated -->
                </div>
            </div>
            
            <!-- Col 3: Slots -->
            <div class="booking-slots-col" id="slotsCol" style="display: none;">
                <div class="slots-header-row">
                    <h4 class="slots-date-label" id="selectedDateLabel">Thursday, Oct 12</h4>
                </div>
                <div class="slots-list" id="slotsList">
                    <!-- JS generated -->
                </div>
                <div class="slots-footer" id="slotsFooter" style="display: none;">
                    <button class="book-slot-btn" id="bookSlotBtn">
                        <i class="fas fa-calendar-check"></i>
                        <span>Book this slot</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Email Collection Modal (for non-logged-in users) -->
<div id="emailCollectionModal" class="booking-modal-overlay" style="display: none;">
    <div class="booking-modal-container" style="max-width: 900px; height: 600px; overflow-y: auto;">
        <button class="booking-close-btn" onclick="closeEmailCollectionModal()"><i class="fas fa-times"></i></button>
        
        <div style="padding: 32px; min-height: 100%; box-sizing: border-box;">
            <h2 style="font-size: 1.5rem; color: #1e293b; margin-bottom: 8px;">Book Your Session</h2>
            <p style="color: #64748b; margin-bottom: 24px; font-size: 0.95rem;">Please provide your email to complete the booking</p>
            
            <form id="emailCollectionForm">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: start;">
                    <!-- Left Column: Email and Message -->
                    <div style="display: flex; flex-direction: column; gap: 16px;">
                        <!-- Email Input -->
                        <div>
                            <label style="display: block; font-weight: 600; color: #1e293b; margin-bottom: 8px; font-size: 0.9rem;">
                                Email Address <span style="color: #ef4444;">*</span>
                            </label>
                            <input type="email" id="bookingEmailInput" class="form-input" placeholder="your@email.com" required style="width: 100%; max-width: 100%; padding: 12px 16px; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 0.95rem; box-sizing: border-box;">
                            <div id="emailError" style="color: #ef4444; font-size: 0.85rem; margin-top: 6px; display: none;"></div>
                        </div>
                        
                        <!-- Note Input -->
                        <div>
                            <label style="display: block; font-weight: 600; color: #1e293b; margin-bottom: 8px; font-size: 0.9rem;">
                                Message (Optional)
                            </label>
                            <textarea id="bookingNoteInput" class="form-input" placeholder="What would you like to focus on during this session?" rows="8" style="width: 100%; max-width: 100%; max-height: 300px; padding: 12px 16px; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 0.95rem; resize: none; font-family: inherit; box-sizing: border-box; overflow-y: auto;"></textarea>
                        </div>
                        
                        <!-- Price Display (moved to left column) -->
                        <div style="padding: 14px 16px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px;">
                                <span style="font-weight: 600; color: #1e293b; font-size: 0.95rem;">Session Price:</span>
                                <span id="bookingPriceDisplay" style="font-size: 1.05rem; font-weight: 700; color: #10b981; text-align: right;">
                                    {% if mentor_profile.first_session_free %}
                                        $0 <span style="font-size: 0.85rem; font-weight: 600;">(First Session Free)</span>
                                    {% else %}
                                        ${{ mentor_profile.price_per_hour|floatformat:0 }}
                                    {% endif %}
                                </span>
                            </div>
                            <div id="bookingPriceNote" style="font-size: 0.8rem; color: #64748b; margin-top: 6px; display: none;">
                                This is your first session with this mentor
                            </div>
                        </div>
                    </div>
                    
                    <!-- Right Column: Timezone, Price, and Button -->
                    <div style="display: flex; flex-direction: column; gap: 16px;">
                        <!-- Timezone Confirmation -->
                        <div>
                            <label style="display: block; font-weight: 600; color: #1e293b; margin-bottom: 8px; font-size: 0.9rem;">
                                Timezone
                            </label>
                            <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px 16px;">
                                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                    <input type="checkbox" id="timezoneConfirmed" checked style="width: 18px; height: 18px; cursor: pointer; flex-shrink: 0;">
                                    <label for="timezoneConfirmed" style="cursor: pointer; flex: 1; color: #475569; font-size: 0.9rem; line-height: 1.4;">
                                        <span id="detectedTimezoneDisplay">We detected your timezone: <strong id="detectedTimezoneName">Loading...</strong></span>
                                    </label>
                                </div>
                                <!-- Live Clock Display -->
                                <div id="timezoneClockDisplay" style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; padding: 8px 12px; background: white; border-radius: 6px; border: 1px solid #e2e8f0;">
                                    <i class="far fa-clock" style="color: #3b82f6; font-size: 0.9rem;"></i>
                                    <div style="display: flex; flex-direction: column; gap: 2px;">
                                        <span id="timezoneCurrentTime" style="font-size: 0.95rem; font-weight: 600; color: #1e293b;">--:--</span>
                                        <span id="timezoneCurrentDate" style="font-size: 0.75rem; color: #64748b;">--</span>
                                    </div>
                                </div>
                                <div id="timezoneSelectorWrapper" style="display: none;">
                                    <div class="autocomplete-container" style="position: relative;">
                                        <input type="text" id="bookingTimezoneInput" class="form-input autocomplete-input" placeholder="Search for your timezone..." autocomplete="off" style="width: 100%; padding: 12px 16px; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 0.95rem; box-sizing: border-box;">
                                        <input type="hidden" id="bookingTimezoneValue" value="">
                                        <div class="autocomplete-suggestions" id="bookingTimezoneSuggestions" style="max-height: 250px; overflow-y: auto; overflow-x: hidden;"></div>
                                    </div>
                                    <!-- Selected Timezone Clock Display -->
                                    <div id="selectedTimezoneClockDisplay" style="display: none; margin-top: 12px; padding: 8px 12px; background: white; border-radius: 6px; border: 1px solid #e2e8f0;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <i class="far fa-clock" style="color: #10b981; font-size: 0.9rem;"></i>
                                            <div style="display: flex; flex-direction: column; gap: 2px;">
                                                <span id="selectedTimezoneCurrentTime" style="font-size: 0.95rem; font-weight: 600; color: #1e293b;">--:--</span>
                                                <span id="selectedTimezoneCurrentDate" style="font-size: 0.75rem; color: #64748b;">--</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Session Recap -->
                        <div id="sessionRecap" style="padding: 16px; background: #eff6ff; border-radius: 8px; border: 1px solid #bfdbfe; margin-bottom: 16px;">
                            <div style="font-size: 0.85rem; font-weight: 600; color: #3b82f6; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px;">Session Details</div>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <i class="far fa-calendar-alt" style="color: #3b82f6; font-size: 0.9rem; width: 18px;"></i>
                                    <span id="recapDate" style="font-size: 0.95rem; color: #1e293b; font-weight: 500;">--</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <i class="far fa-clock" style="color: #3b82f6; font-size: 0.9rem; width: 18px;"></i>
                                    <span id="recapTime" style="font-size: 0.95rem; color: #1e293b; font-weight: 500;">--</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-hourglass-half" style="color: #3b82f6; font-size: 0.9rem; width: 18px;"></i>
                                    <span id="recapLength" style="font-size: 0.95rem; color: #1e293b; font-weight: 500;">--</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Submit Button -->
                        <button type="submit" class="book-slot-btn" id="submitBookingBtn" style="width: 100%; margin-top: auto;">
                            <i class="fas fa-calendar-check"></i>
                            <span>Book Session</span>
                        </button>
                    </div>
                </div>
            </form>
        </div>
    </div>
</div>

<style>
/* Modal CSS */
.booking-modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(15, 23, 42, 0.6);
    backdrop-filter: blur(4px);
    z-index: 10000;
    display: none;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}
.booking-modal-overlay.open {
    display: flex;
    opacity: 1;
}

.booking-modal-container {
    background: white;
    width: 90%;
    max-width: 1000px;
    height: 600px;
    border-radius: 20px;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.booking-close-btn {
    position: absolute;
    top: 16px;
    right: 16px;
    background: rgba(15, 23, 42, 0.1); /* Subtle dark circle in light modal */
    border: 1px solid rgba(15, 23, 42, 0.1);
    color: #64748b;
    font-size: 1rem;
    cursor: pointer;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 20;
}
.booking-close-btn:hover {
    background: #ef4444;
    border-color: #ef4444;
    color: white;
    transform: rotate(90deg) scale(1.1);
    box-shadow: 0 0 15px rgba(239, 68, 68, 0.4);
}

.booking-grid {
    display: grid;
    grid-template-columns: 300px 1fr 320px; /* Fixed width for slots col to prevent jumping */
    height: 100%;
    max-height: 100%; /* Ensure grid doesn't exceed container */
}

/* Sidebar */
.booking-sidebar {
    padding: 32px;
    border-right: 1px solid #e2e8f0;
    background: #f8fafc;
}
.booking-mentor-mini {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 32px;
}
.booking-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    object-fit: cover;
}
.booking-avatar-placeholder {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: #3b82f6;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
}
.booking-mentor-name { color: #64748b; font-size: 0.9rem; font-weight: 500; }
.booking-session-name { color: #1e293b; font-size: 1.1rem; font-weight: 700; margin-top: 2px; }

.booking-meta { display: flex; flex-direction: column; gap: 12px; margin-bottom: 32px; }
.booking-meta-item { display: flex; align-items: center; gap: 10px; color: #475569; font-weight: 500; }
.booking-meta-item i { color: #94a3b8; width: 20px; text-align: center; }

.booking-desc { font-size: 0.9rem; color: #64748b; line-height: 1.6; }

/* Selection Summary */
.booking-selection-summary {
    background: #f8fafc;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 24px;
    border: 1px solid #e2e8f0;
}
.summary-label {
    text-transform: uppercase;
    font-size: 0.7rem;
    font-weight: 700;
    color: #94a3b8;
    letter-spacing: 0.05em;
    margin-bottom: 10px;
}
.summary-details {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.summary-item {
    display: flex;
    align-items: center;
    gap: 10px;
    color: #1e293b;
    font-size: 0.95rem;
    font-weight: 600;
}
.summary-item i {
    color: #3b82f6;
    width: 16px;
    font-size: 0.9rem;
}

/* Calendar */
.booking-calendar-col {
    padding: 32px;
    flex: 1;
    overflow-y: auto;
}
.booking-title { font-size: 1.5rem; color: #1e293b; margin-bottom: 24px; }

.calendar-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 24px;
}
.current-month-label { font-size: 1.1rem; font-weight: 600; color: #1e293b; }
.cal-nav-btn {
    background: transparent;
    border: 1px solid #e2e8f0;
    width: 32px; height: 32px;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
    color: #64748b;
}
.cal-nav-btn:hover { background: #f1f5f9; color: var(--mp-primary); }

.calendar-grid-header {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    text-align: center;
    font-size: 0.75rem;
    font-weight: 600;
    color: #94a3b8;
    text-transform: uppercase;
    margin-bottom: 12px;
}
.calendar-days {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    row-gap: 8px;
}
.cal-day {
    height: 44px;
    width: 44px;
    margin: 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    cursor: pointer;
    font-size: 0.95rem;
    font-weight: 500;
    color: #334155;
    transition: all 0.2s;
    position: relative;
}
.cal-day:hover:not(.empty):not(.disabled) {
    background: #eff6ff; /* Light Blue */
    color: #3b82f6;
    font-weight: 600;
}
.cal-day.selected {
    background: #3b82f6 !important;
    color: white !important;
}
.cal-day.disabled {
    color: #cbd5e1;
    cursor: default;
}
.cal-day.has-slots:not(.disabled):not(.selected) {
    background: #eff6ff; /* Light Blue tint */
    color: #3b82f6;
    font-weight: 600;
}
.cal-day.has-slots:not(.selected)::after {
    content: '';
    position: absolute;
    bottom: 6px;
    width: 4px; height: 4px;
    background: #3b82f6;
    border-radius: 50%;
}
.cal-day.selected.has-slots::after { background: white; }
.cal-day.today {
    background: #f1f5f9; /* Neutral gray for today since it's disabled */
    border: 1px solid #cbd5e1;
    font-weight: 700;
}

/* Slots Col */
.booking-slots-col {
    width: 320px;
    padding: 32px;
    border-left: 1px solid #e2e8f0;
    display: flex;
    flex-direction: column;
    height: 100%;
    max-height: 100%; /* Force height to match modal */
    min-height: 0;
    background: white;
    box-sizing: border-box;
    overflow: hidden; /* Prevent the column itself from scrolling */
}
.slots-header-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
    flex-shrink: 0; /* Prevent header from shrinking */
}
.slots-date-label {
    font-size: 1rem;
    color: #475569;
    margin: 0;
}

@keyframes slideIn {
    from { opacity: 0; transform: translateX(10px); }
    to { opacity: 1; transform: translateX(0); }
}

.slots-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0; /* Critical for scroll inside flex */
    scrollbar-width: thin; /* Firefox: thin scrollbar */
    scrollbar-color: #cbd5e1 transparent; /* Firefox: thumb and track */
}
.slots-list::-webkit-scrollbar {
    width: 4px; /* Super thin width */
}
.slots-list::-webkit-scrollbar-track {
    background: transparent;
}
.slots-list::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 10px;
}
.slots-list::-webkit-scrollbar-thumb:hover {
    background: #94a3b8;
}
.time-slot-btn {
    padding: 14px;
    border: 1px solid #3b82f6; /* Default Blue Border */
    border-radius: 12px;
    background: #eff6ff; /* Default Light Blue Background */
    color: #3b82f6; /* Default Blue Text */
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    text-align: center;
    box-sizing: border-box;
}
.time-slot-btn:hover {
    border-color: #2563eb; /* Darker Blue Border */
    background: #dbeafe; /* Light Blue Background */
    color: #2563eb; /* Darker Blue Text */
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}
.time-slot-btn.selected {
    border-color: #3b82f6;
    background: #3b82f6; /* High contrast Blue selection */
    color: white; /* White text for visibility */
    box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.3);
}
.time-slot-btn.selected:hover {
    background: #2563eb;
    border-color: #2563eb;
    color: white;
}

.slots-footer {
    padding-top: 20px;
    border-top: 1px solid #e2e8f0;
    margin-top: 20px;
    flex-shrink: 0; /* Keep footer size fixed */
}

.book-slot-btn {
    width: 100%;
    padding: 14px 20px;
    background: var(--mp-primary); /* Green button */
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 4px 6px rgba(16, 185, 129, 0.2);
}
.book-slot-btn:hover {
    background: #059669;
    box-shadow: 0 6px 12px rgba(16, 185, 129, 0.3);
}
.book-slot-btn:active {
    transform: scale(0.98);
}

/* Error State */
.booking-error-state {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    padding: 40px;
    min-height: 400px;
}

.booking-error-content {
    text-align: center;
    max-width: 400px;
    width: 100%;
}

.booking-error-icon {
    font-size: 64px;
    color: #ef4444;
    margin-bottom: 24px;
}

.booking-error-title {
    font-size: 24px;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 16px;
}

.booking-error-message {
    font-size: 16px;
    color: #64748b;
    line-height: 1.6;
    margin-bottom: 32px;
}

.booking-error-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 12px 24px;
    background: #3b82f6;
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s;
    justify-content: center;
}

.booking-error-btn:hover {
    background: #2563eb;
    transform: translateY(-1px);
    box-shadow: 0 4px 6px rgba(59, 130, 246, 0.3);
}

.booking-error-btn:active {
    transform: translateY(0);
}

/* Responsiveness for Modal */
@media (max-width: 900px) {
    .booking-grid {
        grid-template-columns: 250px 1fr;
    }
    .booking-slots-col {
        position: absolute;
        top: 0; right: 0; bottom: 0;
        background: white;
        box-shadow: -10px 0 20px rgba(0,0,0,0.1);
        z-index: 10;
    }
}
@media (max-width: 768px) {
    .booking-modal-container {
        height: 100%;
        max-height: 100%;
        width: 100%;
        border-radius: 0;
    }
    .booking-grid {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
    }
    .booking-sidebar {
        padding: 20px;
        border-right: none;
        border-bottom: 1px solid #e2e8f0;
    }
    .booking-mentor-mini { margin-bottom: 16px; }
    .booking-meta { flex-direction: row; gap: 20px; margin-bottom: 16px; font-size: 0.85rem; }
    .booking-desc { display: none; } /* Hide desc on mobile */
    .booking-slots-col {
        width: 100%;
        border-left: none;
    }
}
</style>

<!-- Data Injection for JS -->
{{ mentor_profile.one_time_slots|json_script:"one-time-slots-data" }}
{{ mentor_profile.recurring_slots|json_script:"recurring-slots-data" }}
<script id="mentor-session-length" type="application/json">{{ mentor_profile.session_length|default:60 }}</script>


<script>
    // --- Booking Logic Variables (must be declared first) ---
    // Get user authentication status from Django template
    const isUserAuthenticated = {% if user.is_authenticated %}true{% else %}false{% endif %};
    const userRole = {% if user.is_authenticated %}'{{ user.profile.role|default:"" }}'{% else %}null{% endif %};
    const mentorId = {{ mentor_profile.user.id }};
    const mentorFirstSessionFree = {% if mentor_profile.first_session_free %}true{% else %}false{% endif %};
    const mentorFirstSessionLength = {{ mentor_profile.first_session_length|default:30 }};
    const mentorSessionLength = {{ mentor_profile.session_length|default:60 }};
    const mentorPricePerHour = {{ mentor_profile.price_per_hour|default_if_none:"null" }};
    
    // Detected timezone (will be set on modal open)
    let detectedTimezone = null;
    let selectedTimezone = null;
    let timezoneClockInterval = null;
    let selectedTimezoneClockInterval = null;
    
    // --- Data & State ---
    let availabilityData;
    let sessionLengthMinutes = 60; // Default session length
    let currentDate = new Date(); // To track month view
    let selectedDate = null;
    let selectedSlot = null; // Track selected time slot
    
    // --- DOM Elements ---
    let modal, currentMonthLabel, calendarDays, slotsCol, slotsList, selectedDateLabel, prevMonthBtn, nextMonthBtn, slotsFooter, bookSlotBtn;

    document.addEventListener('DOMContentLoaded', function() {
        // Safe access to data script
        const oneTimeData = document.getElementById('one-time-slots-data');
        const recurringData = document.getElementById('recurring-slots-data');
        const sessionLengthEl = document.getElementById('mentor-session-length');
        
        // Get session length
        if (sessionLengthEl) {
            try {
                sessionLengthMinutes = parseInt(JSON.parse(sessionLengthEl.textContent)) || 60;
            } catch (e) {
                sessionLengthMinutes = 60;
            }
        }
        
        // Parse availability data
        let oneTimeSlots = [];
        let recurringSlots = [];
        
        if (oneTimeData) {
            try {
                oneTimeSlots = JSON.parse(oneTimeData.textContent) || [];
            } catch (e) {
                console.error('Error parsing one-time slots:', e);
            }
        }
        
        if (recurringData) {
            try {
                recurringSlots = JSON.parse(recurringData.textContent) || [];
            } catch (e) {
                console.error('Error parsing recurring slots:', e);
            }
        }
        
        // Filter one-time slots to only include future, non-booked slots
        const now = new Date();
        oneTimeSlots = oneTimeSlots.filter(slot => {
            if (!slot.start || !slot.end) return false;
            if (slot.booked === true) return false;
            
            try {
                const endDate = new Date(slot.end.replace('Z', '+00:00'));
                // Only include slots that end in the future
                return endDate > now;
            } catch (e) {
                return false;
            }
        });
        
        availabilityData = {
            one_time_slots: oneTimeSlots,
            recurring_slots: recurringSlots
        };
        
        modal = document.getElementById('bookingModal');
        currentMonthLabel = document.getElementById('currentMonthLabel');
        calendarDays = document.getElementById('calendarDays');
        slotsCol = document.getElementById('slotsCol');
        slotsList = document.getElementById('slotsList');
        selectedDateLabel = document.getElementById('selectedDateLabel');
        prevMonthBtn = document.getElementById('prevMonth');
        nextMonthBtn = document.getElementById('nextMonth');
        slotsFooter = document.getElementById('slotsFooter');
        bookSlotBtn = document.getElementById('bookSlotBtn');

        bookingSummary = document.getElementById('bookingSummary');
        summaryDate = document.getElementById('summaryDate');
        summaryTimeRow = document.getElementById('summaryTimeRow');
        summaryTime = document.getElementById('summaryTime');
        
        // --- Events ---
        if (prevMonthBtn) prevMonthBtn.onclick = () => {
            currentDate.setMonth(currentDate.getMonth() - 1);
            renderCalendar();
        };
        if (nextMonthBtn) nextMonthBtn.onclick = () => {
            currentDate.setMonth(currentDate.getMonth() + 1);
            renderCalendar();
        };
        
        // Close on click outside
        if (modal) modal.addEventListener('click', (e) => {
            if (e.target === modal) closeBookingModal();
        });
        
        // Close on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal && modal.classList.contains('open')) {
                closeBookingModal();
            }
        });
        
        // Book slot button handler
        if (bookSlotBtn) {
            bookSlotBtn.addEventListener('click', function() {
                if (selectedSlot && selectedDate) {
                    handleBookingClick();
                }
            });
        }
        
        // Email collection form handler
        const emailCollectionForm = document.getElementById('emailCollectionForm');
        if (emailCollectionForm) {
            emailCollectionForm.addEventListener('submit', function(e) {
                e.preventDefault();
                handleEmailCollectionSubmit();
            });
        }
        
        // Timezone confirmation checkbox
        const timezoneConfirmed = document.getElementById('timezoneConfirmed');
        if (timezoneConfirmed) {
            timezoneConfirmed.addEventListener('change', function() {
                const timezoneSelectorWrapper = document.getElementById('timezoneSelectorWrapper');
                if (timezoneSelectorWrapper) {
                    if (this.checked) {
                        // Hide selector, use detected timezone
                        timezoneSelectorWrapper.style.display = 'none';
                        selectedTimezone = detectedTimezone;
                        const bookingTimezoneValue = document.getElementById('bookingTimezoneValue');
                        if (bookingTimezoneValue) {
                            bookingTimezoneValue.value = detectedTimezone;
                        }
                        // Stop selected timezone clock
                        if (selectedTimezoneClockInterval) {
                            clearInterval(selectedTimezoneClockInterval);
                            selectedTimezoneClockInterval = null;
                        }
                        const selectedClockDisplay = document.getElementById('selectedTimezoneClockDisplay');
                        if (selectedClockDisplay) selectedClockDisplay.style.display = 'none';
                    } else {
                        // Show selector, initialize autocomplete
                        timezoneSelectorWrapper.style.display = 'block';
                        initializeBookingTimezoneAutocomplete();
                    }
                }
            });
        }
    });

    // --- Modal Logic ---
    function openBookingModal() {
        if (!modal) return; // Guard clause
        
        // Reset State on Open
        currentDate = new Date(); // Reset to current month
        selectedDate = null;      // Clear selection
        selectedSlot = null;      // Clear slot selection
        if (slotsCol) slotsCol.style.display = 'none'; // Hide slots initially
        if (slotsFooter) slotsFooter.style.display = 'none'; // Hide footer
        if (bookingSummary) bookingSummary.style.display = 'none'; // Hide summary
        
        modal.classList.add('open');
        document.body.style.overflow = 'hidden'; // Prevent background scroll
        renderCalendar();
    }

    function closeBookingModal() {
        if (!modal) return;
        modal.classList.remove('open');
        document.body.style.overflow = '';
        // State is reset on next open, but good to clear view
        selectedDate = null;
        selectedSlot = null;
        if (slotsCol) slotsCol.style.display = 'none';
        if (slotsFooter) slotsFooter.style.display = 'none';
        if (bookingSummary) bookingSummary.style.display = 'none';
        hideBookingError(); // Hide error state when closing
        renderCalendar();
    }
    
    function showBookingError() {
        const errorState = document.getElementById('bookingErrorState');
        const mainContent = document.getElementById('bookingMainContent');
        
        if (errorState) errorState.style.display = 'flex';
        if (mainContent) mainContent.style.display = 'none';
    }
    
    function hideBookingError() {
        const errorState = document.getElementById('bookingErrorState');
        const mainContent = document.getElementById('bookingMainContent');
        
        if (errorState) errorState.style.display = 'none';
        if (mainContent) mainContent.style.display = 'grid';
    }
    
    function closeSlots() {
        if (slotsCol) slotsCol.style.display = 'none';
        if (slotsFooter) slotsFooter.style.display = 'none';
        if (bookingSummary) bookingSummary.style.display = 'none';
        selectedDate = null;
        selectedSlot = null;
        renderCalendar(); // Redraws calendar to remove 'selected' class
    }
    
    // Close on click outside
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeBookingModal();
    });    
        // --- Calendar Logic ---
    function renderCalendar() {
        if (!calendarDays) return;
        
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();

        // Update Header
        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        if (currentMonthLabel) currentMonthLabel.textContent = `${monthNames[month]} ${year}`;

        // Days calculation
        const firstDayOfMonth = new Date(year, month, 1).getDay(); // 0 (Sun) - 6 (Sat)
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        
        // Use a temp date for checking availability
        const today = new Date();
        today.setHours(0,0,0,0);

        calendarDays.innerHTML = '';

        // Empty cells for previous month padding
        for (let i = 0; i < firstDayOfMonth; i++) {
            const emptyCell = document.createElement('div');
            emptyCell.classList.add('cal-day', 'empty');
            calendarDays.appendChild(emptyCell);
        }

        // Days
        for (let day = 1; day <= daysInMonth; day++) {
            const dayEl = document.createElement('div');
            dayEl.classList.add('cal-day');
            dayEl.textContent = day;
            
            const checkDate = new Date(year, month, day);
            checkDate.setHours(0,0,0,0);

            // Disable past dates and today
            if (checkDate <= today) {
                dayEl.classList.add('disabled');
                if (checkDate.getTime() === today.getTime()) {
                    dayEl.classList.add('today');
                }
            } else {
                // Check Availability
                if (hasAvailability(checkDate)) {
                    dayEl.classList.add('has-slots');
                }
                
                dayEl.onclick = () => selectDate(checkDate, dayEl);
            }

            // Selected State
            if (selectedDate && checkDate.getTime() === selectedDate.getTime()) {
                dayEl.classList.add('selected');
            }

            calendarDays.appendChild(dayEl);
        }
    }

    // --- Slot Calculation Logic ---
    function hasAvailability(date) {
        if (!availabilityData) return false;
        
        // Get date string in local timezone (YYYY-MM-DD format)
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const dateStr = `${year}-${month}-${day}`;
        
        const now = new Date();
        // Check if it's today
        const nowYear = now.getFullYear();
        const nowMonth = String(now.getMonth() + 1).padStart(2, '0');
        const nowDay = String(now.getDate()).padStart(2, '0');
        const nowDateStr = `${nowYear}-${nowMonth}-${nowDay}`;
        const isToday = dateStr === nowDateStr;
        
        // 1. One-Time Check
        const hasOneTime = availabilityData.one_time_slots.some(slot => {
            if (!slot.start || !slot.end) return false;
            if (slot.booked === true) return false;
            
            try {
                const slotStart = new Date(slot.start.replace('Z', '+00:00'));
                const slotEnd = new Date(slot.end.replace('Z', '+00:00'));
                
                // Convert slot date to local timezone for comparison
                const slotYear = slotStart.getFullYear();
                const slotMonth = String(slotStart.getMonth() + 1).padStart(2, '0');
                const slotDay = String(slotStart.getDate()).padStart(2, '0');
                const slotDateStr = `${slotYear}-${slotMonth}-${slotDay}`;
                
                if (slotDateStr !== dateStr) return false;
                
                // For today, ensure the slot end is in the future
                // For future dates, any slot is fine
                if (isToday) {
                    return slotEnd > now;
                } else {
                    return slotEnd > now; // Still check future for safety
                }
            } catch (e) {
                return false;
            }
        });
        if (hasOneTime) return true;

        // 2. Recurring Check
        const weekdayMap = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        const dayName = weekdayMap[date.getDay()];
        
        const hasRecurring = availabilityData.recurring_slots.some(rule => {
            if (!rule || !rule.type) return false;
            
            const skipDates = new Set(rule.skip_dates || []);
            const bookedDates = new Set(rule.booked_dates || []);
            
            // Skip if this date is in skip_dates or booked_dates
            if (skipDates.has(dateStr) || bookedDates.has(dateStr)) return false;
            
            // Check if rule applies to this date
            let matches = false;
            if (rule.type === 'daily') {
                matches = true;
            } else if (rule.type === 'weekly') {
                const weekdays = rule.weekdays || [];
                matches = weekdays.includes(dayName);
            } else if (rule.type === 'monthly') {
                const dayOfMonth = rule.day_of_month;
                if (dayOfMonth !== null && dayOfMonth !== undefined) {
                    if (date.getDate() === dayOfMonth) {
                        matches = true;
                    } else if (dayOfMonth > 28) {
                        // Handle edge case: if slot is for day 31 but month doesn't have 31 days
                        const lastDayOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                        if (date.getDate() === lastDayOfMonth && dayOfMonth > lastDayOfMonth) {
                            matches = true;
                        }
                    }
                }
            }
            
            if (!matches) return false;
            
            // For today, check if there are any future slots from this rule
            if (isToday && rule.start_time && rule.end_time) {
                try {
                    const [endH, endM] = rule.end_time.split(':').map(Number);
                    const windowEnd = new Date(date);
                    windowEnd.setHours(endH, endM, 0, 0);
                    return windowEnd > now;
                } catch (e) {
                    return false;
                }
            }
            
            return true;
        });
        
        return hasRecurring;
    }

    function getSlotsForDate(date) {
        if (!availabilityData) return [];

        const slots = [];
        // Get date string in local timezone (YYYY-MM-DD format)
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const dateStr = `${year}-${month}-${day}`;
        
        const weekdayMap = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        const dayName = weekdayMap[date.getDay()];
        const now = new Date();

        // 1. Add One-Time Slots
        availabilityData.one_time_slots.forEach(slot => {
            if (!slot.start || !slot.end) return;
            if (slot.booked === true) return;
            
            try {
                const slotStart = new Date(slot.start.replace('Z', '+00:00'));
                const slotEnd = new Date(slot.end.replace('Z', '+00:00'));
                
                // Convert slot date to local timezone for comparison
                const slotYear = slotStart.getFullYear();
                const slotMonth = String(slotStart.getMonth() + 1).padStart(2, '0');
                const slotDay = String(slotStart.getDate()).padStart(2, '0');
                const slotDateStr = `${slotYear}-${slotMonth}-${slotDay}`;
                
                // Only include slots for this date that end in the future
                if (slotDateStr === dateStr && slotEnd > now) {
                    // Generate time slots from this availability window
                    const windowSlots = generateTimeSlotsFromWindow(slotStart, slotEnd, sessionLengthMinutes);
                    windowSlots.forEach(slotStartTime => {
                        const slotEndTime = new Date(slotStartTime.getTime() + sessionLengthMinutes * 60000);
                        
                        // Format times in 12-hour format with AM/PM
                        // Use local time methods which automatically handle timezone conversion
                        const formatTime = (date) => {
                            // getHours() and getMinutes() already return local time
                            let hours = date.getHours();
                            const minutes = date.getMinutes();
                            const ampm = hours >= 12 ? 'pm' : 'am';
                            hours = hours % 12;
                            hours = hours ? hours : 12; // the hour '0' should be '12'
                            const minutesStr = minutes < 10 ? '0' + minutes : minutes;
                            return `${hours}:${minutesStr} ${ampm}`;
                        };
                        
                        const startTimeStr = formatTime(slotStartTime);
                        const endTimeStr = formatTime(slotEndTime);
                        
                        // Create a unique key for deduplication based on the actual start time
                        const startTimeKey = slotStartTime.getTime(); // Use timestamp for uniqueness
                        
                        slots.push({ 
                            time: `${startTimeStr} - ${endTimeStr}`, 
                            raw: slot, 
                            type: 'one_time',
                            start: slotStartTime.toISOString(),
                            end: slotEndTime.toISOString(),
                            _startTimeKey: startTimeKey, // Internal key for deduplication
                            availability_slot_id: slot.id || null // For one-time slots
                        });
                    });
                }
            } catch (e) {
                console.error('Error processing one-time slot:', e);
            }
        });

        // 2. Generate Recurring Slots
        availabilityData.recurring_slots.forEach(rule => {
            if (!rule || !rule.type) return;
            
            const skipDates = new Set(rule.skip_dates || []);
            const bookedDates = new Set(rule.booked_dates || []);
            
            // Skip if this date is in skip_dates or booked_dates
            if (skipDates.has(dateStr) || bookedDates.has(dateStr)) return;
            
            let matches = false;
            
            if (rule.type === 'daily') {
                matches = true;
            } else if (rule.type === 'weekly') {
                const weekdays = rule.weekdays || [];
                matches = weekdays.includes(dayName);
            } else if (rule.type === 'monthly') {
                const dayOfMonth = rule.day_of_month;
                if (dayOfMonth !== null && dayOfMonth !== undefined) {
                    if (date.getDate() === dayOfMonth) {
                        matches = true;
                    } else if (dayOfMonth > 28) {
                        // Handle edge case: if slot is for day 31 but month doesn't have 31 days
                        const lastDayOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                        if (date.getDate() === lastDayOfMonth && dayOfMonth > lastDayOfMonth) {
                            matches = true;
                        }
                    }
                }
            }
            
            if (matches && rule.start_time && rule.end_time) {
                try {
                    // Parse start and end times
                    const [startH, startM] = rule.start_time.split(':').map(Number);
                    const [endH, endM] = rule.end_time.split(':').map(Number);
                    
                    // Create datetime objects for this specific date
                    const windowStart = new Date(date);
                    windowStart.setHours(startH, startM, 0, 0);
                    
                    const windowEnd = new Date(date);
                    windowEnd.setHours(endH, endM, 0, 0);
                    
                    // Only include if the window end is in the future
                    if (windowEnd > now) {
                        const windowSlots = generateTimeSlotsFromWindow(windowStart, windowEnd, sessionLengthMinutes);
                        windowSlots.forEach(slotStart => {
                            const slotEnd = new Date(slotStart.getTime() + sessionLengthMinutes * 60000);
                            
                            // Format times in 12-hour format with AM/PM
                            const formatTime = (date) => {
                                let hours = date.getHours();
                                const minutes = date.getMinutes();
                                const ampm = hours >= 12 ? 'pm' : 'am';
                                hours = hours % 12;
                                hours = hours ? hours : 12; // the hour '0' should be '12'
                                const minutesStr = minutes < 10 ? '0' + minutes : minutes;
                                return `${hours}:${minutesStr} ${ampm}`;
                            };
                            
                            const startTimeStr = formatTime(slotStart);
                            const endTimeStr = formatTime(slotEnd);
                            
                            // Create a unique key for deduplication based on the actual start time
                            const startTimeKey = slotStart.getTime(); // Use timestamp for uniqueness
                            
                            // Get date string for recurring slots (YYYY-MM-DD)
                            const slotDateStr = `${slotStart.getFullYear()}-${String(slotStart.getMonth() + 1).padStart(2, '0')}-${String(slotStart.getDate()).padStart(2, '0')}`;
                            
                            slots.push({ 
                                time: `${startTimeStr} - ${endTimeStr}`, 
                                raw: rule, 
                                type: 'recurring',
                                start: slotStart.toISOString(),
                                end: slotEnd.toISOString(),
                                _startTimeKey: startTimeKey, // Internal key for deduplication
                                recurring_id: rule.id || null, // For recurring slots
                                instance_date: slotDateStr // Date string (YYYY-MM-DD format)
                            });
                        });
                    }
                } catch (e) {
                    console.error('Error processing recurring slot:', e);
                }
            }
        });

        // Sort by start time and remove duplicates based on actual start timestamp
        const uniqueSlots = [];
        const seenStartTimes = new Set();
        
        slots.sort((a, b) => {
            // Sort by actual start time (timestamp)
            const timeA = a._startTimeKey || (a.start ? new Date(a.start).getTime() : 0);
            const timeB = b._startTimeKey || (b.start ? new Date(b.start).getTime() : 0);
            return timeA - timeB;
        }).forEach(slot => {
            // Use the timestamp for deduplication (most reliable)
            const startTimeKey = slot._startTimeKey || (slot.start ? new Date(slot.start).getTime() : null);
            if (startTimeKey !== null && !seenStartTimes.has(startTimeKey)) {
                seenStartTimes.add(startTimeKey);
                // Remove the internal key before returning
                delete slot._startTimeKey;
                uniqueSlots.push(slot);
            }
        });
        
        return uniqueSlots;
    }
    
    // Helper function to generate time slots from an availability window
    function generateTimeSlotsFromWindow(windowStart, windowEnd, slotLengthMinutes) {
        const slots = [];
        const now = new Date();
        
        let currentTime = new Date(windowStart);
        
        while (currentTime < windowEnd) {
            const slotEnd = new Date(currentTime.getTime() + slotLengthMinutes * 60000);
            
            if (slotEnd <= windowEnd && slotEnd > now) {
                // Return the actual Date object for robust formatting later
                slots.push(new Date(currentTime));
            }
            
            currentTime = new Date(currentTime.getTime() + slotLengthMinutes * 60000);
        }
        
        return slots;
    }

    function selectDate(date, dayEl) {
        selectedDate = date;
        selectedSlot = null; // Clear slot selection when date changes
        renderCalendar(); // Refresh calendar to show selected date
        
        // Show Slots
        if (slotsCol) slotsCol.style.display = 'flex';
        const dateOptions = {weekday: 'long', month: 'short', day: 'numeric'};
        const formattedDate = date.toLocaleDateString([], dateOptions);
        if (selectedDateLabel) selectedDateLabel.textContent = formattedDate;
        
        // Update Sidebar Summary
        if (bookingSummary) bookingSummary.style.display = 'block';
        if (summaryDate) summaryDate.textContent = formattedDate;
        if (summaryTimeRow) summaryTimeRow.style.display = 'none'; // Hide time until slot selected
        
        renderSlots(date);
    }

    function renderSlots(date) {
        const slots = getSlotsForDate(date);
        if (slotsList) {
            slotsList.innerHTML = '';
            
            if (slots.length === 0) {
                slotsList.innerHTML = '<div style="color: #94a3b8; font-style: italic;">No available slots.</div>';
                if (slotsFooter) slotsFooter.style.display = 'none';
            } else {
                slots.forEach((slot, index) => {
                    const btn = document.createElement('button');
                    btn.classList.add('time-slot-btn');
                    btn.textContent = slot.time;
                    btn.dataset.slotIndex = index;
                    btn.onclick = () => {
                        // Remove selected class from all buttons
                        slotsList.querySelectorAll('.time-slot-btn').forEach(b => b.classList.remove('selected'));
                        // Add selected class to clicked button
                        btn.classList.add('selected');
                        selectedSlot = slot;
                        
                        // Show book button
                        if (slotsFooter) slotsFooter.style.display = 'block';

                        // Update Sidebar Summary Time
                        if (summaryTimeRow) summaryTimeRow.style.display = 'flex';
                        if (summaryTime) summaryTime.textContent = slot.time;
                    };
                    slotsList.appendChild(btn);
                });
                // Hide footer initially (will show when slot is selected)
                if (slotsFooter) slotsFooter.style.display = 'none';
            }
        }
    }
    
    // --- Booking Logic Functions ---
    function handleBookingClick() {
        if (!selectedSlot || !selectedDate) {
            return;
        }
        
        // Check authentication
        if (isUserAuthenticated) {
            if (userRole === 'mentor') {
                // Show error state in modal for mentors
                showBookingError();
                return;
            } else if (userRole === 'user') {
                // Logged-in user - proceed directly to booking
                submitBooking();
                return;
            }
        }
        
        // Not logged in - show email collection modal
        openEmailCollectionModal();
    }
    
    // Helper functions for time formatting
    function formatTime(date, timezone) {
        try {
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: timezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            });
            return formatter.format(date);
        } catch (e) {
            return 'Unable to format time';
        }
    }
    
    function formatDate(date, timezone) {
        try {
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: timezone,
                weekday: 'short',
                month: 'short',
                day: 'numeric'
            });
            return formatter.format(date);
        } catch (e) {
            return 'Unable to format date';
        }
    }
    
    function updateTimezoneClock(timezone, timeEl, dateEl) {
        if (!timezone || !timeEl) return;
        
        const now = new Date();
        const timeStr = formatTime(now, timezone);
        if (timeEl) timeEl.textContent = timeStr;
        
        if (dateEl) {
            const dateStr = formatDate(now, timezone);
            dateEl.textContent = dateStr;
        }
    }
    
    function startTimezoneClock(timezone) {
        // Clear any existing interval
        if (timezoneClockInterval) {
            clearInterval(timezoneClockInterval);
        }
        
        const timeEl = document.getElementById('timezoneCurrentTime');
        const dateEl = document.getElementById('timezoneCurrentDate');
        
        // Update immediately
        updateTimezoneClock(timezone, timeEl, dateEl);
        
        // Update every second
        timezoneClockInterval = setInterval(() => {
            updateTimezoneClock(timezone, timeEl, dateEl);
        }, 1000);
    }
    
    function startSelectedTimezoneClock(timezone) {
        // Clear any existing interval
        if (selectedTimezoneClockInterval) {
            clearInterval(selectedTimezoneClockInterval);
        }
        
        const timeEl = document.getElementById('selectedTimezoneCurrentTime');
        const dateEl = document.getElementById('selectedTimezoneCurrentDate');
        const clockDisplay = document.getElementById('selectedTimezoneClockDisplay');
        
        if (!timezone || !timeEl) {
            if (clockDisplay) clockDisplay.style.display = 'none';
            return;
        }
        
        if (clockDisplay) clockDisplay.style.display = 'block';
        
        // Update immediately
        updateTimezoneClock(timezone, timeEl, dateEl);
        
        // Update every second
        selectedTimezoneClockInterval = setInterval(() => {
            updateTimezoneClock(timezone, timeEl, dateEl);
        }, 1000);
    }
    
    function stopTimezoneClocks() {
        if (timezoneClockInterval) {
            clearInterval(timezoneClockInterval);
            timezoneClockInterval = null;
        }
        if (selectedTimezoneClockInterval) {
            clearInterval(selectedTimezoneClockInterval);
            selectedTimezoneClockInterval = null;
        }
    }
    
    function openEmailCollectionModal() {
        const emailModal = document.getElementById('emailCollectionModal');
        if (!emailModal) return;
        
        // Detect timezone
        try {
            detectedTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            selectedTimezone = detectedTimezone;
            
            // Update timezone display using TIMEZONE_OPTIONS if available
            const detectedTimezoneName = document.getElementById('detectedTimezoneName');
            if (detectedTimezoneName) {
                let tzDisplay = detectedTimezone;
                let offset = '';
                
                // Try to use TIMEZONE_OPTIONS from timezone-checker.js
                if (window.TIMEZONE_OPTIONS && window.TIMEZONE_OPTIONS.length > 0) {
                    const tzObj = window.TIMEZONE_OPTIONS.find(tz => tz.id === detectedTimezone);
                    if (tzObj) {
                        tzDisplay = tzObj.name;
                        // Get current offset (handles DST)
                        const now = new Date();
                        const formatter = new Intl.DateTimeFormat('en', {
                            timeZone: detectedTimezone,
                            timeZoneName: 'longOffset'
                        });
                        const parts = formatter.formatToParts(now);
                        const offsetPart = parts.find(p => p.type === 'timeZoneName');
                        offset = offsetPart ? offsetPart.value : '';
                    }
                } else {
                    // Fallback: format manually
                    const tzParts = detectedTimezone.split('/');
                    const tzCity = tzParts[tzParts.length - 1] || detectedTimezone;
                    tzDisplay = tzCity.replace(/_/g, ' ');
                    
                    const now = new Date();
                    const formatter = new Intl.DateTimeFormat('en', {
                        timeZone: detectedTimezone,
                        timeZoneName: 'longOffset'
                    });
                    const parts = formatter.formatToParts(now);
                    const offsetPart = parts.find(p => p.type === 'timeZoneName');
                    offset = offsetPart ? offsetPart.value : '';
                }
                
                detectedTimezoneName.textContent = offset ? `${tzDisplay} (${offset})` : tzDisplay;
            }
            
            // Set hidden timezone value
            const bookingTimezoneValue = document.getElementById('bookingTimezoneValue');
            if (bookingTimezoneValue) {
                bookingTimezoneValue.value = detectedTimezone;
            }
            
            // Start live clock
            startTimezoneClock(detectedTimezone);
        } catch (e) {
            console.error('Error detecting timezone:', e);
            detectedTimezone = 'UTC';
            selectedTimezone = 'UTC';
            startTimezoneClock('UTC');
        }
        
        // Calculate and display price
        updatePriceDisplay();
        
        // Update session recap
        updateSessionRecap();
        
        // Reset form
        const emailForm = document.getElementById('emailCollectionForm');
        if (emailForm) emailForm.reset();
        const emailError = document.getElementById('emailError');
        if (emailError) {
            emailError.style.display = 'none';
            emailError.textContent = '';
        }
        
        // Show modal
        emailModal.style.display = 'flex';
        setTimeout(() => {
            emailModal.style.opacity = '1';
        }, 10);
        
        // Focus email input
        const emailInput = document.getElementById('bookingEmailInput');
        if (emailInput) emailInput.focus();
    }
    
    function closeEmailCollectionModal() {
        const emailModal = document.getElementById('emailCollectionModal');
        if (!emailModal) return;
        
        // Stop clocks
        stopTimezoneClocks();
        
        emailModal.style.opacity = '0';
        setTimeout(() => {
            emailModal.style.display = 'none';
        }, 300);
    }
    
    function updatePriceDisplay() {
        const priceDisplay = document.getElementById('bookingPriceDisplay');
        const priceNote = document.getElementById('bookingPriceNote');
        
        if (!priceDisplay) return;
        
        // For new users, first session is always free if mentor has it enabled
        if (mentorFirstSessionFree) {
            priceDisplay.innerHTML = '$0 <span style="font-size: 0.85rem; font-weight: 600;">(First Session Free)</span>';
            if (priceNote) {
                priceNote.style.display = 'block';
                priceNote.textContent = 'This is your first session with this mentor';
            }
        } else {
            const price = mentorPricePerHour || 0;
            priceDisplay.textContent = `$${price}`;
            if (priceNote) {
                priceNote.style.display = 'none';
            }
        }
    }
    
    function updateSessionRecap() {
        if (!selectedSlot || !selectedDate) {
            const recapDate = document.getElementById('recapDate');
            const recapTime = document.getElementById('recapTime');
            const recapLength = document.getElementById('recapLength');
            if (recapDate) recapDate.textContent = '--';
            if (recapTime) recapTime.textContent = '--';
            if (recapLength) recapLength.textContent = '--';
            return;
        }
        
        const recapDate = document.getElementById('recapDate');
        const recapTime = document.getElementById('recapTime');
        const recapLength = document.getElementById('recapLength');
        
        if (!recapDate || !recapTime || !recapLength) return;
        
        // Format date
        const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
        const formattedDate = selectedDate.toLocaleDateString('en-US', dateOptions);
        recapDate.textContent = formattedDate;
        
        // Format time (from selectedSlot.time which is already formatted)
        recapTime.textContent = selectedSlot.time || '--';
        
        // Determine session length based on first session free logic
        // Same logic as in the booking modal sidebar
        let sessionLengthMinutes = mentorSessionLength;
        let lengthDisplay = `${mentorSessionLength} minutes`;
        
        if (mentorFirstSessionFree) {
            // If first session free is enabled, show both lengths like in the booking modal
            // For non-logged-in users, it's always a first session
            // For logged-in users, we can't determine without backend, so show the actual slot duration
            if (!isUserAuthenticated) {
                // Not logged in - always first session if first_session_free is enabled
                sessionLengthMinutes = mentorFirstSessionLength;
                lengthDisplay = `${mentorFirstSessionLength} minutes (First Session)`;
            } else {
                // Logged in - use actual slot duration (can't determine if first session without backend)
                try {
                    const startDate = new Date(selectedSlot.start);
                    const endDate = new Date(selectedSlot.end);
                    const diffMs = endDate.getTime() - startDate.getTime();
                    const calculatedMinutes = Math.round(diffMs / (1000 * 60));
                    sessionLengthMinutes = calculatedMinutes;
                    lengthDisplay = `${calculatedMinutes} minutes`;
                } catch (e) {
                    // Fallback: show both like in booking modal
                    lengthDisplay = `${mentorFirstSessionLength} min (First Session) / ${mentorSessionLength} min (Regular)`;
                }
            }
        } else {
            // No first session free - use regular session length or calculated duration
            try {
                const startDate = new Date(selectedSlot.start);
                const endDate = new Date(selectedSlot.end);
                const diffMs = endDate.getTime() - startDate.getTime();
                const calculatedMinutes = Math.round(diffMs / (1000 * 60));
                sessionLengthMinutes = calculatedMinutes;
                lengthDisplay = `${calculatedMinutes} minutes`;
            } catch (e) {
                lengthDisplay = `${mentorSessionLength} minutes`;
            }
        }
        
        recapLength.textContent = lengthDisplay;
    }
    
    function handleEmailCollectionSubmit() {
        const emailInput = document.getElementById('bookingEmailInput');
        const noteInput = document.getElementById('bookingNoteInput');
        const timezoneConfirmed = document.getElementById('timezoneConfirmed');
        const bookingTimezoneValue = document.getElementById('bookingTimezoneValue');
        const emailError = document.getElementById('emailError');
        const submitBtn = document.getElementById('submitBookingBtn');
        
        if (!emailInput || !submitBtn) return;
        
        const email = emailInput.value.trim();
        
        // Validate email
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!email || !emailRegex.test(email)) {
            if (emailError) {
                emailError.textContent = 'Please enter a valid email address';
                emailError.style.display = 'block';
            }
            return;
        }
        
        // Get timezone
        let timezone = detectedTimezone || 'UTC';
        if (timezoneConfirmed && !timezoneConfirmed.checked && bookingTimezoneValue) {
            timezone = bookingTimezoneValue.value || detectedTimezone || 'UTC';
        }
        
        const note = noteInput ? noteInput.value.trim() : '';
        
        // Disable button
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>Booking...</span>';
        
        // Hide error
        if (emailError) {
            emailError.style.display = 'none';
        }
        
        // Submit booking
        submitBooking(email, note, timezone);
    }
    
    function submitBooking(email = null, note = null, timezone = null) {
        if (!selectedSlot || !selectedDate) {
            return;
        }
        
        // Prepare payload
        const payload = {
            mentor_id: mentorId,
            start_datetime: selectedSlot.start,
            end_datetime: selectedSlot.end,
            is_logged_in: isUserAuthenticated
        };
        
        // Add availability slot info
        if (selectedSlot.type === 'one_time' && selectedSlot.availability_slot_id) {
            payload.availability_slot_id = selectedSlot.availability_slot_id;
        } else if (selectedSlot.type === 'recurring' && selectedSlot.recurring_id && selectedSlot.instance_date) {
            payload.recurring_id = selectedSlot.recurring_id;
            payload.instance_date = selectedSlot.instance_date;
        }
        
        // Add email/note/timezone if not logged in
        if (!isUserAuthenticated) {
            if (email) payload.email = email;
            if (note) payload.note = note;
            if (timezone) payload.timezone = timezone;
        }
        
        // Get CSRF token
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        const csrftoken = getCookie('csrftoken');
        
        // Make API call
        fetch('{% url "general:dashboard_user:book_session" %}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify(payload)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Close modals
                closeBookingModal();
                closeEmailCollectionModal();
                
                // Show success message
                if (typeof showNotification !== 'undefined') {
                    if (isUserAuthenticated) {
                        showNotification('Session booked successfully! Check your session management page.', 'success');
                        // Redirect to session management after a delay
                        setTimeout(() => {
                            window.location.href = '{% url "general:dashboard_user:session_management" %}';
                        }, 1500);
                    } else {
                        showNotification('Session booked! Please check your email to complete registration and confirm your session.', 'success');
                    }
                } else {
                    alert(isUserAuthenticated ? 
                        'Session booked successfully! Redirecting to session management...' : 
                        'Session booked! Please check your email to complete registration.');
                    if (isUserAuthenticated) {
                        setTimeout(() => {
                            window.location.href = '{% url "general:dashboard_user:session_management" %}';
                        }, 1500);
                    }
                }
            } else {
                // Show error
                const errorMsg = data.error || 'Failed to book session. Please try again.';
                if (typeof showNotification !== 'undefined') {
                    showNotification(errorMsg, 'error');
                } else {
                    alert(errorMsg);
                }
                
                // Re-enable button
                const submitBtn = document.getElementById('submitBookingBtn');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="fas fa-calendar-check"></i> <span>Book Session</span>';
                }
            }
        })
        .catch(error => {
            console.error('Booking error:', error);
            const errorMsg = 'An error occurred while booking. Please try again.';
            if (typeof showNotification !== 'undefined') {
                showNotification(errorMsg, 'error');
            } else {
                alert(errorMsg);
            }
            
            // Re-enable button
            const submitBtn = document.getElementById('submitBookingBtn');
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.innerHTML = '<i class="fas fa-calendar-check"></i> <span>Book Session</span>';
            }
        });
    }
    
    // Initialize timezone autocomplete for email collection modal
    function initializeBookingTimezoneAutocomplete() {
        const timezoneInput = document.getElementById('bookingTimezoneInput');
        const timezoneValue = document.getElementById('bookingTimezoneValue');
        const timezoneSuggestions = document.getElementById('bookingTimezoneSuggestions');
        
        if (!timezoneInput || !timezoneValue || !timezoneSuggestions) return;
        
        // Use TIMEZONE_OPTIONS from timezone-checker.js if available
        const timezones = window.TIMEZONE_OPTIONS || [];
        
        if (timezones.length === 0) {
            // Fallback: build timezone list
            let ids = [];
            try {
                if (typeof Intl.supportedValuesOf === 'function') {
                    ids = Intl.supportedValuesOf('timeZone');
                }
            } catch (e) {
                ids = ['UTC', 'America/New_York', 'Europe/London', 'Asia/Tokyo', 'Australia/Sydney'];
            }
            
            // Simple timezone list for autocomplete
            timezones = ids.map(id => ({
                id: id,
                name: id.split('/').pop().replace(/_/g, ' ')
            }));
        }
        
        if (timezones.length === 0) {
            console.warn('TIMEZONE_OPTIONS not available, waiting for timezone-checker.js to load...');
            // Wait a bit and try again
            setTimeout(initializeBookingTimezoneAutocomplete, 500);
            return;
        }
        
        // Use the same autocomplete function from timezone-checker.js if available
        if (typeof window.initializeTimezoneAutocomplete === 'function') {
            window.initializeTimezoneAutocomplete(
                timezoneInput,
                timezoneValue,
                timezoneSuggestions,
                timezones,
                function(selectedTzObj) {
                    // When timezone is selected
                    selectedTimezone = selectedTzObj.id;
                    timezoneValue.value = selectedTzObj.id;
                    
                    // Update and start clock for selected timezone
                    startSelectedTimezoneClock(selectedTzObj.id);
                }
            );
        } else {
            // Fallback: simple autocomplete implementation
            function filterTimezones(query) {
                if (!query || query.trim() === '') {
                    return timezones.slice(0, 20); // Show first 20 if empty
                }
                const lowerQuery = query.toLowerCase();
                return timezones.filter(tz => 
                    (tz.name && tz.name.toLowerCase().includes(lowerQuery)) ||
                    (tz.region && tz.region.toLowerCase().includes(lowerQuery)) ||
                    (tz.id && tz.id.toLowerCase().includes(lowerQuery)) ||
                    (tz.offset && tz.offset.toLowerCase().includes(lowerQuery))
                ).slice(0, 20);
            }
            
            function displaySuggestions(suggestions) {
                if (suggestions.length === 0) {
                    timezoneSuggestions.style.display = 'none';
                    return;
                }
                
                timezoneSuggestions.innerHTML = '';
                suggestions.forEach(tz => {
                    const item = document.createElement('div');
                    item.className = 'suggestion-item';
                    item.style.cssText = 'cursor: pointer; padding: 12px 16px; border-bottom: 1px solid #e2e8f0; transition: background 0.2s;';
                    item.innerHTML = `<div style="font-weight: 600; color: #1e293b;">${tz.name || tz.id}</div><div style="font-size: 0.85rem; color: #64748b;">${tz.offset || ''}</div>`;
                    item.addEventListener('mouseenter', function() {
                        this.style.background = '#f1f5f9';
                    });
                    item.addEventListener('mouseleave', function() {
                        this.style.background = 'transparent';
                    });
                    item.addEventListener('click', function() {
                        timezoneInput.value = (tz.name || tz.id) + (tz.offset ? ' (' + tz.offset + ')' : '');
                        timezoneValue.value = tz.id;
                        timezoneSuggestions.style.display = 'none';
                        selectedTimezone = tz.id;
                        
                        // Update and start clock for selected timezone
                        startSelectedTimezoneClock(tz.id);
                    });
                    timezoneSuggestions.appendChild(item);
                });
                
                timezoneSuggestions.style.display = 'block';
            }
            
            timezoneInput.addEventListener('input', function() {
                const query = this.value.trim();
                displaySuggestions(filterTimezones(query));
            });
            
            timezoneInput.addEventListener('focus', function() {
                const query = this.value.trim();
                displaySuggestions(filterTimezones(query));
            });
            
            // Close on outside click
            document.addEventListener('click', function(e) {
                if (timezoneInput && !timezoneInput.contains(e.target) && 
                    timezoneSuggestions && !timezoneSuggestions.contains(e.target)) {
                    timezoneSuggestions.style.display = 'none';
                }
            });
        }
    }
</script>

